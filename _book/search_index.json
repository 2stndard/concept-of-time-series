[["시계열-데이터-handling.html", "Chapter 4 시계열 데이터 Handling", " Chapter 4 시계열 데이터 Handling 이 장에서는 시계열 데이터를 시간단위로 다루는 방법을 설명할 것이다. 우리는 시간 단위로 기록된 데이터를 항상 다루어왔다. 데이터의 월 평균, 데이터의 전월 대비 변동량 등을 산출하기 위해서는 데이터를 월 단위로 구분하여 평균을 구하거나 전월 데이터를 산출하여 당월 데이터와의 차이를 구하는 등의 작업을 해야한다. R에서 주로 사용하는 data.frame에서는 행렬 인덱스나 조건을 []를 이용하여 전달함으로써 데이터를 검색하고 일부 데이터를 subsetting하거나 dplyr 패키지에서 제공하는 select, filter, group_by, arrange, mutate 등의 함수를 많이 사용하여 작업을 수행할 수 있다. 물론 data.frame에 저장된 시계열 데이터는 dplyr에서 제공하는 함수를 사용할 수 있지만 ts나 xts의 시계열 class의 객체에 대해서는 적용이 되지 않는다. 또한 시계열 데이터는 타 데이터에는 없는 시간적 특성(예를 들어 1분은 60초, 국가마다 년, 월을 표현하하는 방식의 차이, Time Zone)이 있기 때문에 이를 잘 활용하기 위해서는 시계열 데이터의 핸들링 방법을 익혀둘 필요가 있다. 시간을 주로 다루는 ‘lubridate’ 패키지는 시간을 다루기 위한 많은 함수를 제공하는데 이 장에서는 시계열 데이터를 잘 활용하기 위해 lubridate 패키지를 활용하여 시간 인덱스를 다루는 방법에 대해 설명하고자 한다. "],["시계열-데이터-정보-다루기.html", "4.1 시계열 데이터 정보 다루기", " 4.1 시계열 데이터 정보 다루기 4.1.1 시계열 정보 추출 시계열 데이터는 년, 월, 일, 시, 분, 초, 타임존 등의 여러 데이터가 결합되어 생성된 시간을 인덱스로 사용하는 데이터이다. 그래서 시계열 데이터를 잘 활용하기 위해서는 시간 인덱스의 여러 요소들을 추출해내야 목적에 맞는 활용이 가능해진다. 함수명 설명 함수명 설명 함수명 설명 year() 연도 추출 hour() 시간 추출 week() 1월1일으로부터의 주수 month() 월 추출 minute() 분 추출 quater(), semester() 1월1일으로부터의 분기수, 반기수 day() 일 추출 second() 초 추출 am(), pm() 오전, 오후의 논리값 wday() 요일 추출 yday() 1월1일으로부터의 날수 leap_year() 윤년 여부의 논리값 library(lubridate) test.time.date &lt;- Sys.time() test.time.char &lt;- as.character(Sys.time()) test.time.xts &lt;- as.xts(Sys.time()) year(test.time.date) ## [1] 2021 month(test.time.char) ## [1] 2 day(test.time.xts) ## [1] 15 yday(test.time.date) ## [1] 46 qday(test.time.char) ## [1] 46 wday(test.time.xts, label = T, abbr = T) ## [1] 월 ## Levels: 일 &lt; 월 &lt; 화 &lt; 수 &lt; 목 &lt; 금 &lt; 토 hour(test.time.date) ## [1] 18 minute(test.time.char) ## [1] 26 second(test.time.xts) ## [1] 22.99533 week(test.time.date) ## [1] 7 quarter(test.time.char, with_year = T) ## [1] 2021.1 semester(test.time.xts, with_year = T) ## [1] 2021.1 am(test.time.date) ## [1] FALSE pm(test.time.char) ## [1] TRUE leap_year(test.time.date) ## [1] FALSE 4.1.2 시계열 데이터 연산 시간의 연산은 일반적으로 오늘로부터 며칠후, 언제로부터 몇개월전 등과 같은 연산을 의미한다. lubridate 패키지에서는 시간의 연산을 위해 몇개의 함수를 제공하는데 다음과 같은 연산들을 지원한다. 다만 앞선 장에서는 ts 와 xts 클래스의 시계열 객체는 본 절에서 다루는 시계열 데이터 연산 중 일부가 지원되지 않기 때문에 llubridate 패키지에서 제공하는 data.frame 클래스의 시간 더하기/빼기 lubridate 패키지에서는 시간의 더하기나 빼기 연산을 지원한다. 일반적인 정수를 이용하여 더하거나 빼면 일을 기준으로 과거나 미래를 산출할 수 있고 lubridate에서 제공하는 years(), months(), days() 등의 함수를 이용하면 년단위, 월단위, 일단위의 연산도 가능하다. as.Date(&#39;2021-01-01&#39;) - as.Date(&#39;1980-01-01&#39;) # 1980년 1월 1일 이후 날짜 수 ## Time difference of 14976 days today &lt;- today() today + 100 # 오늘부터 100일 후 ## [1] &quot;2021-05-26&quot; today - months(2) # 오늘부터 2개월 전 ## [1] &quot;2020-12-15&quot; today - years(1) #오늘부터 1년전 ## [1] &quot;2020-02-15&quot; 시계열 데이터 기간 앞선 예에서 1980년 1월 1일부터 오늘까지는 14,976일로 계산되었다. 그러나 우리는 보통 몇년 몇월 몇일로 표현된다. lubridate에서는 이렇게 몇년 몇월 몇일로 변환하는 것을 interval()함수를 사용하여 계산한다. 하지만 바로 계산되는 것은 아니고 interval()함수에 의해 반환되는 값은 interval 클래스의 데이터값으로 시작점으로부터의 초를 기록한다. 이렇게 변환된 interval 객체를 올바르게 표현하기 위해서는 interval 객체를 period 나 duration 클래스 객체로 변환하여야 한다. interval 함수는 함수형태로 사용이 가능하고 %–% 연산자를 사용할 수도 있다. library(lubridate) interval &lt;- interval(as.Date(&#39;1980-01-01&#39;), as.Date(&#39;2021-12-31&#39;)) as.period(interval) # 년월일 형태로 기간 반환 ## [1] &quot;41y 11m 30d 0H 0M 0S&quot; as.duration(interval) # 경과 초 형태로 기간 반환 ## [1] &quot;1325376000s (~42 years)&quot; interval &lt;- &#39;1980-01-01&#39; %--% &#39;2021-12-31&#39; as.period(interval) # 년월일 형태로 기간 반환 ## [1] &quot;41y 11m 30d 0H 0M 0S&quot; 위의 예제와 같이 internal은 시간 범위(time spans)를 표현하는데 lubridate는 period와 duration의 두가지 시간 범위(time spans) 클래스를 제공한다. lubridate에서 제공하는 period 함수는 복수형태(years(), months() 등)로 표현된 함수를 사용하고 duration 함수는 함수의 접두어를 ’d’를 사용하여 표현한다. 두가지 형태의 internal을 제공하는 이유는 시간의 타임라인은 숫자의 라인과 동일하지 않기 때문이다. duration은 항상 수학적으로 동일한 결과를 제공한다. 하지만 period는 우리가 흔히 생각하는 시간 범위의 결과를 제공한다. 예를 들어 duration의 1년 후는 시작일로부터 365일 후가 되는 날짜를 리턴하지만 period의 1년 후는 연도가 1이 더해진 날짜를 리턴한다. 두가지의 결과가 동일할 것이라고 생각되지만 윤년이 낀 경우는 duration의 결과는 period의 결과와 달라진다. 또 duration 함수에 정수 시퀀스를 넣어주면 해당 연산에 의한 vector값이 얻어진다.2 as.Date(&#39;2012-01-01&#39;) + years(1) ### 2011-01-01부터 1년 후(period) ## [1] &quot;2013-01-01&quot; as.Date(&#39;2012-01-01&#39;) + dyears(1) ### 2011-01-01부터 1년 후(duration) ## [1] &quot;2012-12-31 06:00:00 UTC&quot; leap_year(2012) ## [1] TRUE as.Date(&#39;2012-01-01&#39;) + years(1) ### 2012-01-01부터 1년 후 period이므로 윤년효과 없이 2013-01-01 반환 ## [1] &quot;2013-01-01&quot; as.Date(&#39;2012-01-01&#39;) + dyears(1) ### 2012-01-01부터 1년 후인데 duration이므로 윤년효과로 365일 후인 2012-12-31일 반환 ## [1] &quot;2012-12-31 06:00:00 UTC&quot; as.Date(&#39;2011-01-01&#39;) + weeks(0:10) ### 2011-01-01부터 일주일씩 11주 같은 요일 날짜 ## [1] &quot;2011-01-01&quot; &quot;2011-01-08&quot; &quot;2011-01-15&quot; &quot;2011-01-22&quot; &quot;2011-01-29&quot; ## [6] &quot;2011-02-05&quot; &quot;2011-02-12&quot; &quot;2011-02-19&quot; &quot;2011-02-26&quot; &quot;2011-03-05&quot; ## [11] &quot;2011-03-12&quot; as.Date(&#39;2012-01-01&#39;) + dweeks(0:10) ### 2012-01-01부터 일주일씩 11주 같은 요일 날짜(윤년때문에 2011과 다르다) ## [1] &quot;2012-01-01&quot; &quot;2012-01-08&quot; &quot;2012-01-15&quot; &quot;2012-01-22&quot; &quot;2012-01-29&quot; ## [6] &quot;2012-02-05&quot; &quot;2012-02-12&quot; &quot;2012-02-19&quot; &quot;2012-02-26&quot; &quot;2012-03-04&quot; ## [11] &quot;2012-03-11&quot; 4.1.3 시계열 데이터 반올림 시간의 계산에서도 숫자의 계산과 같이 올림, 내림, 반올림 등이 가능하다. 숫자의 계산에서는 소수점 세째자리, 천단위 반올림, 올림 등과 같이 반올림될 단위를 지정해야 하는데 시간의 올림, 반올림 연산에도 월에서 반올림을 할것인지 일에서 반올림을 할 것인지와 같은 단위를 지정해야 한다.3 lubridate 패키지 lubridate 패키지에서는 시간 데이터의 반올림을 위해 round_date(), 내림을 위해 floor_date(), 올림을 위해 ceiling_date() 함수를 제공한다. 매개변수로 ‘day,’ ‘week,’ ‘month,’ ‘halfyear,’ ‘year’ 등을 설정하여 반올림, 올림, 내림의 기본 단위를 지정할 수 있다. x &lt;- as.Date(&quot;2009-08-03&quot;) round_date(x, &quot;day&quot;) # 일단위로 반올림 ## [1] &quot;2009-08-03&quot; round_date(x, &quot;week&quot;) # 주단위로 반올림 ## [1] &quot;2009-08-02&quot; round_date(x, &quot;month&quot;) # 월단위로 반올림 ## [1] &quot;2009-08-01&quot; round_date(x, &quot;halfyear&quot;) # 반기단위로 반올림 ## [1] &quot;2009-07-01&quot; round_date(x, &quot;year&quot;) # 년단위로 반올림 ## [1] &quot;2010-01-01&quot; floor_date(x, &quot;day&quot;) # 일단위로 내림 ## [1] &quot;2009-08-03&quot; floor_date(x, &quot;week&quot;) # 주단위로 내림 ## [1] &quot;2009-08-02&quot; floor_date(x, &quot;month&quot;) # 월단위로 내림 ## [1] &quot;2009-08-01&quot; floor_date(x, &quot;halfyear&quot;) # 반기 단위로 내림 ## [1] &quot;2009-07-01&quot; floor_date(x, &quot;year&quot;) # 년단위로 내림 ## [1] &quot;2009-01-01&quot; ceiling_date(x, &quot;day&quot;) # 일단위로 올림 ## [1] &quot;2009-08-04&quot; ceiling_date(x, &quot;week&quot;) # 주단위로 올림 ## [1] &quot;2009-08-09&quot; ceiling_date(x, &quot;month&quot;) # 월단위로 올림 ## [1] &quot;2009-09-01&quot; ceiling_date(x, &quot;halfyear&quot;) # 반기 단위로 올림 ## [1] &quot;2010-01-01&quot; ceiling_date(x, &quot;year&quot;) # 년단위로 올림 ## [1] &quot;2010-01-01&quot; days_in_month(as.Date(&#39;2012-2&#39;, format = &#39;%Y-%d&#39;)) # 말일을 구하는 코드 ## Feb ## 29 xts 패키지 xts 클래스 데이터 객체에서는 위의 예제를 적용할 수 없다. 다만 xts 패키지에서는 floor_date와 ceiling_date와 유사한 기능을 수행하는 함수, first(), last()를 제공한다. first()는 함수에서 지정된 단위의 첫번째 날짜를 리턴하고 last()는 지정된 단위의 마지막 날짜를 리턴한다. endpoints 함수는 기본값으로 매월 마지막 날짜를 반환하지만 매개변수를 설정함으로써 매주 마지막날, 매월 마지막날, 매년 마지막날 등을 반환할 수 있다 x &lt;- xts(1:100, Sys.Date()+1:100) first(x, 10) ## [,1] ## 2021-02-16 1 ## 2021-02-17 2 ## 2021-02-18 3 ## 2021-02-19 4 ## 2021-02-20 5 ## 2021-02-21 6 ## 2021-02-22 7 ## 2021-02-23 8 ## 2021-02-24 9 ## 2021-02-25 10 first(x, &#39;1 day&#39;) ## [,1] ## 2021-02-16 1 first(x, &#39;4 days&#39;) ## [,1] ## 2021-02-16 1 ## 2021-02-17 2 ## 2021-02-18 3 ## 2021-02-19 4 first(x, &#39;month&#39;) ## [,1] ## 2021-02-16 1 ## 2021-02-17 2 ## 2021-02-18 3 ## 2021-02-19 4 ## 2021-02-20 5 ## 2021-02-21 6 ## 2021-02-22 7 ## 2021-02-23 8 ## 2021-02-24 9 ## 2021-02-25 10 ## 2021-02-26 11 ## 2021-02-27 12 ## 2021-02-28 13 last(x, 10) ## [,1] ## 2021-05-17 91 ## 2021-05-18 92 ## 2021-05-19 93 ## 2021-05-20 94 ## 2021-05-21 95 ## 2021-05-22 96 ## 2021-05-23 97 ## 2021-05-24 98 ## 2021-05-25 99 ## 2021-05-26 100 last(x, &#39;2 weeks&#39;) ## [,1] ## 2021-05-17 91 ## 2021-05-18 92 ## 2021-05-19 93 ## 2021-05-20 94 ## 2021-05-21 95 ## 2021-05-22 96 ## 2021-05-23 97 ## 2021-05-24 98 ## 2021-05-25 99 ## 2021-05-26 100 4.1.4 시계열 데이터 Grouping 시계열 데이터를 사용할 때 많이 사용하는 계산은 월별 평균, 주별 합계 등 일정 단위별로 그룹핑한 후 그룹함수를 적용하여 산출하는 작업이다. 아쉽게도 앞서 사용한 lubridate 패키지에서는 시계열 데이터를 주단위, 월단위, 년단위 등으로 그룹핑하는 함수를 제공하지 않는다. 따라서 lubridate 함수를 이용하여 그룹화하기 위해서는 dplyr에서 제공하는 pipe 연산자와 함수를 같이 사용하여 산출할 수 있다. 하지만 앞장에서 소개한 timetk 패키지에서는 그룹핑하여 평균을 내거나 합계를 내는 함수를 제공하기 때문에 이를 사용할 수도 있다. lubridate, dplyr 패키지 먼저 그룹핑을 하기 위한 단위를 설정하기 위해 lubridate 패키지의 year, month, week 등의 함수를 사용하여 해당 일의 년, 월, 주등을 산출하고 mutate 함수를 사용하여 컬럼으로 만들어준다. 다음 group_by 함수를 사용하여 데이터를 그룹핑하고 summarise 함수를 통해 sum, mean 등의 그룹 함수를 사용하여 원하는 값을 산출한다. library(dplyr) library(ggplot2) ### 월별 취업자수를 연별 취업자수로 그룹핑 employees %&gt;% mutate(year = year(time)) %&gt;% group_by(year) %&gt;% summarise(total.year = sum(total), employees.edu = sum(employees.edu)) -&gt; employees.by.year employees.by.year %&gt;% ggplot(aes(year, total.year)) + geom_line() ### 일별 확진자수를 월별 확진자수로 그룹핑 wide.covid19.by.age %&gt;% mutate(month = month(date), year = year(date)) %&gt;% group_by(month, year) %&gt;% summarise(total.1대확진자 = sum(`0-9세`), total.10대확진자 = sum(`10-19세`), total.20대확진자 = sum(`20-29세`), total.30대확진자 = sum(`30-39세`), total.40대확진자 = sum(`40-49세`), total.50대확진자 = sum(`50-59세`), total.60대확진자 = sum(`60-69세`), total.70대확진자 = sum(`70-79세`), total.80대확진자 = sum(`80세 이상`)) ## # A tibble: 11 x 11 ## # Groups: month [11] ## month year total.1대확진자 total.10대확진자 total.20대확진자 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2021 893 1433 2241 ## 2 2 2021 188 NA 412 ## 3 4 2020 14 42 120 ## 4 5 2020 16 62 214 ## 5 6 2020 31 48 171 ## 6 7 2020 53 74 258 ## 7 8 2020 196 363 700 ## 8 9 2020 136 161 442 ## 9 10 2020 112 137 387 ## 10 11 2020 301 593 1298 ## 11 12 2020 1016 1589 3010 ## # ... with 6 more variables: total.30대확진자 &lt;dbl&gt;, total.40대확진자 &lt;dbl&gt;, ## # total.50대확진자 &lt;dbl&gt;, total.60대확진자 &lt;dbl&gt;, total.70대확진자 &lt;dbl&gt;, ## # total.80대확진자 &lt;dbl&gt; 또 하나의 방법은 tibbletime 패키지에서 제공하는 collapse_by() 함수를 사용하는 방법이다. collapse_by() 함수는 시간 인덱스열을 직접 컨트롤하여 매개변수로 전달된 기간마다 데이터를 접은(collapse) 후에 group_by() 함수를 이용해 그룹핑하여 기간별 데이터를 산출할 수 있다.4 다만 collapse_by()함수를 사용하려면 tibbletime 패키지를 설치, 로딩해야하며 tbl_time 클래스 객체로 변환된 데이터 객체에 한해서 사용할 수 있다. library(tibbletime) as_tbl_time(wide.covid19.by.age, index = date) %&gt;% collapse_by(&#39;weekly&#39;) %&gt;% group_by(date) %&gt;% summarise(`1대`= sum(`0-9세`), `10대` = sum(`10-19세`), `20대` = sum(`20-29세`), `30대` = sum(`30-39세`), `40대` = sum(`40-49세`), `50대` = sum(`50-59세`), `60대` = sum(`60-69세`), `70대` = sum(`70-79세`), `80대` = sum(`80세 이상`)) %&gt;% head(10) ## # A time tibble: 10 x 10 ## # Index: date ## date `1대` `10대` `20대` `30대` `40대` `50대` `60대` `70대` `80대` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2020-04-11 4 10 24 13 12 11 15 2 5 ## 2 2020-04-18 8 18 62 21 13 18 16 11 6 ## 3 2020-04-25 1 10 19 7 8 9 4 3 4 ## 4 2020-05-02 1 4 23 17 10 3 2 1 1 ## 5 2020-05-09 1 4 19 17 8 2 6 1 2 ## 6 2020-05-16 6 25 95 32 16 8 9 4 2 ## 7 2020-05-23 1 12 29 12 17 6 5 3 0 ## 8 2020-05-30 8 21 54 54 43 50 32 7 7 ## 9 2020-06-06 6 5 26 24 26 39 44 27 8 ## 10 2020-06-13 4 17 43 38 27 69 74 37 23 timetk 패키지 timetk 패키지에서는 그룹핑을 위해 summarise_by_time() 함수를 제공한다. 매개변수로 .date_var(시간컬럼), .by(그룹핑 단위) 등을 설정하고 산출하기 원하는 컬럼명과 그룹함수를 기재하여 원하는 값을 얻을 수 있다. library(timetk) wide.covid19.by.age %&gt;% summarise_by_time(.date_var = date, .by = &#39;week&#39;, `1대`= sum(`0-9세`), `10대` = sum(`10-19세`), `20대` = sum(`20-29세`), `30대` = sum(`30-39세`), `40대` = sum(`40-49세`), `50대` = sum(`50-59세`), `60대` = sum(`60-69세`), `70대` = sum(`70-79세`), `80대` = sum(`80세 이상`)) ## # A tibble: 45 x 10 ## date `1대` `10대` `20대` `30대` `40대` `50대` `60대` `70대` `80대` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2020-04-05 4 10 24 13 12 11 15 2 5 ## 2 2020-04-12 8 18 62 21 13 18 16 11 6 ## 3 2020-04-19 1 10 19 7 8 9 4 3 4 ## 4 2020-04-26 1 4 23 17 10 3 2 1 1 ## 5 2020-05-03 1 4 19 17 8 2 6 1 2 ## 6 2020-05-10 6 25 95 32 16 8 9 4 2 ## 7 2020-05-17 1 12 29 12 17 6 5 3 0 ## 8 2020-05-24 8 21 54 54 43 50 32 7 7 ## 9 2020-05-31 6 5 26 24 26 39 44 27 8 ## 10 2020-06-07 4 17 43 38 27 69 74 37 23 ## # ... with 35 more rows employees %&gt;% summarise_by_time(.date_var = time, .by = &#39;month&#39;, total.year = sum(total), employees.edu = sum(employees.edu)) ## # A tibble: 96 x 3 ## time total.year employees.edu ## &lt;date&gt; &lt;int&gt; &lt;int&gt; ## 1 2013-01-01 24287 1710 ## 2 2013-02-01 24215 1681 ## 3 2013-03-01 24736 1716 ## 4 2013-04-01 25322 1745 ## 5 2013-05-01 25610 1774 ## 6 2013-06-01 25686 1786 ## 7 2013-07-01 25681 1813 ## 8 2013-08-01 25513 1811 ## 9 2013-09-01 25701 1794 ## 10 2013-10-01 25798 1790 ## # ... with 86 more rows xts 패키지 data.frame 클래스의 시계열 객체는 위와 같이 dplyr 패키지의 기능을 이용해 그룹핑하고 그룹함수를 적용용하지만 xts 클래스에서는 시간 유닛별로 그룹핑하여 그룹함수를 적용할 수 있는 함수를 지원한다. 따라서 연 평균, 월 합계와 같은 작업에 편리하게 사용할 수 있다. apply.monthly(employees.xts, sum) ## [,1] ## 2013-01-01 25997 ## 2013-02-01 25896 ## 2013-03-01 26452 ## 2013-04-01 27067 ## 2013-05-01 27384 ## 2013-06-01 27472 ## 2013-07-01 27494 ## 2013-08-01 27324 ## 2013-09-01 27495 ## 2013-10-01 27588 ## 2013-11-01 27588 ## 2013-12-01 27027 ## 2014-01-01 26798 ## 2014-02-01 26902 ## 2014-03-01 27277 ## 2014-04-01 27822 ## 2014-05-01 27940 ## 2014-06-01 28017 ## 2014-07-01 28121 ## 2014-08-01 28033 ## 2014-09-01 28072 ## 2014-10-01 28099 ## 2014-11-01 28121 ## 2014-12-01 27521 ## 2015-01-01 27216 ## 2015-02-01 27279 ## 2015-03-01 27600 ## 2015-04-01 27968 ## 2015-05-01 28256 ## 2015-06-01 28264 ## 2015-07-01 28355 ## 2015-08-01 28201 ## 2015-09-01 28339 ## 2015-10-01 28407 ## 2015-11-01 28318 ## 2015-12-01 27958 ## 2016-01-01 27473 ## 2016-02-01 27429 ## 2016-03-01 27798 ## 2016-04-01 28180 ## 2016-05-01 28482 ## 2016-06-01 28588 ## 2016-07-01 28616 ## 2016-08-01 28559 ## 2016-09-01 28587 ## 2016-10-01 28627 ## 2016-11-01 28666 ## 2016-12-01 28255 ## 2017-01-01 27770 ## 2017-02-01 27855 ## 2017-03-01 28356 ## 2017-04-01 28684 ## 2017-05-01 28936 ## 2017-06-01 28971 ## 2017-07-01 29013 ## 2017-08-01 28800 ## 2017-09-01 28880 ## 2017-10-01 28911 ## 2017-11-01 28921 ## 2017-12-01 28487 ## 2018-01-01 28039 ## 2018-02-01 27905 ## 2018-03-01 28391 ## 2018-04-01 28702 ## 2018-05-01 28911 ## 2018-06-01 28970 ## 2018-07-01 28940 ## 2018-08-01 28767 ## 2018-09-01 28913 ## 2018-10-01 28960 ## 2018-11-01 29042 ## 2018-12-01 28491 ## 2019-01-01 28069 ## 2019-02-01 28183 ## 2019-03-01 28675 ## 2019-04-01 28927 ## 2019-05-01 29206 ## 2019-06-01 29326 ## 2019-07-01 29303 ## 2019-08-01 29241 ## 2019-09-01 29323 ## 2019-10-01 29384 ## 2019-11-01 29407 ## 2019-12-01 29030 ## 2020-01-01 28644 ## 2020-02-01 28666 ## 2020-03-01 28379 ## 2020-04-01 28321 ## 2020-05-01 28744 ## 2020-06-01 28884 ## 2020-07-01 28937 ## 2020-08-01 28878 ## 2020-09-01 28780 ## 2020-10-01 28860 ## 2020-11-01 29026 ## 2020-12-01 28303 apply.weekly(employees.xts, sum) %&gt;% head(10) ## [,1] ## 2013-01-01 25997 ## 2013-02-01 25896 ## 2013-03-01 26452 ## 2013-04-01 27067 ## 2013-05-01 27384 ## 2013-06-01 27472 ## 2013-07-01 27494 ## 2013-08-01 27324 ## 2013-09-01 27495 ## 2013-10-01 27588 apply.quarterly(employees.xts, sum) %&gt;% head(10) ## [,1] ## 2013-03-01 78345 ## 2013-06-01 81923 ## 2013-09-01 82313 ## 2013-12-01 82203 ## 2014-03-01 80977 ## 2014-06-01 83779 ## 2014-09-01 84226 ## 2014-12-01 83741 ## 2015-03-01 82095 ## 2015-06-01 84488 4.1.5 시계열 데이터 OHLC 시계열 데이터를 다룰때 앞서 설명한 grouping을 많이 사용한다. 대부분의 데이터에서는 그룹함수로 제공되는 sum(), mean(), median() 등의 함수를 사용하는 경우가 많지만 시계열 데이터, 특히 금융권 데이터에서는 OHLC 정보를 확인하는 경우도 많다 OHLC는 주어진 기간동안의 첫번째 값(Open), 최대값(High), 최소값(Low), 마지막값(Close) 값을 말한다. lubridate, tibbletime, dplyr 패키지 앞서 소개한 collapse_by() 함수를 사용하면 OHLC 정보를 간단히 산출할 수 있다. collapse_by()를 이용해 그룹핑할 시간 주기를 설정하고 group_by()함수를 사용하여 data.frame을 그룹핑한 후 lubridata 패키지의first(), max(), min(), last() 함수를 사용하면 산출이 가능하다. as_tbl_time(wide.covid19.by.age, index = date) %&gt;% collapse_by(&#39;weekly&#39;) %&gt;% group_by(date) %&gt;% summarise(Open = first(`0-9세`), High = max(`0-9세`), Low = min(`0-9세`), Close = last(`0-9세`)) %&gt;% head(10) ## # A time tibble: 10 x 5 ## # Index: date ## date Open High Low Close ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2020-04-11 2 2 1 1 ## 2 2020-04-18 0 3 0 2 ## 3 2020-04-25 0 1 0 1 ## 4 2020-05-02 2 2 -1 0 ## 5 2020-05-09 0 1 0 0 ## 6 2020-05-16 0 2 0 2 ## 7 2020-05-23 0 1 0 0 ## 8 2020-05-30 0 3 0 1 ## 9 2020-06-06 0 3 0 3 ## 10 2020-06-13 1 1 0 0 xts xts 패키지에서는 OHLC 정보를 확인할 수 있는 함수를 직접 제공한다. to.period()함수인데 OHLC를 제공하는데 to.period 함수의 매개변수인 period에 ‘months,’ ‘quarters’ 등 적절한 시간 간격을 설정해주면 해당 기간동안의 OHCL를 자동으로 출력해준다. to.period(wide.covid19.by.age.xts, method = &#39;months&#39;, OLHC = TRUE) ## Warning in to.period(wide.covid19.by.age.xts, method = &quot;months&quot;, OLHC = TRUE): ## missing values removed from data ## wide.covid19.by.age.xts.Open wide.covid19.by.age.xts.High ## 2020-04-30 2 5 ## 2020-05-31 0 11 ## 2020-06-30 0 6 ## 2020-07-31 0 10 ## 2020-08-31 1 35 ## 2020-09-30 14 17 ## 2020-10-31 6 11 ## 2020-11-30 5 57 ## 2020-12-31 15 86 ## 2021-01-31 41 138 ## 2021-02-08 20 41 ## wide.covid19.by.age.xts.Low wide.covid19.by.age.xts.Close ## 2020-04-30 1 2 ## 2020-05-31 0 7 ## 2020-06-30 0 6 ## 2020-07-31 -4 13 ## 2020-08-31 0 15 ## 2020-09-30 0 20 ## 2020-10-31 0 22 ## 2020-11-30 9 32 ## 2020-12-31 0 132 ## 2021-01-31 44 49 ## 2021-02-08 30 31 4.1.6 시계열 데이터 Rolling 주식투자를 하는 분들은 주식거래 프로그램에서 많은 시계열 그래프들을 보게된다. 이들 그래프 중에 어떤 그래프에는 MA(5), MA(10)과 같은 표기가 된 line plot을 볼 수 있는데 이를 이동평균이라고 한다. 최근 5일 평균, 최근 10일 평균과 같이 평균의 기준 범위가 날짜별로 달라지면서 평균을 구하게 되는데 이와 같이 기준일에서 특정 기간의 일, 월의 집합 함수를 적용하는 과정을 rolling이라 하고 rolling의 기간을 rolling window라고 한다. rolling도 앞선 group과 같이 lubridate 패키지에서 제공하는 함수를 dplyr 함수와 파이프라인을 사용하는 방법, timetk 패키지를 사용하는 방법, xts 패키지를 사용하는 방법을 설명하고자 한다. lubridate, dplyr 패키지 lubridate 패키지를 사용하여 data.frame 클래스 객체에 대한 rolling은 좀 복잡하다. 하지만 zoo 패키지에서 제공하는 roll* 함수를 사용하면 비교적 쉽게 rolling을 수행할 수있어 이 방법을 소개하고자 한다. 사실 이 방법에서는 lubridate 패키지 함수는 사용되지 않는데 mutate 함수를 이용하여 새로운 컬럼을 생성하는데 각 컬럼을 생성하는 함수로 zoo 패키지의 roll* 함수를 사용한다. roll* 함수는 rollapply()와 rollmean()의 두가지를 제공하는데 rollapply는 apply함수를 rolling용으로 수정한 버젼이고 rollapply 함수에 mean을 적용하는 경우가 많기 때문에 추가적으로 이동평균을 구하는 함수를 제공한다. library(zoo) employees %&gt;% mutate(ma3 = rollmean(total, k = 3, fill = NA), sum3 = rollapply(total, 3, sum, fill = NA)) %&gt;% select(total, ma3, sum3) %&gt;% head(10) ## total ma3 sum3 ## 1 24287 NA NA ## 2 24215 24412.67 73238 ## 3 24736 24757.67 74273 ## 4 25322 25222.67 75668 ## 5 25610 25539.33 76618 ## 6 25686 25659.00 76977 ## 7 25681 25626.67 76880 ## 8 25513 25631.67 76895 ## 9 25701 25670.67 77012 ## 10 25798 25764.67 77294 timetk 패키지 timetk 패키지에서는 rolling 기능을 위해 slidify() 함수를 제공한다. slidify() 함수가 타 함수와 다른점은 그 반환값이 함수의 실행 결과값이 아니고 함수자체를 반환한다는 것이다. 즉 rolling window 기간에 특정 함수를 적용하는 함수를 제공하기 때문에 이후 함수의 형태로 사용해야 한다. 아래의 예에 m3와 sum3는 data.frame이나 숫자값이 아니고 함수 객체이다. 이 함수 객체는 mutate 함수안에서 함수처럼 작용하는데 그 매개변수로 rolling을 해야할 컬럼을 전달하면 그 결과 벡터가 전달되는 형태로 실행된다. ma3 &lt;- slidify(mean, .period = 3, .align = &quot;right&quot;) sum3 &lt;- slidify(sum, .period = 3, .align = &quot;center&quot;) class(ma3) ## [1] &quot;function&quot; class(sum3) ## [1] &quot;function&quot; employees %&gt;% mutate(ma3 = ma3(total), sum3 = sum3(total)) %&gt;% select(total, ma3, sum3) %&gt;% head(10) ## total ma3 sum3 ## 1 24287 NA NA ## 2 24215 NA 73238 ## 3 24736 24412.67 74273 ## 4 25322 24757.67 75668 ## 5 25610 25222.67 76618 ## 6 25686 25539.33 76977 ## 7 25681 25659.00 76880 ## 8 25513 25626.67 76895 ## 9 25701 25631.67 77012 ## 10 25798 25670.67 77294 xts 패키지 xts 패키지에서는 rolling을 위한 간단한 함수를 제공한다. rollapply함수로 xts 객체와 rolling window 기간, 적용할 함수를 전달하면 rolling을 간단히 구할수 있다. rollapply(employees.xts, width = 3, FUN = sum) %&gt;% head(10) ## total employees.edu ## 2013-01-01 NA NA ## 2013-02-01 NA NA ## 2013-03-01 73238 5107 ## 2013-04-01 74273 5142 ## 2013-05-01 75668 5235 ## 2013-06-01 76618 5305 ## 2013-07-01 76977 5373 ## 2013-08-01 76880 5410 ## 2013-09-01 76895 5418 ## 2013-10-01 77012 5395 4.1.7 시계열 데이터 Filtering 시계열 데이터가 아닌 데이터들은 데이터 값에 대한 조건의 결과에 따라 filtering한다. 물론 시계열 데이터도 데이터 값의 조건에 따라 filtering이 가능하지만 시간 인덱스에 조건을 적용하여 filtering도 가능하다. lubridate, dplyr 패키지 data.frame에 저장된 시계열 객체의 시간 인덱스 컬럼은 조건 연산자가 산술 연산과 동일하게 적용된다. 따라서 &lt;, &gt;, &lt;=, &gt;= 등의 연산자를 사용하여 인덱스를 filtering하여 전체 데이터를 filtering 할 수 있다. wide.covid19.by.age %&gt;% filter(date &gt;= as.Date(&#39;2020-10-01&#39;) &amp; date &lt;= as.Date(&#39;2020-10-10&#39;)) ## date status 0-9세 10-19세 20-29세 30-39세 40-49세 50-59세 60-69세 ## 1 2020-10-01 신규 6 4 7 9 14 13 13 ## 2 2020-10-02 신규 3 6 6 10 6 11 13 ## 3 2020-10-03 신규 1 1 6 13 11 11 16 ## 4 2020-10-04 신규 0 4 4 9 13 8 12 ## 5 2020-10-05 신규 0 3 17 9 8 12 14 ## 6 2020-10-06 신규 5 8 26 8 2 11 9 ## 7 2020-10-07 신규 1 2 8 13 10 28 31 ## 8 2020-10-08 신규 6 5 6 7 9 12 11 ## 9 2020-10-10 신규 0 0 0 0 0 0 0 ## 70-79세 80세 이상 ## 1 7 4 ## 2 4 4 ## 3 13 3 ## 4 8 6 ## 5 6 4 ## 6 4 2 ## 7 16 5 ## 8 10 3 ## 9 0 0 wide.covid19.by.age %&gt;% filter(between(date, as.Date(&#39;2021-01-01&#39;), as.Date(&#39;2021-01-15&#39;))) ## date status 0-9세 10-19세 20-29세 30-39세 40-49세 50-59세 60-69세 ## 1 2021-01-01 신규 41 74 131 145 154 204 159 ## 2 2021-01-02 신규 39 66 111 109 106 160 125 ## 3 2021-01-03 신규 32 46 80 75 88 124 117 ## 4 2021-01-04 신규 40 71 120 127 172 187 153 ## 5 2021-01-05 신규 45 44 107 105 112 124 108 ## 6 2021-01-06 신규 45 60 106 106 110 140 148 ## 7 2021-01-07 신규 41 54 123 120 155 176 113 ## 8 2021-01-08 신규 34 43 91 86 83 124 125 ## 9 2021-01-09 신규 32 50 100 91 89 124 80 ## 10 2021-01-10 신규 36 56 87 79 94 143 87 ## 11 2021-01-11 신규 19 36 47 54 61 79 79 ## 12 2021-01-12 신규 32 34 71 59 91 102 74 ## 13 2021-01-13 신규 24 28 66 81 83 129 87 ## 14 2021-01-14 신규 25 45 60 67 82 98 71 ## 15 2021-01-15 신규 42 37 62 70 81 97 91 ## 70-79세 80세 이상 ## 1 80 41 ## 2 59 49 ## 3 51 38 ## 4 69 81 ## 5 44 26 ## 6 73 51 ## 7 59 27 ## 8 49 37 ## 9 50 25 ## 10 49 34 ## 11 44 31 ## 12 39 35 ## 13 47 16 ## 14 39 29 ## 15 22 11 employees %&gt;% filter(year(time) == 2019 &amp; month(time) == 5) ## time total employees.edu ## 1 2019-05-01 27322 1884 wide.covid19.by.age %&gt;% filter(between(day(date), 3, 7)) %&gt;% # 매월 3일부터 7일까지 filtering head(15) ## date status 0-9세 10-19세 20-29세 30-39세 40-49세 50-59세 60-69세 ## 1 2020-05-03 신규 0 1 2 3 2 0 2 ## 2 2020-05-04 신규 0 0 2 1 3 0 2 ## 3 2020-05-05 신규 0 0 0 1 1 1 0 ## 4 2020-05-06 신규 0 0 0 1 0 0 1 ## 5 2020-05-07 신규 0 1 2 1 0 0 0 ## 6 2020-06-03 신규 1 2 5 6 5 9 15 ## 7 2020-06-04 신규 1 0 5 3 3 9 9 ## 8 2020-06-05 신규 1 2 5 2 3 7 10 ## 9 2020-06-06 신규 3 1 2 6 11 8 9 ## 10 2020-06-07 신규 1 6 3 6 8 11 12 ## 11 2020-07-03 신규 2 10 10 10 6 7 11 ## 12 2020-07-04 신규 3 2 12 16 8 8 9 ## 13 2020-07-05 신규 3 3 8 9 11 7 14 ## 14 2020-07-06 신규 4 1 7 10 6 9 4 ## 15 2020-07-07 신규 1 2 12 6 7 7 7 ## 70-79세 80세 이상 ## 1 1 2 ## 2 0 0 ## 3 0 0 ## 4 0 0 ## 5 0 0 ## 6 6 0 ## 7 6 3 ## 8 7 2 ## 9 8 3 ## 10 8 2 ## 11 4 3 ## 12 2 3 ## 13 6 0 ## 14 2 3 ## 15 2 0 timetk 패키지 timetk 패키지에서는 filter_by_time() 함수를 제공한다. 이 함수는 dplyr 패키지의 파이프라인(%&gt;%)을 이용해서 시계열 데이터를 filtering 할 수 있다. 매개변수 .start로 시작일과 .end 종료일을 전달하면 해당 기간동안의 데이터를 반환한다. 또 timetk에서는 주어진 기간동안의 데이터에 한하여 조건에 적합한 데이터를 반환하는 filter_period() 함수를 제공한다. filter_period() 함수는 위에서 설명한 xts의 누적값을 구하는 방법과 유사하게 작동하는데 우선 데이터를 filter_period() 에서 설정한 기간으로 나누고 나뉘어진 데이터 내에서 주어진 조건에 적합한 결과들을 산출해서 반환한다. 예를 들어 매월 최대 매출일을 기록한 날, 매년 월평균 매출액보다 큰 매출을 기록한 월 등을 산출할 때 유용하다. wide.covid19.by.age %&gt;% filter_by_time(.date_var = date, .start = &#39;2020-10-01&#39;, .end = &#39;2020-10-05&#39;) ## date status 0-9세 10-19세 20-29세 30-39세 40-49세 50-59세 60-69세 ## 1 2020-10-01 신규 6 4 7 9 14 13 13 ## 2 2020-10-02 신규 3 6 6 10 6 11 13 ## 3 2020-10-03 신규 1 1 6 13 11 11 16 ## 4 2020-10-04 신규 0 4 4 9 13 8 12 ## 5 2020-10-05 신규 0 3 17 9 8 12 14 ## 70-79세 80세 이상 ## 1 7 4 ## 2 4 4 ## 3 13 3 ## 4 8 6 ## 5 6 4 wide.covid19.by.age %&gt;% filter(`0-9세` != 0) %&gt;% filter_period(.date_var = date, .period = &#39;1 month&#39;, `0-9세` == max(`0-9세`)) ## # A tibble: 17 x 11 ## date status `0-9세` `10-19세` `20-29세` `30-39세` `40-49세` `50-59세` ## &lt;date&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2020-04-16 신규 3 3 5 1 2 3 ## 2 2020-05-27 신규 3 2 8 6 3 6 ## 3 2020-06-06 신규 3 1 2 6 11 8 ## 4 2020-06-23 신규 3 0 4 9 9 9 ## 5 2020-06-29 신규 3 1 9 5 6 5 ## 6 2020-06-30 신규 3 4 10 6 8 6 ## 7 2020-07-17 신규 10 4 26 37 32 23 ## 8 2020-08-23 신규 16 35 34 40 62 82 ## 9 2020-08-28 신규 16 17 32 48 53 73 ## 10 2020-08-29 신규 16 18 31 36 47 54 ## 11 2020-09-01 신규 14 17 25 24 25 45 ## 12 2020-10-29 신규 11 8 13 23 14 17 ## 13 2020-11-23 신규 23 21 41 41 49 50 ## 14 2020-12-17 신규 56 54 107 122 141 214 ## 15 2021-01-05 신규 45 44 107 105 112 124 ## 16 2021-01-06 신규 45 60 106 106 110 140 ## 17 2021-02-05 신규 30 28 30 60 42 65 ## # ... with 3 more variables: `60-69세` &lt;dbl&gt;, `70-79세` &lt;dbl&gt;, `80세 ## # 이상` &lt;dbl&gt; xts 패키지 xts 객체의 시간 인덱스 filtering은 앞선 lubridate, dplyr, timetk와는 조금 달리 filtering이 가능하다. xts 객체는 함수로 filtering하지 않고 [ ]내에 조건을 전달할 수 있고 연산자인 ’/’로 기간 구간을 설정할 수 있다. wide.covid19.by.age.xts[&#39;2020-10-02&#39;] ### 2020-10-02에 해당하는 데이터 filtering ## 0-9세 10-19세 20-29세 30-39세 40-49세 50-59세 60-69세 70-79세 ## 2020-10-02 3 6 6 10 6 11 13 4 wide.covid19.by.age.xts[&#39;2020-10-01/2020-10-15&#39;] ### 2020-10-01에서부터 2020-10-15 까지 데이터 filtering ## 0-9세 10-19세 20-29세 30-39세 40-49세 50-59세 60-69세 70-79세 ## 2020-10-01 6 4 7 9 14 13 13 7 ## 2020-10-02 3 6 6 10 6 11 13 4 ## 2020-10-03 1 1 6 13 11 11 16 13 ## 2020-10-04 0 4 4 9 13 8 12 8 ## 2020-10-05 0 3 17 9 8 12 14 6 ## 2020-10-06 5 8 26 8 2 11 9 4 ## 2020-10-07 1 2 8 13 10 28 31 16 ## 2020-10-08 6 5 6 7 9 12 11 10 ## 2020-10-10 0 0 0 0 0 0 0 0 ## 2020-10-11 4 0 11 14 8 6 6 6 ## 2020-10-12 8 2 19 19 16 12 11 8 ## 2020-10-13 5 7 21 16 20 13 12 7 ## 2020-10-14 4 7 30 11 11 9 8 2 ## 2020-10-15 5 3 13 10 8 5 13 11 wide.covid19.by.age.xts[&#39;2021-02-05/&#39;] ### 2021-02-05일 부터 끝까지 데이터 filtering ## 0-9세 10-19세 20-29세 30-39세 40-49세 50-59세 60-69세 70-79세 ## 2021-02-05 30 28 30 60 42 65 75 25 ## 2021-02-06 25 31 53 41 60 77 63 30 ## 2021-02-07 21 27 51 47 44 79 66 26 ## 2021-02-08 19 9 35 31 53 52 59 22 ## 2021-02-09 15 NA 33 41 52 59 38 28 wide.covid19.by.age.xts[&#39;/2020-04-11&#39;] ### 처음부터 2020-04-11까지의 filtering ## 0-9세 10-19세 20-29세 30-39세 40-49세 50-59세 60-69세 70-79세 ## 2020-04-09 2 4 12 7 7 2 2 0 ## 2020-04-10 1 1 7 4 2 3 6 2 ## 2020-04-11 1 5 5 2 3 6 7 0 https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html https://rdrr.io/cran/lubridate/man/round_date.html https://cran.r-project.org/web/packages/tibbletime/vignettes/TT-04-use-with-dplyr.html "],["시계열-데이터-응용-사례.html", "4.2 시계열 데이터 응용 사례", " 4.2 시계열 데이터 응용 사례 본 절에서는 앞에서 설명한 시계열 데이터 핸들링 방법을 기초로 실제 리포팅 과정에서 주로 많이 사용되는 응용 사례에 대해 설명한다. 시계열 데이터가 저장되어 있는 객체의 형태별로 사용가능한 함수와 plotting 예제를 보인다. 4.2.1 월별, 분기별, 연별 합계 데이터프레임 : month(), quarter(), year() 함수 데이터 프레임 객체는 dplyr의 group_by()함수와 파이프라인(%&gt;%)을 사용하여 데이터를 그룹핑 한 후 summarise() 함수를 사용하여 합계를 구할 수 있다. employees %&gt;% mutate(year = year(time)) %&gt;% ### 시간에서 연도를 추출하여 컬럼 생성 group_by(year) %&gt;% ### 연도컬럼으로 group summarise(total.year = sum(total), employees.edu.year = sum(employees.edu)) ### 연도별 합계 산출 ## # A tibble: 8 x 3 ## year total.year employees.edu.year ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 303592 21192 ## 2 2014 310766 21957 ## 3 2015 314133 22028 ## 4 2016 316910 22350 ## 5 2017 320698 22886 ## 6 2018 321866 22165 ## 7 2019 325474 22600 ## 8 2020 322852 21570 employees %&gt;% mutate(year = year(time)) %&gt;% group_by(year) %&gt;% summarise(total.year = sum(total), employees.edu.year = sum(employees.edu)) %&gt;% ggplot(aes(as.factor(year), total.year)) + ### x축에 연도를 as.factor로 변환하지 않으면 연도가 모두 표기되지 않음(정수와 factor의 차이임) geom_line(aes(group = 1)) + geom_point() + geom_text(aes(label = scales::comma(total.year)), vjust = 1) + ### 데이터 포인트마다 취업자수를 표기하는데 scales::comma() 함수로 1000단위 콤마를 찍고 포인트와 겹치기 때문에 vsjut로 위치조정 labs(title = &#39;연도별 전체 취업자수 합계 추이&#39;, x = &#39;연도&#39;, y = &#39;취업자수&#39;) ### plot, x, y 축제목 설정 employees %&gt;% mutate(year = year(time), qrt = quarter(time)) %&gt;% group_by(year, qrt) %&gt;% summarise(total.year = sum(total), employees.edu.year = sum(employees.edu)) ## # A tibble: 32 x 4 ## # Groups: year [8] ## year qrt total.year employees.edu.year ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 73238 5107 ## 2 2013 2 76618 5305 ## 3 2013 3 76895 5418 ## 4 2013 4 76841 5362 ## 5 2014 1 75629 5348 ## 6 2014 2 78275 5504 ## 7 2014 3 78676 5550 ## 8 2014 4 78186 5555 ## 9 2015 1 76629 5466 ## 10 2015 2 79024 5464 ## # ... with 22 more rows employees %&gt;% mutate(year = year(time), qrt = quarter(time)) %&gt;% group_by(year, qrt) %&gt;% summarise(total.year = sum(total), employees.edu.year = sum(employees.edu)) %&gt;% ggplot(aes(x = as.factor(paste0(year, &#39;,&#39;, qrt)), y = employees.edu.year)) + geom_line(aes(group = 1)) + geom_point() + ggrepel::geom_text_repel(aes(label = scales::number(employees.edu.year, big.mark = &#39;,&#39;, accuracy = 1)), vjust = 1, size = 3) + ### ggrepel::geom_text_repel() 함수로 숫자들이 겹치지 않게 plotting labs(title = &#39;분기별 교육서비스업 취업자수 합계 추이&#39;, x = &#39;연도&#39;, y = &#39;취업자수&#39;) + theme(axis.text.x=element_text(angle=90,hjust=1)) wide.covid19.by.age %&gt;% mutate(year = year(date), month = month(date)) %&gt;% group_by(year, month) %&gt;% summarise(`0-9세.month` = sum(`0-9세`)) ## # A tibble: 11 x 3 ## # Groups: year [2] ## year month `0-9세.month` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2020 4 14 ## 2 2020 5 16 ## 3 2020 6 31 ## 4 2020 7 53 ## 5 2020 8 196 ## 6 2020 9 136 ## 7 2020 10 112 ## 8 2020 11 301 ## 9 2020 12 1016 ## 10 2021 1 893 ## 11 2021 2 188 데이터프레임, tsibble : collapse_by() 함수 데이터프레임이나 tsibble 객체는 collapse_by() 함수를 사용할 수 있다. 앞서 설명한 바와 같이 collpase_by 함수를 사용하기 위해서는 tbl_time 객체로 변환이 필요하다. as_tbl_time(employees, index = time) %&gt;% collapse_by(&#39;quarterly&#39;) %&gt;% group_by(time) %&gt;% summarise(total.quater = sum(total)) ## # A time tibble: 32 x 2 ## # Index: time ## time total.quater ## &lt;date&gt; &lt;int&gt; ## 1 2013-03-01 73238 ## 2 2013-06-01 76618 ## 3 2013-09-01 76895 ## 4 2013-12-01 76841 ## 5 2014-03-01 75629 ## 6 2014-06-01 78275 ## 7 2014-09-01 78676 ## 8 2014-12-01 78186 ## 9 2015-03-01 76629 ## 10 2015-06-01 79024 ## # ... with 22 more rows as_tbl_time(employees, index = time) %&gt;% collapse_by(&#39;quarterly&#39;) %&gt;% group_by(time) %&gt;% summarise(total.quater = sum(total)) %&gt;% ggplot(aes(time, total.quater)) + geom_line() + geom_point() + ggrepel::geom_text_repel(aes(label = scales::comma(total.quater)), vjust = 1, size = 3) + ### ggrepel::geom_text_repel() 함수로 숫자들이 겹치지 않게 plotting labs(title = &#39;분기별 전체 취업자수 합계 추이&#39;, x = &#39;연도&#39;, y = &#39;취업자수&#39;) as_tbl_time(wide.covid19.by.age.tsibble, index = date) %&gt;% collapse_by(&#39;monthly&#39;) %&gt;% group_by(date) %&gt;% summarise(total.1대 = sum(`0-9세`)) %&gt;% ggplot(aes(as.factor(date), total.1대)) + geom_line(aes(group = 1)) + geom_point() + geom_text(aes(label = scales::comma(total.1대, accuracy = 1)), vjust = 1, size = 3) + ### ggrepel::geom_text_repel() 함수로 숫자들이 겹치지 않게 plotting labs(title = &#39;월별 0-9세 코로나 확진자수 합계 추이&#39;, x = &#39;월&#39;, y = &#39;확진자수&#39;) + theme(axis.text.x=element_text(angle=90,hjust=1)) tsibble : index_by() 함수 tsibble 객체는 데이터프레임 객체와 동일하게 핸들링 할 수 있다. 하지만 tsibble 객체에서만 동작하는 함수인 index_by() 함수를 사용하면 쉽게 구할 수 있다. index_by 함수는 tsibble 객체 생성시 지정한 index 컬럼에서 grouping 하기 위한 새로운 컬럼을 생성하는데 이 컬럼에 grouping 주기를 함수로 명기한다. 여기서 주의해야할 사항은 grouping 함수 앞에 ~를 붙여야 한다는 것과 grouping 함수의 매개변수로 ‘.’을 사용해야 한다는 점이다.’’의 의미는 index 컬럼을 사용한다는 의미이다. grouping 주기는 다음과 같다. 함수명 주기 lubridate::year 연도 주기 yearquarter 분기 주기 yearmonth 월 주기 yearweek 주 주기 as.Date 일 주기 celling_date, floor_date, round_date 상세 주기 employees.tsibble%&gt;% index_by(yearqtr = ~ yearquarter(.)) %&gt;% summarise(sum.qtrly = sum(total)) %&gt;% head(10) ## # A tsibble: 10 x 2 [1Q] ## yearqtr sum.qtrly ## &lt;qtr&gt; &lt;int&gt; ## 1 2013 Q1 73238 ## 2 2013 Q2 76618 ## 3 2013 Q3 76895 ## 4 2013 Q4 76841 ## 5 2014 Q1 75629 ## 6 2014 Q2 78275 ## 7 2014 Q3 78676 ## 8 2014 Q4 78186 ## 9 2015 Q1 76629 ## 10 2015 Q2 79024 wide.covid19.by.age.tsibble[, c(1,3)]%&gt;% index_by(yearweek = ~ yearweek(.)) %&gt;% summarise(sum.weekly = sum(`0-9세`)) %&gt;% head(10) ## # A tsibble: 10 x 2 [1W] ## yearweek sum.weekly ## &lt;week&gt; &lt;dbl&gt; ## 1 2020 W15 4 ## 2 2020 W16 8 ## 3 2020 W17 3 ## 4 2020 W18 -1 ## 5 2020 W19 1 ## 6 2020 W20 6 ## 7 2020 W21 1 ## 8 2020 W22 8 ## 9 2020 W23 7 ## 10 2020 W24 3 index_by를 사용할 때 장점은 grouping 기간을 자유자재로 설정할 수 있다는 점이다. 월, 분기, 년과 같이 달력상의 주기 외에 ‘매 4일마다,’ ’매 2달마다’와 같이 주기를 설정할 수 있다. wide.covid19.by.age.tsibble[, c(1,3)]%&gt;% index_by(twoweek = ~ lubridate::floor_date(., &quot;2 month&quot;)) %&gt;% summarise(sum.2week = sum(`0-9세`)) %&gt;% head(10) ## # A tsibble: 6 x 2 [1D] ## twoweek sum.2week ## &lt;date&gt; &lt;dbl&gt; ## 1 2020-03-01 14 ## 2 2020-05-01 47 ## 3 2020-07-01 249 ## 4 2020-09-01 248 ## 5 2020-11-01 1317 ## 6 2021-01-01 1081 wide.covid19.by.age.tsibble[, c(1,3)]%&gt;% index_by(fourday = ~ lubridate::floor_date(., &quot;4 day&quot;)) %&gt;% summarise(sum.4days = sum(`0-9세`)) %&gt;% head(10) ## # A tsibble: 10 x 2 [1D] ## fourday sum.4days ## &lt;date&gt; &lt;dbl&gt; ## 1 2020-04-09 4 ## 2 2020-04-13 5 ## 3 2020-04-17 3 ## 4 2020-04-21 0 ## 5 2020-04-25 2 ## 6 2020-04-29 0 ## 7 2020-05-01 0 ## 8 2020-05-05 1 ## 9 2020-05-09 1 ## 10 2020-05-13 5 xts : apply 계열 함수 xts 객체의 월별, 분기별, 연별 값을 구하기 위해서 제공하는 함수는 ’apply.’으로 시작하는 함수로 함수에 xts 객체와 적용하고자 하는 함수(sum, mean 등)을 전달하면 값을 산출할 수 있다. apply. 계열 함수는 다음의 5가지가 있다. 산출된 결과는 plot.xts 함수로 간단히 plotting 할 수 있다. 함수명 설명 apply.daily(xts객체, 함수명) 일별로 함수를 적용한 결과값 반환 apply.weekly(xts객체, 함수명) 주별로 함수를 적용한 결과값 반환 apply.monthly(xts객체, 함수명) 월별로 함수를 적용한 결과값 반환 apply.quarterly(xts객체, 함수명) 분기별로 함수를 적용한 결과값 반환 apply.yearly(xts객체, 함수명) 년별로 함수를 적용한 결과값 반환 library(xts) apply.quarterly(employees.xts, sum) %&gt;% head(10) ## [,1] ## 2013-03-01 78345 ## 2013-06-01 81923 ## 2013-09-01 82313 ## 2013-12-01 82203 ## 2014-03-01 80977 ## 2014-06-01 83779 ## 2014-09-01 84226 ## 2014-12-01 83741 ## 2015-03-01 82095 ## 2015-06-01 84488 apply.yearly(employees.xts, sum) %&gt;% plot.xts() apply.monthly(wide.covid19.by.age.xts[,1], sum) %&gt;% plot.xts(main = &#39;월별 0-9세 코로나 확진자수&#39;) apply.quarterly(wide.covid19.by.age.xts[,1], sum) %&gt;% plot.xts(main = &#39;분기별 0-9세 코로나 확진자수&#39;) ts 객체 ts 객체는 다음장부터 다뤄질 시계열 분석 패키지인 forecast 패키지에서 중요하게 사용되는 객체이다. 하지만 앞선 data.frame 이나 xts 처럼 핸들링이 용이하지 않다. 따라서 데이터 핸들링을 위해서는 data.frame 이나 xts 객체로 변환하여 사용하는 것이 정신 건강에 좋다. 4.2.2 월별, 분기별, 연별 증감량 데이터프레임 : lag() 함수 월별, 분기별, 연별 증감량을 산출하기 위해서는 바로 직전 데이터와의 차감 데이터를 계산해야 한다. 시계열 분석에서는 바로 이전 데이터와의 차감데이터가 중요하게 활용되는데 자세한 내용은 다음장에서 다뤄진다. lag() 함수를 통해 데이터를 하나씩 Shift 시켜주고 mutate를 통해 증감과 증감률 컬럼을 넣어준다. cbind(students %&gt;% filter(지역규모 == &#39;계&#39;) %&gt;% select(연도, 학생수계), ### 1.연도와 학생수 컬럼을 선택 students %&gt;% filter(지역규모 == &#39;계&#39;) %&gt;% lag(1) %&gt;% select(학생수계) %&gt;% rename(전년 = 학생수계)) %&gt;% ### 2. lag(1) 함수를 사용하여 시차1 데이터 생성(하나씩 아래로 shift) 하고 컬럼명을 lag로 변경 mutate(증감 = 학생수계 - 전년, 증감율 = round((학생수계/전년)-1, 3) * 100) %&gt;% head(10) ### 3. 시차1 데이터와 원 데이터의 차이를 증감 컬럼으로, 원데이터를 시차1 데이터로 나눈 수치를 1에서 빼준 결과(비중을 증감으로 변환)에 100을 곱한다(백분률로 변환) ## 연도 학생수계 전년 증감 증감율 ## 1 1999 8658358 NA NA NA ## 2 2000 8535867 8658358 -122491 -1.4 ## 3 2001 8414423 8535867 -121444 -1.4 ## 4 2002 8361933 8414423 -52490 -0.6 ## 5 2003 8379775 8361933 17842 0.2 ## 6 2004 8371630 8379775 -8145 -0.1 ## 7 2005 8371421 8371630 -209 0.0 ## 8 2006 8354891 8371421 -16530 -0.2 ## 9 2007 8309932 8354891 -44959 -0.5 ## 10 2008 8187782 8309932 -122150 -1.5 cbind(students %&gt;% filter(지역규모 == &#39;계&#39;) %&gt;% select(연도, 학생수계), students %&gt;% filter(지역규모 == &#39;계&#39;) %&gt;% lag(1) %&gt;% select(학생수계) %&gt;% rename(전년 = 학생수계)) %&gt;% mutate(증감 = 학생수계 - 전년, 증감율 = round((학생수계/전년)-1, 3) * 100) %&gt;% ggplot(aes(as.factor(연도), 증감)) + geom_line(aes(group = 1)) + geom_point() + ggrepel::geom_text_repel(aes(label = scales::comma(증감)), vjust = 1, size = 3) + ### ggrepel::geom_text_repel() 함수로 숫자들이 겹치지 않게 plotting labs(title = &#39;전년대비 전체 학생수 증감 추이&#39;, x = &#39;연도&#39;, y = &#39;학생수 증감량&#39;) + theme(axis.text.x=element_text(angle=90,hjust=1)) cbind(employees %&gt;% select(time, total), employees %&gt;% select(total) %&gt;% lag(1) %&gt;% rename(전월 = total)) %&gt;% mutate(증감 = total - 전월, 증감율 = round((total/전월)-1, 3) * 100) %&gt;% ggplot(aes(time, 증감율)) + geom_line(aes(group = 1)) + geom_point() + labs(title = &#39;전월대비 전체 취업자수 증감율 추이&#39;, x = &#39;시간&#39;, y = &#39;취업자수 증감율&#39;) + scale_x_date(date_breaks = &#39;6 month&#39;) + theme(axis.text.x=element_text(angle=90,hjust=1)) tsibble : diffrence() 함수 앞선 데이터 프레임에서는 lag() 함수를 사용하여 원 데이터의 time shift를 한 데이터 컬럼을 생성하고 두 컬럼의 차이를 구하였다. tsibble 객체는 이 과정을 바로 지원하는 difference() 함수를 제공한다. 따라서 데이터프레임보다는 몇단계 과정을 줄일수 있다. students.tsibble%&gt;% filter(지역규모 == &#39;계&#39;) %&gt;% select(1, 3) -&gt; students.tsibble.계 students.tsibble.계 %&gt;% mutate(증감 = difference(students.tsibble.계$학생수계, lag = 1)) %&gt;% mutate(증감율 = round((증감/학생수계), 3) * 100) %&gt;% head(10) ## # A tsibble: 10 x 4 [1Y] ## 연도 학생수계 증감 증감율 ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1999 8658358 NA NA ## 2 2000 8535867 -122491 -1.4 ## 3 2001 8414423 -121444 -1.4 ## 4 2002 8361933 -52490 -0.6 ## 5 2003 8379775 17842 0.2 ## 6 2004 8371630 -8145 -0.1 ## 7 2005 8371421 -209 0 ## 8 2006 8354891 -16530 -0.2 ## 9 2007 8309932 -44959 -0.5 ## 10 2008 8187782 -122150 -1.5 employees%&gt;% mutate(증감 = difference(employees.tsibble$total, lag = 1)) %&gt;% mutate(증감율 = round((증감/total), 3) * 100) %&gt;% select(1, 2, 4, 5) %&gt;% head(10) ## time total 증감 증감율 ## 1 2013-01-01 24287 NA NA ## 2 2013-02-01 24215 -72 -0.3 ## 3 2013-03-01 24736 521 2.1 ## 4 2013-04-01 25322 586 2.3 ## 5 2013-05-01 25610 288 1.1 ## 6 2013-06-01 25686 76 0.3 ## 7 2013-07-01 25681 -5 0.0 ## 8 2013-08-01 25513 -168 -0.7 ## 9 2013-09-01 25701 188 0.7 ## 10 2013-10-01 25798 97 0.4 xts : diff() 함수 xts 객체도 tsibble 객체와 같이 차분 함수인 diff() 함수를 제공한다. 이후 과정은 tsibble과 동일한 과정을 거친다. students.total.xts$증감 &lt;- diff(students.total.xts[,2]) students.total.xts$증감율 &lt;- round((students.total.xts$증감/students.total.xts$학생수계), 3) * 100 students.total.xts[, c(&#39;학생수계&#39;, &#39;증감&#39;, &#39;증감율&#39;)] %&gt;% head(10) ## 학생수계 증감 증감율 ## 1999-01-01 8658358 NA NA ## 2000-01-01 8535867 -122491 -1.4 ## 2001-01-01 8414423 -121444 -1.4 ## 2002-01-01 8361933 -52490 -0.6 ## 2003-01-01 8379775 17842 0.2 ## 2004-01-01 8371630 -8145 -0.1 ## 2005-01-01 8371421 -209 0.0 ## 2006-01-01 8354891 -16530 -0.2 ## 2007-01-01 8309932 -44959 -0.5 ## 2008-01-01 8187782 -122150 -1.5 plot.xts(students.total.xts[, &#39;증감율&#39;], main = &#39;전년대비 학생수 증감률&#39;) employees.xts$증감 &lt;- diff(employees.xts$total) employees.xts$증감율 &lt;- round((employees.xts$증감/employees.xts$total), 3) * 100 employees.xts[, c(&#39;total&#39;, &#39;증감&#39;, &#39;증감율&#39;)] %&gt;% head(10) ## total 증감 증감율 ## 2013-01-01 24287 NA NA ## 2013-02-01 24215 -72 -0.3 ## 2013-03-01 24736 521 2.1 ## 2013-04-01 25322 586 2.3 ## 2013-05-01 25610 288 1.1 ## 2013-06-01 25686 76 0.3 ## 2013-07-01 25681 -5 0.0 ## 2013-08-01 25513 -168 -0.7 ## 2013-09-01 25701 188 0.7 ## 2013-10-01 25798 97 0.4 plot.xts(employees.xts[, c(&#39;증감율&#39;)], main = &#39;전월대비 전체 취업자 증감률&#39;) 4.2.3 월 비중 백분율, 연 비중 백분율 전체 연간 매출의 월별 비중, 전체 월간 합계 중 일별, 주간별 비중과 같은 수치를 산출해야할 때가 있다. 전체 연간 매출의 월별 비중을 모두 합하면 100%가 되어야 한다. 이를 위해서는 각각의 row에 비중을 구하기 위한 총 합계치가 계산되어야 한다. 예를 들어 매월 매출액이 기록된 시계열 데이터에서 년중 비중을 구하기 위해서는 매월 매출액의 옆 컬럼에 해당 년의 전체 매출액 합계가 있어야 비중을 구할 수 있다. data.frame : group_by(), mutate() 함수 데이터 프레임에서 총합계를 구하기 위해서는 먼저 구하고자 하는 총 합계의 주기로 grouping 하여 전체 합계를 구해야하는데 이때 주의해야할 점이 summarise() 함수를 통해 합계를 구하지 않고 mutate() 함수를 통해 합계를 구해야 한다. summarise 함수를 통해 합계를 구하면 전체 데이터 구조가 grouping 된 구조로 바뀌게 되지만 mutate() 함수를 통해 합계를 구하면 grouping 된 주기별로 합계값을 구한 컬럼이 추가되게 되어 비중을 구하기 쉽다. employees %&gt;% group_by(year(time)) %&gt;% mutate(sum.by.year = sum(total)) %&gt;% ungroup() %&gt;% mutate(rate.by.year = round(total/sum.by.year, 3) * 100) %&gt;% head(15) ## # A tibble: 15 x 6 ## time total employees.edu `year(time)` sum.by.year rate.by.year ## &lt;date&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013-01-01 24287 1710 2013 303592 8 ## 2 2013-02-01 24215 1681 2013 303592 8 ## 3 2013-03-01 24736 1716 2013 303592 8.1 ## 4 2013-04-01 25322 1745 2013 303592 8.3 ## 5 2013-05-01 25610 1774 2013 303592 8.4 ## 6 2013-06-01 25686 1786 2013 303592 8.5 ## 7 2013-07-01 25681 1813 2013 303592 8.5 ## 8 2013-08-01 25513 1811 2013 303592 8.4 ## 9 2013-09-01 25701 1794 2013 303592 8.5 ## 10 2013-10-01 25798 1790 2013 303592 8.5 ## 11 2013-11-01 25795 1793 2013 303592 8.5 ## 12 2013-12-01 25248 1779 2013 303592 8.3 ## 13 2014-01-01 25050 1748 2014 310766 8.1 ## 14 2014-02-01 25116 1786 2014 310766 8.1 ## 15 2014-03-01 25463 1814 2014 310766 8.2 wide.covid19.by.age %&gt;% group_by(year(date), month(date)) %&gt;% mutate(sum.by.month = sum(`0-9세`)) %&gt;% ungroup() %&gt;% mutate(rate.by.month = round(`0-9세`/sum.by.month, 3) * 100) %&gt;% select(date, `0-9세`, sum.by.month, rate.by.month) ## # A tibble: 302 x 4 ## date `0-9세` sum.by.month rate.by.month ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2020-04-09 2 14 14.3 ## 2 2020-04-10 1 14 7.1 ## 3 2020-04-11 1 14 7.1 ## 4 2020-04-12 0 14 0 ## 5 2020-04-13 2 14 14.3 ## 6 2020-04-14 0 14 0 ## 7 2020-04-15 0 14 0 ## 8 2020-04-16 3 14 21.4 ## 9 2020-04-17 1 14 7.1 ## 10 2020-04-18 2 14 14.3 ## # ... with 292 more rows wide.covid19.by.age %&gt;% group_by(year(date), month(date), week(date)) %&gt;% mutate(sum.by.week = sum(`0-9세`)) %&gt;% ungroup() %&gt;% mutate(rate.by.week = round(`0-9세`/sum.by.week, 3) * 100) %&gt;% select(date, `0-9세`, sum.by.week, rate.by.week) ## # A tibble: 302 x 4 ## date `0-9세` sum.by.week rate.by.week ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2020-04-09 2 6 33.3 ## 2 2020-04-10 1 6 16.7 ## 3 2020-04-11 1 6 16.7 ## 4 2020-04-12 0 6 0 ## 5 2020-04-13 2 6 33.3 ## 6 2020-04-14 0 6 0 ## 7 2020-04-15 0 6 0 ## 8 2020-04-16 3 6 50 ## 9 2020-04-17 1 6 16.7 ## 10 2020-04-18 2 6 33.3 ## # ... with 292 more rows tsibble : index_by(), mutate() 함수 앞선 월별 분기별 합산에서 사용했던 inde_by() 함수를 이용하면 데이터를 주기별로 grouping 할 수 있다. 이때 데이터프레임과 같이 summarise() 함수가 아닌 mutate() 함수를 사용하여 전체 row에 grouping된 합계 컬럼을 생성한 후 비율을 구할 수 있다. ### 취업자수의 분기별 비율 employees.tsibble%&gt;% index_by(yearqtr = ~ yearquarter(.)) %&gt;% mutate(sum.qtrly = sum(total)) %&gt;% mutate(rate.qtrly = total/sum.qtrly) %&gt;% head(15) ## # A tsibble: 15 x 6 [1D] ## # Groups: @ yearqtr [5] ## time total employees.edu yearqtr sum.qtrly rate.qtrly ## &lt;date&gt; &lt;int&gt; &lt;int&gt; &lt;qtr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013-01-01 24287 1710 2013 Q1 73238 0.332 ## 2 2013-02-01 24215 1681 2013 Q1 73238 0.331 ## 3 2013-03-01 24736 1716 2013 Q1 73238 0.338 ## 4 2013-04-01 25322 1745 2013 Q2 76618 0.330 ## 5 2013-05-01 25610 1774 2013 Q2 76618 0.334 ## 6 2013-06-01 25686 1786 2013 Q2 76618 0.335 ## 7 2013-07-01 25681 1813 2013 Q3 76895 0.334 ## 8 2013-08-01 25513 1811 2013 Q3 76895 0.332 ## 9 2013-09-01 25701 1794 2013 Q3 76895 0.334 ## 10 2013-10-01 25798 1790 2013 Q4 76841 0.336 ## 11 2013-11-01 25795 1793 2013 Q4 76841 0.336 ## 12 2013-12-01 25248 1779 2013 Q4 76841 0.329 ## 13 2014-01-01 25050 1748 2014 Q1 75629 0.331 ## 14 2014-02-01 25116 1786 2014 Q1 75629 0.332 ## 15 2014-03-01 25463 1814 2014 Q1 75629 0.337 ### 취업자수의 월별 비율 employees.tsibble%&gt;% index_by(yearqtr = ~ year(.)) %&gt;% mutate(sum.qtrly = sum(total)) %&gt;% mutate(rate.qtrly = (total/sum.qtrly)*100) %&gt;% head(15) ## # A tsibble: 15 x 6 [1D] ## # Groups: @ yearqtr [2] ## time total employees.edu yearqtr sum.qtrly rate.qtrly ## &lt;date&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013-01-01 24287 1710 2013 303592 8.00 ## 2 2013-02-01 24215 1681 2013 303592 7.98 ## 3 2013-03-01 24736 1716 2013 303592 8.15 ## 4 2013-04-01 25322 1745 2013 303592 8.34 ## 5 2013-05-01 25610 1774 2013 303592 8.44 ## 6 2013-06-01 25686 1786 2013 303592 8.46 ## 7 2013-07-01 25681 1813 2013 303592 8.46 ## 8 2013-08-01 25513 1811 2013 303592 8.40 ## 9 2013-09-01 25701 1794 2013 303592 8.47 ## 10 2013-10-01 25798 1790 2013 303592 8.50 ## 11 2013-11-01 25795 1793 2013 303592 8.50 ## 12 2013-12-01 25248 1779 2013 303592 8.32 ## 13 2014-01-01 25050 1748 2014 310766 8.06 ## 14 2014-02-01 25116 1786 2014 310766 8.08 ## 15 2014-03-01 25463 1814 2014 310766 8.19 4.2.4 월별, 분기별, 연별 누적합계 시계열 데이터는 시간동안의 데이터 흐름을 나타내지만 경우에 따라서 계속된 합계값을 나타내야 할 경우가 있다. 예를 들어 주간별 매출액의 연도별 누적 매출액, 웹사이트의 누적 사용자와 같은 경우이다. 누적값은 앞서 설명한 grouping과 함께 쓰면 더 좋은 결과를 낼 수 있다. data.frame : cumsum(), group_by(), collapse_by() 함수 data.frame 객체로 저장된 시계열 데이터에 대한 누적값을 구하기 위해서는 dplyr 패키지의 누적값을 산출 함수인 cumsum() 함수를 사용한다. 데이터를 grouping 하지 않고 전체 데이터에 대한 누적값은 mutate() 함수를 사용하여 cumsum() 함수 결과 컬럼을 생성함으로써 구할 수 있다. students %&gt;% filter(지역규모 == &#39;계&#39;) %&gt;% mutate(cumsum = cumsum(학생수계)) %&gt;% select(연도, 학생수계, cumsum) ## 연도 학생수계 cumsum ## 1 1999 8658358 8658358 ## 2 2000 8535867 17194225 ## 3 2001 8414423 25608648 ## 4 2002 8361933 33970581 ## 5 2003 8379775 42350356 ## 6 2004 8371630 50721986 ## 7 2005 8371421 59093407 ## 8 2006 8354891 67448298 ## 9 2007 8309932 75758230 ## 10 2008 8187782 83946012 ## 11 2009 8016924 91962936 ## 12 2010 7807663 99770599 ## 13 2011 7586266 107356865 ## 14 2012 7370308 114727173 ## 15 2013 7173904 121901077 ## 16 2014 6973154 128874231 ## 17 2015 6806411 135680642 ## 18 2016 6621547 142302189 ## 19 2017 6454281 148756470 ## 20 2018 6295366 155051836 ## 21 2019 6122198 161174034 ## 22 2020 5995239 167169273 employees %&gt;% mutate(cumsum = cumsum(total)) %&gt;% select(time, total, cumsum) %&gt;% head(15) ## time total cumsum ## 1 2013-01-01 24287 24287 ## 2 2013-02-01 24215 48502 ## 3 2013-03-01 24736 73238 ## 4 2013-04-01 25322 98560 ## 5 2013-05-01 25610 124170 ## 6 2013-06-01 25686 149856 ## 7 2013-07-01 25681 175537 ## 8 2013-08-01 25513 201050 ## 9 2013-09-01 25701 226751 ## 10 2013-10-01 25798 252549 ## 11 2013-11-01 25795 278344 ## 12 2013-12-01 25248 303592 ## 13 2014-01-01 25050 328642 ## 14 2014-02-01 25116 353758 ## 15 2014-03-01 25463 379221 wide.covid19.by.age %&gt;% mutate(cumsum = cumsum(`0-9세`)) %&gt;% select(date, `0-9세`, cumsum) %&gt;% ggplot(aes(date, cumsum)) + geom_line(aes(group = 1)) + scale_x_date(date_breaks = &quot;1 month&quot;, date_labels = &quot;%y.%m&quot;) + theme(axis.text.x=element_text(angle=90,hjust=1)) 전체 데이터에 대한 누적 합계가 아닌 연별, 월별, 주별 등의 주기별 누적합계를 구하려면 앞서 설명한 group_by(), collapse_by()와 함께 사용하면 원하는 기간동안의 누적 합계를 구할 수 있다. employees %&gt;% group_by(year(time)) %&gt;% mutate(cumsum.total = cumsum(total), cumsum.edu = cumsum(employees.edu)) ## # A tibble: 96 x 6 ## # Groups: year(time) [8] ## time total employees.edu `year(time)` cumsum.total cumsum.edu ## &lt;date&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013-01-01 24287 1710 2013 24287 1710 ## 2 2013-02-01 24215 1681 2013 48502 3391 ## 3 2013-03-01 24736 1716 2013 73238 5107 ## 4 2013-04-01 25322 1745 2013 98560 6852 ## 5 2013-05-01 25610 1774 2013 124170 8626 ## 6 2013-06-01 25686 1786 2013 149856 10412 ## 7 2013-07-01 25681 1813 2013 175537 12225 ## 8 2013-08-01 25513 1811 2013 201050 14036 ## 9 2013-09-01 25701 1794 2013 226751 15830 ## 10 2013-10-01 25798 1790 2013 252549 17620 ## # ... with 86 more rows as_tbl_time(wide.covid19.by.age, index = date) %&gt;% collapse_by(&#39;monthly&#39;) %&gt;% group_by(date) %&gt;% summarise(누적.1대 = cumsum(`0-9세`), 누적.10대 = cumsum(`10-19세`), 누적.20대 = cumsum(`20-29세`), 누적.30대 = cumsum(`30-39세`), 누적.40대 = cumsum(`40-49세`), 누적.50대 = cumsum(`50-59세`), 누적.60대 = cumsum(`60-69세`), 누적.70대 = cumsum(`70-79세`), 누적.80대 = cumsum(`80세 이상`)) ## # A time tibble: 302 x 10 ## # Index: date ## # Groups: date [11] ## date 누적.1대 누적.10대 누적.20대 누적.30대 누적.40대 누적.50대 ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2020-04-30 2 4 12 7 7 2 ## 2 2020-04-30 3 5 19 11 9 5 ## 3 2020-04-30 4 10 24 13 12 11 ## 4 2020-04-30 4 13 37 18 13 15 ## 5 2020-04-30 6 14 47 20 14 17 ## 6 2020-04-30 6 17 54 24 18 20 ## 7 2020-04-30 6 21 63 29 21 22 ## 8 2020-04-30 9 24 68 30 23 25 ## 9 2020-04-30 10 28 77 33 24 27 ## 10 2020-04-30 12 28 86 34 25 29 ## # ... with 292 more rows, and 3 more variables: 누적.60대 &lt;dbl&gt;, ## # 누적.70대 &lt;dbl&gt;, 누적.80대 &lt;dbl&gt; tsibble : index_by() 함수 tsibble 객체에 대한 누적합계는 grouping 하여 합계를 산출하는 방법의 sum 함수를 cumsum 함수로 바꾸어주고 summarise()를 mutate() 로 바꾸어 준다. mutate()를 쓰는 이유는 누적합계는 모든 관측값에 필요한 컬럼이기 때문이다. employees.tsibble%&gt;% index_by(yearqtr = ~ yearquarter(.)) %&gt;% mutate(cumsum.qtrly = cumsum(total)) %&gt;% select(yearqtr, cumsum.qtrly) %&gt;% head(10) ## # A tsibble: 10 x 3 [1D] ## # Groups: @ yearqtr [4] ## yearqtr cumsum.qtrly time ## &lt;qtr&gt; &lt;int&gt; &lt;date&gt; ## 1 2013 Q1 24287 2013-01-01 ## 2 2013 Q1 48502 2013-02-01 ## 3 2013 Q1 73238 2013-03-01 ## 4 2013 Q2 25322 2013-04-01 ## 5 2013 Q2 50932 2013-05-01 ## 6 2013 Q2 76618 2013-06-01 ## 7 2013 Q3 25681 2013-07-01 ## 8 2013 Q3 51194 2013-08-01 ## 9 2013 Q3 76895 2013-09-01 ## 10 2013 Q4 25798 2013-10-01 wide.covid19.by.age.tsibble[, c(1,3)]%&gt;% index_by(yearweek = ~ yearweek(.)) %&gt;% mutate(cumsum.weekly = cumsum(`0-9세`)) %&gt;% head(10) ## # A tsibble: 10 x 4 [1D] ## # Groups: @ yearweek [2] ## date `0-9세` yearweek cumsum.weekly ## &lt;date&gt; &lt;dbl&gt; &lt;week&gt; &lt;dbl&gt; ## 1 2020-04-09 2 2020 W15 2 ## 2 2020-04-10 1 2020 W15 3 ## 3 2020-04-11 1 2020 W15 4 ## 4 2020-04-12 0 2020 W15 4 ## 5 2020-04-13 2 2020 W16 2 ## 6 2020-04-14 0 2020 W16 2 ## 7 2020-04-15 0 2020 W16 2 ## 8 2020-04-16 3 2020 W16 5 ## 9 2020-04-17 1 2020 W16 6 ## 10 2020-04-18 2 2020 W16 8 xts xts 패키지에서는 누적값을 산출하는 함수를 제공하지 않는다. 그렇기 때문에 누적값을 구하기 위해서는 몇가지 단계를 거쳐야 한다. 먼저 split() 함수를 사용하여 누적값을 적용할 시간단위로 데이터를 분리해준다. 분리한 결과는 list의 형태로 반환되는데 이 결과를 lapply()함수를 이용하여 cumsum() 함수를 각각의 list에 적용시켜 준다. 이 결과는 list의 형태이기 때문에 do.call() 함수를 이용하여 하나의 xts 형태로 다시 묶어 주면 원하는 값을 얻을 수 있다. 이 과정에서 list를 다루는 함수인 lapply()와 do.call() 함수가 사용되었다. 이 두 함수 모두 매개변수로 받은 함수를 각각의 list 요소에 적용하는데 차이점은 lapply의 경우 각각의 list의 모든 행에 대해 매개변수 함수를 적용하는데 반해 do.call은 list의 요소에 대해 함수를 적용한다는 점에서 차이가 있다. 아래의 예에서 lapply()로 전달된 cumsum() 함수는 split()로 분리된 12개의 요소의 각 행(총 1,424개)에 적용되고 do.call로 전달된 rbind() 함수는 split로 분리된 12개의 요소에 적용되기 때문에 단순히 12번 호출된다. do.call(rbind, lapply(split(employees.xts, f = &#39;year&#39;), cumsum)) %&gt;% head(15) ## total employees.edu 증감 증감율 ## 2013-01-01 24287 1710 NA NA ## 2013-02-01 48502 3391 NA NA ## 2013-03-01 73238 5107 NA NA ## 2013-04-01 98560 6852 NA NA ## 2013-05-01 124170 8626 NA NA ## 2013-06-01 149856 10412 NA NA ## 2013-07-01 175537 12225 NA NA ## 2013-08-01 201050 14036 NA NA ## 2013-09-01 226751 15830 NA NA ## 2013-10-01 252549 17620 NA NA ## 2013-11-01 278344 19413 NA NA ## 2013-12-01 303592 21192 NA NA ## 2014-01-01 25050 1748 -198 -0.8 ## 2014-02-01 50166 3534 -132 -0.5 ## 2014-03-01 75629 5348 215 0.9 4.2.5 동월별, 동분기별, 동년별 Plot 앞선 plot에서처럼 시계열 데이터는 대부분 선 plot으로 그려지는 경우가 많다. 하지만 동년, 동월, 동분기의 데이터를 전체적으로 확인해야 할 떄가 있다. 이 경우는 우선 데이터를 적절히 grouping 해야한다. 앞의 예제에서는 월로 grouping 하기를 원하면 더 큰 시간인 년과 같이 grouping을 함으로써 시간적 흐름을 놓치지 않도록 유지하였다. 하지만 매 1월 판매량 등과 같이 시간적 흐름보다는 시간적 특성만을 원할 경우는 grouping할 때 원하는 해당 정보에 대해서만 grouping 함으로써 원하는 정보를 얻을 수 있다. 이 절에서는 주로 box plot을 활용하여 정보를 표현하도록 하겠다. date.frame : group_by() 함수 students.total ## 연도 지역규모 학생수계 유치원 초등학교 중학교 고등학교계 일반계고 전문계고 ## 1 1999 계 8658358 534166 3935537 1896956 2251140 1399389 851751 ## 2 2000 계 8535867 545263 4019991 1860539 2071468 1324482 746986 ## 3 2001 계 8414423 545142 4089429 1831152 1911173 1259975 651198 ## 4 2002 계 8361933 550256 4138366 1841030 1795509 1220146 575363 ## 5 2003 계 8379775 546531 4175626 1854641 1766529 1224452 542077 ## 6 2004 계 8371630 541713 4116195 1933543 1746560 1232010 514550 ## 7 2005 계 8371421 541603 4022801 2010704 1762896 1259792 503104 ## 8 2006 계 8354891 545812 3925043 2075311 1775857 1281508 494349 ## 9 2007 계 8309932 541550 3829998 2063159 1841374 1347363 494011 ## 10 2008 계 8187782 537822 3672207 2038611 1906978 1419486 487492 ## 11 2009 계 8016924 537361 3474395 2006972 1965792 1484966 480826 ## 12 2010 계 7807663 538587 3299094 1974798 1962356 1496227 466129 ## 13 2011 계 7586266 564834 3132477 1910572 1943798 NA NA ## 14 2012 계 7370308 613749 2951995 1849094 1920087 NA NA ## 15 2013 계 7173904 658188 2784000 1804189 1893303 NA NA ## 16 2014 계 6973154 652546 2728509 1717911 1839372 NA NA ## 17 2015 계 6806411 682553 2714610 1585951 1788266 NA NA ## 18 2016 계 6621547 704138 2672843 1457490 1752457 NA NA ## 19 2017 계 6454281 694631 2674227 1381334 1669699 NA NA ## 20 2018 계 6295366 675998 2711385 1334288 1538576 NA NA ## 21 2019 계 6122198 633913 2747219 1294559 1411027 NA NA ## 22 2020 계 5995239 612538 2693716 1315846 1337312 0 0 ## 일반고 특목고 특성화고 자율고 특수학교 공민학교 고등공민 고등기술학교 ## 1 NA NA NA NA 23490 150 511 8399 ## 2 NA NA NA NA 23605 150 297 6601 ## 3 NA NA NA NA 23769 140 302 5408 ## 4 NA NA NA NA 23453 145 156 4911 ## 5 NA NA NA NA 24119 105 150 4324 ## 6 NA NA NA NA 23876 106 147 3457 ## 7 NA NA NA NA 23566 94 174 3374 ## 8 NA NA NA NA 23394 70 172 3076 ## 9 NA NA NA NA 23147 65 191 3378 ## 10 NA NA NA NA 23419 60 188 1463 ## 11 NA NA NA NA 23720 50 193 1236 ## 12 NA NA NA NA 23858 19 200 1194 ## 13 1425882 63727 340227 113962 24617 7 186 1140 ## 14 1381130 64468 330797 143692 24785 0 170 1137 ## 15 1356070 67099 320374 149760 25161 0 175 1031 ## 16 1314073 66928 313449 144922 25317 0 117 1026 ## 17 1278008 67529 302021 140708 25536 0 85 940 ## 18 1256108 67607 290632 138110 25502 0 61 897 ## 19 1193562 67960 274281 133896 25670 0 53 795 ## 20 1096331 66693 252260 123292 25860 0 64 652 ## 21 1001756 65244 230098 113929 26044 0 71 556 ## 22 958108 64493 212294 102417 26269 0 48 552 ## 각종학교 ## 1 8009 ## 2 7953 ## 3 7908 ## 4 8107 ## 5 7750 ## 6 6033 ## 7 6209 ## 8 6156 ## 9 7070 ## 10 7034 ## 11 7205 ## 12 7557 ## 13 8635 ## 14 9291 ## 15 7857 ## 16 8356 ## 17 8470 ## 18 8159 ## 19 7872 ## 20 8543 ## 21 8809 ## 22 8958 "]]
