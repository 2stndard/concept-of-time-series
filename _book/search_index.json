[["시계열-forecasting-part-ii-시계열-예측-모델.html", "Chapter 6 시계열 forecasting Part II - 시계열 예측 모델", " Chapter 6 시계열 forecasting Part II - 시계열 예측 모델 A future like the past: 시계열 예측의 가장 기본적인 가정은 과거의 패턴은 미래에도 계속된다는 가정이다. 이 가정은 단기 미래에서는 데이터가 발생되는 환경이 현재와 유사하기 때문에 불확실성이 작지만 장기 미래로 갈수록 데이터가 발생되는 환경이 달라질 가능성이 높아지면서 예측 데이터에 대한 불확실성이 높아질 수 밖에 없다. 이러한 이유때문에 시계열 예측은 외부 충격이나 원인모를 이유에 의한 갑작스런 데이터 흐름 변화를 예측해낼 수 없다는 한계를 지닌다. 그런 지점을 전환점(Turning Point)라고 한다. 이 전환점은 시계열 분석에 있어 중요한 부분이지만 전환점을 예측하기 위해서는 전통적인 시계열 분석 기법보다는 다른 기법을 활용해야 할 수 있다.2 본 장에서는 시계열 예측을 위한 모델을 설명하기 위해 forecast 패키지에서 제공하는 함수들을 이용한다. 여러가지 시계열 모델을 구축하고 성능평가를 통해 가장 효율적인 모델을 선정해야한다. 과거에는 많은 패키지에서 제공하는 다양한 함수를 사용하여 여러가지 모델을 각각 생성하고 성능평가를 위한 데이터를 생성하여 최선의 성능을 내는 모델을 채택하였다. 그러나 최근에는 여러가지 모델을 하나의 프레임워크에서 수행하여 가장 좋은 모델을 선정하는 방법이 사용된다. 따라서 이 장에서는 모델을 이해하고 다음 장에서 시계열 평가, 시각화를 위한 프레임워크를 소개하고자 한다. https://hbr.org/1971/07/how-to-choose-the-right-forecasting-technique "],["simple-모델.html", "6.1 Simple 모델", " 6.1 Simple 모델 simple 모델링 알고리즘은 Rob Hyndman의 ’Forecasting : principals and practice’에서 그룹핑한 알고리즘과 명칭을 사용했다.3 따라서 Simple 모델링이라는 명칭과 알고리즘들은 일반적인 분류는 아닐수 있다. 사실 Simple 알고리즘을 보면 ’이게 무슨 예측이야?’라고 생각할 수도 있다. 하지만 우리가 매우 쉽게 접하고 사용하는 ’평균’이라는 것도 통계적 모델링에 하나라고 보면 Simple 알고리즘도 충분히 시계열 데이터의 모델링으로 볼 수도 있다. Simple 모델링의 대부분은 매우 간단한 개념을 함수화 하여 미래 예측에 활용할 수 있도록 제작되었다. Simple 모델링에서 제시하는 대부분의 함수는 forecast 패키지(앞에서 설명한 Rob Hyndman이 주도하여 제작된 패키지임)에서 제공하는 함수를 위주로 설명하고자 한다.4 6.1.1 평균 모델(forecast::meanf) 평균 모델은 우리가 흔히 알고 있는 평균이 앞으로의 미래에도 적용하는 방법이다. forecast 패키지에서는 meanf() 함수를 통해 시계열 데이터의 평균을 활용한 미래 예측값을 반환하는 함수를 제공한다. 이 함수에서는 평균 모델에 의한 점 예측값(Point Forecast)뿐 아니라 예측구간 80%와 95%를 산출해 준다. 매개변수를 설정함으로써 이 예측구간을 Bootstrap 방법을 통해 산출할 수도 있다. meanf() 함수의 입력 데이터는 숫자 벡터나 ts 클래스 객체를 사용한다. meanf()함수의 결과를 plot하기 위해서는 autoplot() 함수에 meanf() 결과 객체를 전달하여 ploting 할 수 있다. library(forecast) summary(meanf(students.total.ts[,1])) ## ## Forecast method: Mean ## ## Model Information: ## $mu ## [1] 7598603 ## ## $mu.se ## [1] 189914 ## ## $sd ## [1] 890775.4 ## ## $bootstrap ## [1] FALSE ## ## $call ## meanf(y = students.total.ts[, 1]) ## ## attr(,&quot;class&quot;) ## [1] &quot;meanf&quot; ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ACF1 ## Training set -1.694451e-10 870295.1 780669 -1.422719 10.7441 6.074563 0.8753895 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## 2021 7598603 6393450 8803757 5704501 9492706 ## 2022 7598603 6393450 8803757 5704501 9492706 ## 2023 7598603 6393450 8803757 5704501 9492706 ## 2024 7598603 6393450 8803757 5704501 9492706 ## 2025 7598603 6393450 8803757 5704501 9492706 ## 2026 7598603 6393450 8803757 5704501 9492706 ## 2027 7598603 6393450 8803757 5704501 9492706 ## 2028 7598603 6393450 8803757 5704501 9492706 ## 2029 7598603 6393450 8803757 5704501 9492706 ## 2030 7598603 6393450 8803757 5704501 9492706 autoplot(meanf(students.total.ts[,1])) autoplot(meanf(students.total.ts[,1], bootstrap = TRUE)) autoplot(meanf(employees.ts[,2])) autoplot(meanf(employees.ts[,3])) 6.1.2 단순(Naive) 모델 단순(Naive) 모델은 시계열 측정값의 마지막 값이 지속될 것이라는 가정하에 향후 데이터값을 예측하는 모델이다. 이 모델은 경제 금융 시계열 모델에서 많이 사용된다.5 앞선 평균 모델과 달리 Naive 모델의 예측구간은 예측 시간이 늘어날수록 범위가 늘어난다. 일반적으로 시계열 모델의 예측구간은 예측기간이 늘어날 수록 범위가 넓어지는 경향을 지닌다. summary(naive(students.total.ts[,1])) ## ## Forecast method: Naive method ## ## Model Information: ## Call: naive(y = students.total.ts[, 1]) ## ## Residual sd: 77849.7308 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ACF1 ## Training set -126815.2 147831.2 128514.4 -1.771615 1.791893 1 0.8922526 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## 2021 5995239 5805786 6184692 5705495 6284983 ## 2022 5995239 5727312 6263166 5585479 6404999 ## 2023 5995239 5667096 6323382 5493388 6497090 ## 2024 5995239 5616332 6374146 5415751 6574727 ## 2025 5995239 5571608 6418870 5347352 6643126 ## 2026 5995239 5531175 6459303 5285514 6704964 ## 2027 5995239 5493993 6496485 5228649 6761829 ## 2028 5995239 5459384 6531094 5175720 6814758 ## 2029 5995239 5426879 6563599 5126007 6864471 ## 2030 5995239 5396135 6594343 5078988 6911490 autoplot(naive(students.total.ts[,1])) summary(naive(employees.ts[,2])) ## ## Forecast method: Naive method ## ## Model Information: ## Call: naive(y = employees.ts[, 2]) ## ## Residual sd: 261.7975 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ## Training set 23.56842 261.4803 194.5579 0.08782727 0.7411892 0.6138395 ## ACF1 ## Training set 0.4208691 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## Jan 2021 26526 26190.90 26861.10 26013.51 27038.49 ## Feb 2021 26526 26052.10 26999.90 25801.23 27250.77 ## Mar 2021 26526 25945.59 27106.41 25638.34 27413.66 ## Apr 2021 26526 25855.80 27196.20 25501.02 27550.98 ## May 2021 26526 25776.69 27275.31 25380.03 27671.97 ## Jun 2021 26526 25705.17 27346.83 25270.66 27781.34 ## Jul 2021 26526 25639.41 27412.59 25170.07 27881.93 ## Aug 2021 26526 25578.19 27473.81 25076.45 27975.55 ## Sep 2021 26526 25520.70 27531.30 24988.52 28063.48 ## Oct 2021 26526 25466.32 27585.68 24905.36 28146.64 autoplot(naive(employees.ts[,2])) summary(naive(employees.ts[,3])) ## ## Forecast method: Naive method ## ## Model Information: ## Call: naive(y = employees.ts[, 3]) ## ## Residual sd: 22.6663 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ## Training set 0.7052632 22.55776 18.17895 0.03288917 0.9893977 0.3603189 ## ACF1 ## Training set 0.08001357 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## Jan 2021 1777 1748.091 1805.909 1732.788 1821.212 ## Feb 2021 1777 1736.117 1817.883 1714.474 1839.526 ## Mar 2021 1777 1726.928 1827.072 1700.422 1853.578 ## Apr 2021 1777 1719.182 1834.818 1688.575 1865.425 ## May 2021 1777 1712.358 1841.642 1678.138 1875.862 ## Jun 2021 1777 1706.188 1847.812 1668.702 1885.298 ## Jul 2021 1777 1700.514 1853.486 1660.025 1893.975 ## Aug 2021 1777 1695.233 1858.767 1651.948 1902.052 ## Sep 2021 1777 1690.273 1863.727 1644.363 1909.637 ## Oct 2021 1777 1685.582 1868.418 1637.188 1916.812 autoplot(naive(employees.ts[,3])) 6.1.3 계절성 단순(Seasonal Naive) 모델 계절성 단순(Seasonal Naive) 모델은 단순(Naive) 모델에서 계절성을 추가한 모델이다. 계절성(Seasonal Pattern)은 주기성(Cyclic Pattern)과 다르다. 계절성은 일정한 주기를 가지고 반복되는 패턴을 의미하지만 주기성은 패턴은 반복되지만 주기가 일정하지 않다는 점에서 다르다. 주기성의 주기는 일반적으로 2년보다 크기때문에 여러 연도에 걸쳐 나타나지만 계절성은 일반적으로 달력의 특성에 연관되어 주기를 갖는 경우가 일반적이다.6 summary(snaive(students.total.ts[,1], 10)) ## ## Forecast method: Seasonal naive method ## ## Model Information: ## Call: snaive(y = students.total.ts[, 1], h = 10) ## ## Residual sd: 77849.7308 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ACF1 ## Training set -126815.2 147831.2 128514.4 -1.771615 1.791893 1 0.8922526 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## 2021 5995239 5805786 6184692 5705495 6284983 ## 2022 5995239 5727312 6263166 5585479 6404999 ## 2023 5995239 5667096 6323382 5493388 6497090 ## 2024 5995239 5616332 6374146 5415751 6574727 ## 2025 5995239 5571608 6418870 5347352 6643126 ## 2026 5995239 5531175 6459303 5285514 6704964 ## 2027 5995239 5493993 6496485 5228649 6761829 ## 2028 5995239 5459384 6531094 5175720 6814758 ## 2029 5995239 5426879 6563599 5126007 6864471 ## 2030 5995239 5396135 6594343 5078988 6911490 autoplot(snaive(students.total.ts[,1], 10)) summary(snaive(employees.ts[,2], 10)) ## ## Forecast method: Seasonal naive method ## ## Model Information: ## Call: snaive(y = employees.ts[, 2], h = 10) ## ## Residual sd: 281.6863 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ACF1 ## Training set 229.2857 361.904 316.9524 0.8720369 1.19817 1 0.8173272 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## Jan 2021 26800 26336.2 27263.8 26090.68 27509.32 ## Feb 2021 26838 26374.2 27301.8 26128.68 27547.32 ## Mar 2021 26609 26145.2 27072.8 25899.68 27318.32 ## Apr 2021 26562 26098.2 27025.8 25852.68 27271.32 ## May 2021 26930 26466.2 27393.8 26220.68 27639.32 ## Jun 2021 27055 26591.2 27518.8 26345.68 27764.32 ## Jul 2021 27106 26642.2 27569.8 26396.68 27815.32 ## Aug 2021 27085 26621.2 27548.8 26375.68 27794.32 ## Sep 2021 27012 26548.2 27475.8 26302.68 27721.32 ## Oct 2021 27088 26624.2 27551.8 26378.68 27797.32 autoplot(snaive(employees.ts[,2], 10)) summary(snaive(employees.ts[,3], 10)) ## ## Forecast method: Seasonal naive method ## ## Model Information: ## Call: snaive(y = employees.ts[, 3], h = 10) ## ## Residual sd: 61.3048 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ACF1 ## Training set 4.5 61.10471 50.45238 0.1996211 2.735763 1 0.8602258 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## Jan 2021 1844 1765.691 1922.309 1724.237 1963.763 ## Feb 2021 1828 1749.691 1906.309 1708.237 1947.763 ## Mar 2021 1770 1691.691 1848.309 1650.237 1889.763 ## Apr 2021 1759 1680.691 1837.309 1639.237 1878.763 ## May 2021 1814 1735.691 1892.309 1694.237 1933.763 ## Jun 2021 1829 1750.691 1907.309 1709.237 1948.763 ## Jul 2021 1831 1752.691 1909.309 1711.237 1950.763 ## Aug 2021 1793 1714.691 1871.309 1673.237 1912.763 ## Sep 2021 1768 1689.691 1846.309 1648.237 1887.763 ## Oct 2021 1772 1693.691 1850.309 1652.237 1891.763 autoplot(snaive(employees.ts[,3], 10)) 6.1.4 Random Work 모델 랜덤 워크는 시간적으로 다음값이 시간적으로 현재값의 영향을 받는다는 이론이다. 주식의 예에서 보면 내일의 종가는 오늘의 종가에 랜덤한 값이 더해지거나 빼져서 결정되는 것과 같은 이치이다. 랜덤 워크에는 어제값 이외에 의미있는 정보가 없기 때문에 예측이 복잡하지 않다7. 앞에서 설명한 Naive 모델은 마지막 값이 지속되는 예측인데 이것이 결국 랜덤 워크와 동일한 결과를 가지게 된다. 랜덤 워크 모델은 드리프트가 없는 모델과 드리프트가 존재하는 모델의 두가지 종류가 있다. 드리프트가 존재하는 모델은 랜덤워크 모델을 기반으로 하지만 예측값이 시간의 흐름에 따라 증가하거나 감소하는 모델이다. summary(rwf(students.total.ts[,1])) ## ## Forecast method: Random walk ## ## Model Information: ## Call: rwf(y = students.total.ts[, 1]) ## ## Residual sd: 77849.7308 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ACF1 ## Training set -126815.2 147831.2 128514.4 -1.771615 1.791893 1 0.8922526 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## 2021 5995239 5805786 6184692 5705495 6284983 ## 2022 5995239 5727312 6263166 5585479 6404999 ## 2023 5995239 5667096 6323382 5493388 6497090 ## 2024 5995239 5616332 6374146 5415751 6574727 ## 2025 5995239 5571608 6418870 5347352 6643126 ## 2026 5995239 5531175 6459303 5285514 6704964 ## 2027 5995239 5493993 6496485 5228649 6761829 ## 2028 5995239 5459384 6531094 5175720 6814758 ## 2029 5995239 5426879 6563599 5126007 6864471 ## 2030 5995239 5396135 6594343 5078988 6911490 autoplot(rwf(students.total.ts[,1])) summary(rwf(employees.ts[,2])) ## ## Forecast method: Random walk ## ## Model Information: ## Call: rwf(y = employees.ts[, 2]) ## ## Residual sd: 261.7975 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ## Training set 23.56842 261.4803 194.5579 0.08782727 0.7411892 0.6138395 ## ACF1 ## Training set 0.4208691 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## Jan 2021 26526 26190.90 26861.10 26013.51 27038.49 ## Feb 2021 26526 26052.10 26999.90 25801.23 27250.77 ## Mar 2021 26526 25945.59 27106.41 25638.34 27413.66 ## Apr 2021 26526 25855.80 27196.20 25501.02 27550.98 ## May 2021 26526 25776.69 27275.31 25380.03 27671.97 ## Jun 2021 26526 25705.17 27346.83 25270.66 27781.34 ## Jul 2021 26526 25639.41 27412.59 25170.07 27881.93 ## Aug 2021 26526 25578.19 27473.81 25076.45 27975.55 ## Sep 2021 26526 25520.70 27531.30 24988.52 28063.48 ## Oct 2021 26526 25466.32 27585.68 24905.36 28146.64 autoplot(rwf(employees.ts[,2])) summary(rwf(employees.ts[,3])) ## ## Forecast method: Random walk ## ## Model Information: ## Call: rwf(y = employees.ts[, 3]) ## ## Residual sd: 22.6663 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ## Training set 0.7052632 22.55776 18.17895 0.03288917 0.9893977 0.3603189 ## ACF1 ## Training set 0.08001357 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## Jan 2021 1777 1748.091 1805.909 1732.788 1821.212 ## Feb 2021 1777 1736.117 1817.883 1714.474 1839.526 ## Mar 2021 1777 1726.928 1827.072 1700.422 1853.578 ## Apr 2021 1777 1719.182 1834.818 1688.575 1865.425 ## May 2021 1777 1712.358 1841.642 1678.138 1875.862 ## Jun 2021 1777 1706.188 1847.812 1668.702 1885.298 ## Jul 2021 1777 1700.514 1853.486 1660.025 1893.975 ## Aug 2021 1777 1695.233 1858.767 1651.948 1902.052 ## Sep 2021 1777 1690.273 1863.727 1644.363 1909.637 ## Oct 2021 1777 1685.582 1868.418 1637.188 1916.812 autoplot(rwf(employees.ts[,3])) summary(rwf(students.total.ts[,1], drift = TRUE)) ## ## Forecast method: Random walk with drift ## ## Model Information: ## Call: rwf(y = students.total.ts[, 1], drift = TRUE) ## ## Drift: -126815.1905 (se 16988.204) ## Residual sd: 77849.7308 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ## Training set -1.773887e-10 75973.56 63881.97 -0.06808499 0.8320398 0.4970802 ## ACF1 ## Training set 0.8922526 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## 2021 5868424 5768655 5968192 5715841 6021006 ## 2022 5741609 5597194 5886023 5520746 5962471 ## 2023 5614793 5433948 5795639 5338214 5891373 ## 2024 5487978 5274664 5701292 5161743 5814214 ## 2025 5361163 5117753 5604573 4988899 5733427 ## 2026 5234348 4962425 5506271 4818478 5650218 ## 2027 5107533 4808227 5406838 4649785 5565281 ## 2028 4980717 4654875 5306560 4482385 5479050 ## 2029 4853902 4502177 5205628 4315985 5391820 ## 2030 4727087 4349998 5104176 4150379 5303795 autoplot(rwf(students.total.ts[,1], drift = TRUE)) summary(rwf(employees.ts[,2], drift = TRUE)) ## ## Forecast method: Random walk with drift ## ## Model Information: ## Call: rwf(y = employees.ts[, 2], drift = TRUE) ## ## Drift: 23.5684 (se 26.8599) ## Residual sd: 261.7975 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ## Training set 9.956667e-13 260.416 190.0696 -0.0013627 0.7245059 0.5996787 ## ACF1 ## Training set 0.4208691 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## Jan 2021 26549.57 26214.06 26885.08 26036.45 27062.68 ## Feb 2021 26573.14 26096.17 27050.11 25843.68 27302.60 ## Mar 2021 26596.71 26009.50 27183.91 25698.66 27494.75 ## Apr 2021 26620.27 25938.75 27301.80 25577.97 27662.58 ## May 2021 26643.84 25877.99 27409.69 25472.58 27815.10 ## Jun 2021 26667.41 25824.24 27510.58 25377.89 27956.93 ## Jul 2021 26690.98 25775.71 27606.25 25291.19 28090.76 ## Aug 2021 26714.55 25731.25 27697.84 25210.72 28218.37 ## Sep 2021 26738.12 25690.07 27786.16 25135.27 28340.96 ## Oct 2021 26761.68 25651.60 27871.77 25063.95 28459.41 autoplot(rwf(employees.ts[,2], drift = TRUE)) summary(rwf(employees.ts[,3], drift = TRUE)) ## ## Forecast method: Random walk with drift ## ## Model Information: ## Call: rwf(y = employees.ts[, 3], drift = TRUE) ## ## Drift: 0.7053 (se 2.3255) ## Residual sd: 22.6663 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ## Training set 3.111458e-14 22.54673 18.14183 -0.005416266 0.9875987 0.3595832 ## ACF1 ## Training set 0.08001357 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## Jan 2021 1777.705 1748.657 1806.753 1733.280 1822.130 ## Feb 2021 1778.411 1737.115 1819.706 1715.254 1841.567 ## Mar 2021 1779.116 1728.276 1829.955 1701.363 1856.868 ## Apr 2021 1779.821 1720.815 1838.827 1689.579 1870.063 ## May 2021 1780.526 1714.219 1846.833 1679.119 1881.934 ## Jun 2021 1781.232 1708.230 1854.233 1669.586 1892.878 ## Jul 2021 1781.937 1702.693 1861.181 1660.744 1903.130 ## Aug 2021 1782.642 1697.509 1867.776 1652.442 1912.843 ## Sep 2021 1783.347 1692.608 1874.087 1644.574 1922.121 ## Oct 2021 1784.053 1687.942 1880.163 1637.064 1931.042 autoplot(rwf(employees.ts[,3], drift = TRUE)) 랜덤 워크는 시간적으로 하나 앞선 값과 현재값을 뺀 차이값들은 백색잡음이 되어야한다는 조건을 만족해야한다. 따라서 랜덤 워크 모델은 차분을 통해서백색잡음이 될 수도 있고 백색잡음은 누적합계를 통해서 랜덤 워크가 될 수 있다. set.seed(345) whitenoise &lt;- ts(rnorm(100), start = 1) ### white noise simulation 데이터 생성 ts.plot(whitenoise) whitenoise.to.randomwalk &lt;- cumsum(whitenoise) ### white noise 데이터로 random walk 생성 ts.plot(whitenoise.to.randomwalk) randomwalk.to.whitenoise &lt;- diff(whitenoise.to.randomwalk) ### random walk에서 white noise 생성 ts.plot(randomwalk.to.whitenoise) 6.1.5 Simple 모델 비교 위에서 설명한 모델들을 하나의 plot으로 그려보면 모델 간의 차이를 살펴볼 수 있다. autoplot(meanf(students.total.ts[,1], h = 10), PI = FALSE, series = &#39;Mean&#39;) + autolayer(naive(students.total.ts[,1], h = 10), PI = FALSE, series = &#39;Naive&#39;) + autolayer(snaive(students.total.ts[,1], h = 10), PI = FALSE, series = &#39;Snaive&#39;) + autolayer(rwf(students.total.ts[,1], h = 10), PI = FALSE, series = &#39;RW&#39;) + autolayer(rwf(students.total.ts[,1], h = 10, drift = TRUE), PI = FALSE, series = &#39;RW with drift&#39;) autoplot(meanf(employees.ts[,2], h = 10), PI = FALSE, series = &#39;Mean&#39;) + autolayer(naive(employees.ts[,2], h = 10), PI = FALSE, series = &#39;Naive&#39;) + autolayer(snaive(employees.ts[,2], h = 10), PI = FALSE, series = &#39;Snaive&#39;) + autolayer(rwf(employees.ts[,2], h = 10), PI = FALSE, series = &#39;RW&#39;) + autolayer(rwf(employees.ts[,2], h = 10, drift = TRUE), PI = FALSE, series = &#39;RW with drift&#39;) autoplot(meanf(employees.ts[,3], h = 10), PI = FALSE, series = &#39;Mean&#39;) + autolayer(naive(employees.ts[,3], h = 10), PI = FALSE, series = &#39;Naive&#39;) + autolayer(snaive(employees.ts[,3], h = 10), PI = FALSE, series = &#39;Snaive&#39;) + autolayer(rwf(employees.ts[,3], h = 10), PI = FALSE, series = &#39;RW&#39;) + autolayer(rwf(employees.ts[,3], h = 10, drift = TRUE), PI = FALSE, series = &#39;RW with drift&#39;) https://otexts.com/fpp2/ https://otexts.com/fpp2/simple-methods.html https://otexts.com/fpp2/simple-methods.html https://robjhyndman.com/hyndsight/cyclicts/ https://robjhyndman.com/files/solutions.pdf "],["regression-모델.html", "6.2 Regression 모델", " 6.2 Regression 모델 회귀 모델은 선형 회귀(Linear Regression), 비선형 회귀,(Non-linear Regression) 로지스틱 회귀(Logistic Regression) 등의 방법이 있다. 회귀 모델은 종속변수와 독립변수와의 관계를 가장 잘 나타내는 회귀방정식을 도출하여 미래 데이터에 대한 예측치를 생성하는 방법으로 아직도 머신러닝 알고리즘 중에 가장 많이 사용되는 알고리즘 중에 하나이다.8 본 문서에서는 R에서 회귀 알고리즘을 구현하는 방법을 다루지는 않고 시계열 데이터의 회귀 알고리즘을 적용하는 방법에 대해 설명하겠다. 시계열 데이터의 회귀 모델은 두가지로 구분할 수 있다. 첫번째는 두가지이상의 시계열 데이터(Multivariate) 간의 회귀 모델과 한가지 시계열 데이터(Univariate)의 시간에 따른 회귀모델이다. 사실 첫번째 모델의 경우는 일반적 회귀모델과 큰 차이는 없지만 사용하는 함수는 시계열 패키지에서 따로 제공된다. 두번째 모델의 경우는 시계열 데이터의 특성인 추세(trend)와 계절성(season), 반복성(cycle)을 회귀에 반영한다는 점에서 일반적 회귀와는 차이가 있다. 시계열 선형 회귀 모델은 데이터간의 관계를 가장 잘 나타내는 직선(Linear)을 산출하여 미래 데이터를 예측하는 방법이다. 선형 회귀 모델은 선형 방정식으로 표현되는데 직선의 기울기(Slope)와 Y 축 절편(Intercept)의 계수(Coefficient)가 산출된다. 시계열 데이터의 선형 회귀를 위해서 forecast 패키지에서 tslm()함수, timetk 패키지의 plot_time_series_regression() 함수(stats::lm() 함수를 사용하여 선형회귀 결과를 ploting하는 함수), modeltime 패키지(timetk 패키지의 모델링 패키지)의 linear_reg() 함수 등을 사용할 수 있다. 6.2.1 tslm 함수(forecast 패키지) forecast 패키지에서 제공하는 tslm() 함수는 시계열 선형회귀 모델을 위한 함수이다. tslm() 함수는 lm() 함수의 래퍼 함수(Wrapper)로 사용법은 비슷하고 시간축이 독립변수에 포함되지 않은 두개 혹은 두개 이상의 시계열 객체에 대한 선형회귀는 lm() 함수의 결과와 같다. 즉 시계열 데이터이지만 독립변수 시간이 포함되지 않는다면 시계열 데이터로써의 특성이 적용되지 않은 양 데이터간의 특성정보만으로 선형회귀 방정식이 얻어진다. 반면 시간을 독립변수로 하여 선형회귀 모형을 적용하기 위해서는 ‘trend,’ ‘season’ 키워드를 함수식의 독립변수에 적용해 줌으로써 시간에 대한 선형회귀 방정식을 얻을 수 있다. ‘trend’는 시계열적인 추세를 반영하여 선형회귀 모델을 만들고 ’season’은 시계열의 계절성을 반영하여 회귀모델을 만들게 되는데 두가지를 모두 고려할 때는’+’ 기호로 연결하여 사용할 수 있다. 이 과정에서 추가적인 독립변수를 추가할 수도 있는데 독립변수를 추가할 때도 ‘+’ 기호를 사용하여 회귀모델을 만들 수 있다. ### 전체 학생수 예측 모델을 추세를 반영하여 생성 student.ts.lm &lt;- tslm(students.total.ts[,1] ~ trend, data = students.total.ts) summary(student.ts.lm) ## ## Call: ## tslm(formula = students.total.ts[, 1] ~ trend, data = students.total.ts) ## ## Residuals: ## Min 1Q Median 3Q Max ## -327962 -206697 -48003 183951 390933 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 9118484 107928 84.49 &lt; 2e-16 *** ## trend -132164 8218 -16.08 6.61e-13 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 244500 on 20 degrees of freedom ## Multiple R-squared: 0.9282, Adjusted R-squared: 0.9246 ## F-statistic: 258.7 on 1 and 20 DF, p-value: 6.608e-13 student.ts.lm %&gt;% forecast() ### tslm 함수로 생성된 모델을 forecast()함수를 통해 예측값을 생성 ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## 2021 6078723 5724474 6432972 5521168 6636278 ## 2022 5946559 5588315 6304804 5382716 6510403 ## 2023 5814396 5451873 6176919 5243818 6384973 ## 2024 5682232 5315157 6049307 5104490 6259974 ## 2025 5550069 5178179 5921959 4964748 6135390 ## 2026 5417905 5040947 5794864 4824607 6011204 ## 2027 5285742 4903471 5668013 4684083 5887401 ## 2028 5153578 4765763 5541394 4543193 5763964 ## 2029 5021415 4627831 5414999 4401950 5640879 ## 2030 4889251 4489686 5288817 4260372 5518131 student.ts.lm %&gt;% forecast() %&gt;% autoplot() student.ts.lm &lt;- tslm(students.total.ts[,3] ~ trend, data = students.total.ts) ### 초등학생 학생수를 예측모델에 독립변수로 트랜드를 사용하는 선형 모델을 생성 student.ts.lm %&gt;% forecast(h = 22) %&gt;% autoplot() student.ts.lm &lt;- tslm(students.total.ts[,3] ~ students.total.ts[,2] + trend, data = students.total.ts) ### 초등학생 학생수를 예측모델에 독립변수로 유치원 학생수와 트랜드를 사용하는 선형 모델을 생성 student.ts.lm %&gt;% forecast(h = 22) %&gt;% autoplot() 위의 예제에서 사용한 데이터는 연도별 학생수의 합계이다. 이 데이터와 같은 연도별 데이터는 계절성이 존재하지 않기 때문에 season 키워드를 사용하면 아래와 같이 에러를 낸다. student.ts.lm &lt;- tslm(students.total.ts[,1] ~ trend + season, data = students.total.ts) ## Error in tslm(students.total.ts[, 1] ~ trend + season, data = students.total.ts): Non-seasonal data cannot be modelled using a seasonal factor 전체 취업자수와 교육서비스업 취업자수에 대한 선형회귀분석 모델과 plot은 다음과 같다. ### 전체 취업자수를 추세(trend)만으로 선형 회귀분석 employee.total.ts.lm &lt;- tslm(employees.ts[,2] ~ trend, data = employees.ts) summary(employee.total.ts.lm) ## ## Call: ## tslm(formula = employees.ts[, 2] ~ trend, data = employees.ts) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1256.4 -264.1 119.9 350.6 525.7 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 25430.605 85.545 297.28 &lt;2e-16 *** ## trend 20.394 1.531 13.32 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 415.8 on 94 degrees of freedom ## Multiple R-squared: 0.6536, Adjusted R-squared: 0.6499 ## F-statistic: 177.3 on 1 and 94 DF, p-value: &lt; 2.2e-16 employee.total.ts.lm %&gt;% forecast() ### tslm 함수로 생성된 모델을 forecast()함수를 통해 예측값을 생성 ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## Jan 2021 27408.79 26860.89 27956.69 26565.89 28251.69 ## Feb 2021 27429.18 26880.94 27977.43 26585.75 28272.62 ## Mar 2021 27449.58 26900.97 27998.18 26605.59 28293.56 ## Apr 2021 27469.97 26921.01 28018.94 26625.43 28314.51 ## May 2021 27490.36 26941.03 28039.70 26645.25 28335.48 ## Jun 2021 27510.76 26961.05 28060.47 26665.07 28356.45 ## Jul 2021 27531.15 26981.06 28081.25 26684.87 28377.43 ## Aug 2021 27551.55 27001.06 28102.03 26704.66 28398.43 ## Sep 2021 27571.94 27021.06 28122.82 26724.45 28419.43 ## Oct 2021 27592.33 27041.05 28143.62 26744.22 28440.45 employee.total.ts.lm %&gt;% forecast() %&gt;% autoplot() ### 전체 취업자수를 추세(trend)와 계절성(season)으로 선형 회귀분석 employee.total.ts.lm &lt;- tslm(employees.ts[,2] ~ trend + season, data = employees.ts) summary(employee.total.ts.lm) ## ## Call: ## tslm(formula = employees.ts[, 2] ~ trend + season, data = employees.ts) ## ## Residuals: ## Min 1Q Median 3Q Max ## -675.70 -42.60 76.66 147.08 312.95 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 24850.616 96.043 258.744 &lt; 2e-16 *** ## trend 19.457 0.919 21.171 &lt; 2e-16 *** ## season2 1.168 123.798 0.009 0.99249 ## season3 318.462 123.808 2.572 0.01189 * ## season4 629.005 123.825 5.080 2.29e-06 *** ## season5 869.174 123.849 7.018 5.63e-10 *** ## season6 919.342 123.880 7.421 9.13e-11 *** ## season7 935.260 123.918 7.547 5.14e-11 *** ## season8 803.429 123.962 6.481 6.13e-09 *** ## season9 854.597 124.013 6.891 9.94e-10 *** ## season10 890.516 124.071 7.177 2.75e-10 *** ## season11 898.809 124.135 7.241 2.07e-10 *** ## season12 385.477 124.207 3.104 0.00261 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 247.6 on 83 degrees of freedom ## Multiple R-squared: 0.8915, Adjusted R-squared: 0.8759 ## F-statistic: 56.86 on 12 and 83 DF, p-value: &lt; 2.2e-16 employee.total.ts.lm %&gt;% forecast() ### tslm 함수로 생성된 모델을 forecast()함수를 통해 예측값을 생성 ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## Jan 2021 26737.91 26392.65 27083.16 26206.34 27269.47 ## Feb 2021 26758.53 26413.28 27103.78 26226.97 27290.09 ## Mar 2021 27095.28 26750.03 27440.53 26563.72 27626.84 ## Apr 2021 27425.28 27080.03 27770.53 26893.72 27956.84 ## May 2021 27684.91 27339.65 28030.16 27153.34 28216.47 ## Jun 2021 27754.53 27409.28 28099.78 27222.97 28286.09 ## Jul 2021 27789.91 27444.65 28135.16 27258.34 28321.47 ## Aug 2021 27677.53 27332.28 28022.78 27145.97 28209.09 ## Sep 2021 27748.16 27402.90 28093.41 27216.59 28279.72 ## Oct 2021 27803.53 27458.28 28148.78 27271.97 28335.09 employee.total.ts.lm %&gt;% forecast() %&gt;% autoplot() ### 교육분야 취업자수를 추세(trend)와 계절성(season)으로 선형 회귀분석 employee.total.ts.lm &lt;- tslm(employees.ts[,3] ~ trend + season, data = employees.ts) summary(employee.total.ts.lm) ## ## Call: ## tslm(formula = employees.ts[, 3] ~ trend + season, data = employees.ts) ## ## Residuals: ## Min 1Q Median 3Q Max ## -106.764 -21.988 6.553 23.192 102.373 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1789.2983 19.0207 94.071 &lt;2e-16 *** ## trend 0.5628 0.1820 3.092 0.0027 ** ## season2 -7.5628 24.5174 -0.308 0.7585 ## season3 6.7493 24.5194 0.275 0.7838 ## season4 19.0615 24.5228 0.777 0.4392 ## season5 32.3737 24.5275 1.320 0.1905 ## season6 41.3108 24.5336 1.684 0.0960 . ## season7 41.2480 24.5410 1.681 0.0966 . ## season8 31.0602 24.5498 1.265 0.2093 ## season9 33.1224 24.5599 1.349 0.1811 ## season10 33.0595 24.5714 1.345 0.1821 ## season11 36.3717 24.5842 1.479 0.1428 ## season12 27.5589 24.5983 1.120 0.2658 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 49.03 on 83 degrees of freedom ## Multiple R-squared: 0.204, Adjusted R-squared: 0.0889 ## F-statistic: 1.772 on 12 and 83 DF, p-value: 0.06634 employee.total.ts.lm %&gt;% forecast() ### tslm 함수로 생성된 모델을 forecast()함수를 통해 예측값을 생성 ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## Jan 2021 1843.893 1775.518 1912.268 1738.621 1949.165 ## Feb 2021 1836.893 1768.518 1905.268 1731.621 1942.165 ## Mar 2021 1851.768 1783.393 1920.143 1746.496 1957.040 ## Apr 2021 1864.643 1796.268 1933.018 1759.371 1969.915 ## May 2021 1878.518 1810.143 1946.893 1773.246 1983.790 ## Jun 2021 1888.018 1819.643 1956.393 1782.746 1993.290 ## Jul 2021 1888.518 1820.143 1956.893 1783.246 1993.790 ## Aug 2021 1878.893 1810.518 1947.268 1773.621 1984.165 ## Sep 2021 1881.518 1813.143 1949.893 1776.246 1986.790 ## Oct 2021 1882.018 1813.643 1950.393 1776.746 1987.290 employee.total.ts.lm %&gt;% forecast() %&gt;% autoplot() 선형 회귀분석을 시행할 때 주의해야 할 점은 잔차가 백색 잡음이어야 한다는 점이다. 잔차의 자가회귀성이 존재하는 경우는 시계열적 특성을 여전히 지니고 있기 때문에 이를 제거할 필요가 있다. 다만 이 예측은 ‘잘못된’ 것은 아니나 예측구간이 커지기 때문에 비효율적 예측 모델이 된다.9 또한 예측에 적용해야할 시계열적 특성이 남아있다는 것을 잔차에서 확인할 수 있다. 아래의 예에서 보면 전체 학생수를 추세에 의해 선형 회귀분석을 시행한 경우 잔차는 자기 상관성을 지니고 있음을 볼 수 있다. checkresiduals() 함수를 사용하여 확인하는데 plot만 봐도 백색잡음이 아님을 확인할 수 있지만 백색잡음 테스트인 Breusch-Godfrey 테스트 결과(checkresiduals() 함수는 회귀모델에 대해서는 Breusch-Godfrey 테스트를, 나머지는 Ljung-Box 테스트를 시행한다.)의 p-value가 0.05보다 작기 때문에 자기상관성이 존재하여 백색잡음으로 볼 수 없다. checkresiduals(tslm(students.total.ts[,1] ~ trend, data = students.total.ts)) ## ## Breusch-Godfrey test for serial correlation of order up to 5 ## ## data: Residuals from Linear regression model ## LM test = 19.584, df = 5, p-value = 0.001496 6.2.2 plot_time_series_regression 함수(timetk 패키지) timetk 패키지는 시계열 데이터를 핸들링하고 plotting 하는 데 주로 활용하는 패키지이다. 그래서 모델링을 위한 함수를 바로 제공하지는 않고 plotting 함수에서 회귀 모델을 호출하여 회귀 결과를 plotting 하는 함수를 제공한다. plot_time_series_regression() 함수에서 사용하는 선형회귀 함수에서도 trend, season 을 적용할 수 없다. 다만 ts 객체가 아닌 data.frame 객체를 사용할 수있다는 장점이 있다. plot_time_series_regression(.data = students %&gt;% filter(지역규모 == &#39;계&#39;), .date_var = 연도, .formula = 학생수계 ~ 연도, .interactive = FALSE, .show_summary = TRUE) ## ## Call: ## stats::lm(formula = .formula, data = .data) ## ## Residuals: ## Min 1Q Median 3Q Max ## -327962 -206697 -48003 183951 390933 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 273181173 16513086 16.54 3.90e-13 *** ## 연도 -132164 8218 -16.08 6.61e-13 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 244500 on 20 degrees of freedom ## Multiple R-squared: 0.9282, Adjusted R-squared: 0.9246 ## F-statistic: 258.7 on 1 and 20 DF, p-value: 6.608e-13 employees$date &lt;- as.Date(as.yearmon(employees$time, &quot;%Y. %m&quot;)) ###as.Date(paste0(employees[, 1], &#39;. 01&#39;), format = &#39;%Y. %m. %d&#39;) ### plot_time_series_regression에 trend만 반영시 plot_time_series_regression(.data = employees, .date_var = time, .formula = total ~ as.numeric(date), .interactive = FALSE) ### plot_time_series_regression에 trend, season(월)까지 반영시 plot_time_series_regression(.data = employees, .date_var = time, .formula = total ~ as.numeric(date) + lubridate::month(date, label = TRUE), .interactive = FALSE) ### plot_time_series_regression에 trend만 반영시 plot_time_series_regression(.data = employees, .date_var = time, .formula = employees.edu ~ as.numeric(date), .interactive = FALSE) # plot_time_series_regression에 trend, season(월)까지 반영시 plot_time_series_regression(.data = employees, .date_var = time, .formula = employees.edu ~ as.numeric(date) + lubridate::month(date, label = TRUE), .interactive = FALSE) 이기준 외, 인구지형변화에 따른 머신러닝 기반 고등교육 계열별 수요예측 모형 개발(2020), 한국교육개발원 https://otexts.com/fppkr/regression-evaluation.html "],["지수-평활exponential-smoothing-모델.html", "6.3 지수 평활(Exponential Smoothing) 모델", " 6.3 지수 평활(Exponential Smoothing) 모델 지수평활 모델은 1950년대에 제안된 모델로 랜덤 워크(Random Walk) 모델과 같이 시계열 적으로 최근의 값이 유지될 확률이 크다는 점에서 나온 모델이다. 다만 랜덤 워크 모델과 같이 마지막 값에 모든 가중치를 둬서 일정하게 유지하는 것이 아닌 현재와 가까운 과거에 더 많은 가중치를 주고 이들의 이동 평균값을 구해서 예측하는 방법이다.10 최근의 데이터에 가중치를 높게 주기 때문에 추세, 계절성, 순환성이 심하지 않은 단기 데이터의 모델링에 적합한 방법이다. 추세나 계절성이 없는 데이터에 적합한 ’단순 지수평활 모델(Simple Exponential Smoothign), 추세가 있는 데이터에 적합한 홀트(Holt) 모델, 추세와 계절성이 있는 데이터에 적합한 홀트-윈터(Holt-Winter) 모델 등이 있다. 지수 평활 모델에서 핵심적인 변수는 평활 계수이다. 평활 매개변수는 앞서 설명한 현재와 가까운 과거에 할당하는 가중치를 의미한다. 평활 매개변수은 보통 0에서 1사이의 변수인데 홀트 모델이나 홀트-윈터 모델에서는 추가적인 계수가 추가될 수 있다. 이고 이 가중치를 어떻게 설정하는 가에 따라 예측 모델의 성능도 달라질 수 있다. 필자는 처음 이 모델을 접했을때 왜 지수(Exponential)과 평활(Smoothing) 이라는 이름을 사용했는지 궁금했다. 평활 매개변수를 설명하는 과정에서 명칭에서 지수를 붙인 이유는 설명이 되겠지만 아직도 평활이라는 이름을 붙인 이유는 명쾌하게 이해되지는 않는다. 시계열 데이터에 대한 추세선을 부드럽게, 스무딩하게 만드는 모델이라고 생각이 되나 사실 홀트-윈터 모델을 보면 별로 부드럽지 않다는 느낌이 들어서 이 부분에 대해 잘 아시는 분은 알려주시길 부탁드린다. 6.3.1 단순 지수 평활 모델(Simple Exponentail Smoothing Model) 단순 지수 평활 모델은 추세, 계절성 등의 시계열적 특성이 비교적 약한 데이터에 적합한 예측 모델이다. 단순 지수 평활 모델을 사용하기 위해서는 우선 평활 계수를 설정해아한다. 평활 계수는 과거치에 대한 가중치로 현재에 가장 가까운 첫번째 과거 데이터에 대한 가중치이다. 이후 가중치 들은 1에서 가중치를 뺀 가중치(1-평활계수)로 설정하고 과거로 계속 갈수록 (1-평활계수)를 계속 곱해서 가중치를 할당한다. 평활 계수를 0.5로 가정하고 학생수 예에 적용해 보면 다음의 표와 같이 가중치가 설정되게 된다. 평활 계수가 지수형태로 계산되기 때문에 평활계수의 합은 1이 될 수 없다. 연도 가중치(평활계수 = 0.5) 2020 0.5 2019 0.25 = (1 - 0.5) 2018 0.125 = (1 - 0.5) * (1 - 0.5) 2017 0.0625 = (1 - 0.5) * (1 - 0.5) * (1 - 0.5) … … 6.3.1.1 forecast::ses() 함수 단순 지수 평활 모델을 적용하는 방법은 forecast 패키지의 ses() 함수를 사용하면 모델을 구축할 수 있다. ses() 함수에서는 평활 계수를 alpha 매개변수를 통해 설정할 수 있지만 설정하지 않으면 자동으로 계산하여 설정해준다. ses() 함수는 뒤에서 설명하는 홀트 모델, 홀트-윈터 모델도 beta와 gamma 매개변수를 통해 생성할 수 있다. ses() 함수를 통해 생성되는 모델은 몇가지 특성값을 가지는데 앞에서 설명한 평활계수가 alpha로 표현되고 초기상태값인 l 값이 나타난다. 단순 지수 평활 모델은 한단계씩 예측해나가는 방법(One Step Forecast)이기 때문에 초기값인 l값부터 시작하여 한단계 앞 값을 예측하고 또 다음 단계를 예측하는 방법으로 수행된다. l 값을 산출하는 방법은 Rob Hyndman의 저서에서 확인할 수 있다.11 이는 ses() 모델을 summary() 함수를 통해 실행시키면 확인이 가능하다. ### 전체 학생수에 대한 Simple Exponential Smoothing ses(students.total.ts[,1]) ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## 2021 5995252 5786909 6203594 5676619 6313884 ## 2022 5995252 5700626 6289878 5544660 6445843 ## 2023 5995252 5634416 6356087 5443401 6547102 ## 2024 5995252 5578598 6411905 5358035 6632468 ## 2025 5995252 5529421 6461082 5282825 6707678 ## 2026 5995252 5484962 6505542 5214830 6775673 ## 2027 5995252 5444077 6546427 5152302 6838201 ## 2028 5995252 5406022 6584481 5094103 6896401 ## 2029 5995252 5370280 6620223 5039440 6951063 ## 2030 5995252 5336474 6654029 4987739 7002765 autoplot(students.total.ts[,1]) + autolayer(fitted(ses(students.total.ts[,1])), series = &#39;ses 적합값&#39;) + autolayer(ses(students.total.ts[,1])) summary(ses(students.total.ts[,1])) ## ## Forecast method: Simple exponential smoothing ## ## Model Information: ## Simple exponential smoothing ## ## Call: ## ses(y = students.total.ts[, 1]) ## ## Smoothing parameters: ## alpha = 0.9999 ## ## Initial states: ## l = 8394600.8229 ## ## sigma: 162570.5 ## ## AIC AICc BIC ## 599.8562 601.1896 603.1294 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ACF1 ## Training set -109072.2 155004.8 134671.7 -1.552769 1.849053 1.047911 0.4105529 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## 2021 5995252 5786909 6203594 5676619 6313884 ## 2022 5995252 5700626 6289878 5544660 6445843 ## 2023 5995252 5634416 6356087 5443401 6547102 ## 2024 5995252 5578598 6411905 5358035 6632468 ## 2025 5995252 5529421 6461082 5282825 6707678 ## 2026 5995252 5484962 6505542 5214830 6775673 ## 2027 5995252 5444077 6546427 5152302 6838201 ## 2028 5995252 5406022 6584481 5094103 6896401 ## 2029 5995252 5370280 6620223 5039440 6951063 ## 2030 5995252 5336474 6654029 4987739 7002765 ses(students.total.ts[,1], alpha = 0.5) ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## 2021 6143847 5780270 6507425 5587804 6699891 ## 2022 6143847 5737355 6550339 5522172 6765523 ## 2023 6143847 5698558 6589137 5462836 6824859 ## 2024 6143847 5662880 6624815 5408271 6879424 ## 2025 6143847 5629671 6658023 5357483 6930212 ## 2026 6143847 5598481 6689213 5309782 6977913 ## 2027 6143847 5568981 6718713 5264665 7023029 ## 2028 6143847 5540922 6746772 5221753 7065941 ## 2029 6143847 5514113 6773582 5180752 7106943 ## 2030 6143847 5488399 6799296 5141425 7146269 ses(students.total.ts[,1], alpha = 0.5) %&gt;% autoplot() ### 전체 취업자수에 대한 Simple Exponential Smoothing autoplot(employees.ts[,2]) + autolayer(fitted(ses(employees.ts[,2])), series = &#39;ses 적합값&#39;) + autolayer(ses(employees.ts[,2])) ### 코로나 신규확진자수(0-9세)에 대한 Simple Exponential Smoothing autoplot(wide.covid19.by.age.ts[,2]) + autolayer(fitted(ses(wide.covid19.by.age.ts[,2])), series = &#39;ses 적합값&#39;) + autolayer(ses(wide.covid19.by.age.ts[,2])) 평활 계수가 클수록 데이터 변화에 빠르게 반응하여 예측의 감응도가 높지만 평활계수가 작으면 데이터의 변화에 느리게 반응하여 예측의 안정성이 높아진다12 ### 전체 학생수의 alpha 값에 따른 적합치와 예측치의 변화 autoplot(students.total.ts[,1], color = &#39;black&#39;) + autolayer(fitted(ses(students.total.ts[,1], alpha = 0.1)), series = &#39;alpha = 0.1&#39;) + autolayer(ses(students.total.ts[,1], alpha = 0.1, PI = FALSE), series = &#39;alpha = 0.1&#39;) + autolayer(fitted(ses(students.total.ts[,1], alpha = 0.2)), series = &#39;alpha = 0.2&#39;) + autolayer(ses(students.total.ts[,1], alpha = 0.2, PI = FALSE), series = &#39;alpha = 0.2&#39;) + autolayer(fitted(ses(students.total.ts[,1], alpha = 0.3)), series = &#39;alpha = 0.3&#39;) + autolayer(ses(students.total.ts[,1], alpha = 0.3, PI = FALSE), series = &#39;alpha = 0.3&#39;) + autolayer(fitted(ses(students.total.ts[,1], alpha = 0.4)), series = &#39;alpha = 0.4&#39;) + autolayer(ses(students.total.ts[,1], alpha = 0.4, PI = FALSE), series = &#39;alpha = 0.4&#39;) + autolayer(fitted(ses(students.total.ts[,1], alpha = 0.5)), series = &#39;alpha = 0.5&#39;) + autolayer(ses(students.total.ts[,1], alpha = 0.5, PI = FALSE), series = &#39;alpha = 0.5&#39;) + autolayer(fitted(ses(students.total.ts[,1], alpha = 0.6)), series = &#39;alpha = 0.6&#39;) + autolayer(ses(students.total.ts[,1], alpha = 0.6, PI = FALSE), series = &#39;alpha = 0.6&#39;) + autolayer(fitted(ses(students.total.ts[,1], alpha = 0.7)), series = &#39;alpha = 0.7&#39;) + autolayer(ses(students.total.ts[,1], alpha = 0.7, PI = FALSE), series = &#39;alpha = 0.7&#39;) + autolayer(fitted(ses(students.total.ts[,1], alpha = 0.8)), series = &#39;alpha = 0.8&#39;) + autolayer(ses(students.total.ts[,1], alpha = 0.8, PI = FALSE), series = &#39;alpha = 0.8&#39;) + autolayer(fitted(ses(students.total.ts[,1], alpha = 0.9)), series = &#39;alpha = 0.9&#39;) + autolayer(ses(students.total.ts[,1], alpha = 0.9, PI = FALSE), series = &#39;alpha = 0.9&#39;) 6.3.1.2 stats::HoltWinters() 함수 R에서 기초 통계 패키지로 제공하는 stat 패키지에서 지수 평활 모델을 구축할 수 있는 HoltWinters() 함수를 제공한다. 다음절에서 소개하겠지만 HoltWinter 모델은 지수 평활 모델에서 추세와 계절성을 가진 데이터를 대상으로 구축하는 모델이다. 하지만 stats 패키지에서는 HoltWinters() 함수에 매개변수를 조절함으로써 단순지수평활 모델, 홀트 모델, 홀트-윈터 모델을 각각 구축할 수 있다. HoltWinters() 함수의 beta(추세), gamma(계절성) 매개변수를 모두 FALSE로 설정함으로써 단순 지수 평활 모델을 구축할 수 있다. 계산방식의 차이로 인해 forecast::ses() 함수와는 다소 차이가 난다. ### 전체 학생수에 대한 Simple Exponential Smoothing modeling HoltWinters(students.total.ts[,1], beta = F, gamma = F) ## Holt-Winters exponential smoothing without trend and without seasonal component. ## ## Call: ## HoltWinters(x = students.total.ts[, 1], beta = F, gamma = F) ## ## Smoothing parameters: ## alpha: 0.9999575 ## beta : FALSE ## gamma: FALSE ## ## Coefficients: ## [,1] ## a 5995244 plot(HoltWinters(students.total.ts[,1], beta = F, gamma = F)) HoltWinters(students.total.ts[,1], alpha = 0.1, beta = F, gamma = F) ## Holt-Winters exponential smoothing without trend and without seasonal component. ## ## Call: ## HoltWinters(x = students.total.ts[, 1], alpha = 0.1, beta = F, gamma = F) ## ## Smoothing parameters: ## alpha: 0.1 ## beta : FALSE ## gamma: FALSE ## ## Coefficients: ## [,1] ## a 7207200 plot(HoltWinters(students.total.ts[,1], alpha = 0.1, beta = F, gamma = F)) ### 전체 취업자수에 대한 Simple Exponential Smoothing modeling plot(HoltWinters(employees.ts[,2], beta = F, gamma = F)) ### 코로나 신규확진자수(0-9세)에 대한 Simple Exponential Smoothing modeling plot(HoltWinters(wide.covid19.by.age.ts[,2], beta = F, gamma = F)) 6.3.2 홀트(Holt) 모델 홀트(holt) 모델은 지수 평활 모델을 확장하여 추세를 반영하는 모델이다. 홀트 모델은 추세조정 지수평활법이나 이중 지수 평활법으로 해석되기도 한다. 추세를 반영하기 위해 평활 계수인 alpha와 추세 기울기 값 beta를 사용하여 모델을 세운다. 평활 계수 값과 마찬가지로 추세 기울기 값도 0과 1사이의 값을 지니고 이 값을 반영한 이동평균을 통해 예측값을 산출한다. 6.3.2.1 forecast::holt() 함수 홀트 모델은 앞선 단순 지수 평활 모델에 사용했던 ses() 함수에 추세 기울기 값인 beta 값을 추가하여 사용할 수도 있고 forecast 패키지에서 제공하는 holt() 함수를 사용하여 모델을 생성할 수도 있다. 다만 alpha, beta 등의 매개변수를 지정하지 않으면 자동 계산되어 적절한 값이 사용된다. ### 전체 학생수에 대한 Holt modeling autoplot(students.total.ts[,1]) + autolayer(fitted(holt(students.total.ts[,1])), series = &#39;적합값&#39;) + autolayer(holt(students.total.ts[,1]), series = &#39;예측값&#39;) summary(holt(students.total.ts[,1])) ## ## Forecast method: Holt&#39;s method ## ## Model Information: ## Holt&#39;s method ## ## Call: ## holt(y = students.total.ts[, 1]) ## ## Smoothing parameters: ## alpha = 0.8654 ## beta = 0.8654 ## ## Initial states: ## l = 8966192.6427 ## b = -36934.0002 ## ## sigma: 82114.94 ## ## AIC AICc BIC ## 571.4867 575.2367 576.9419 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ## Training set -5106.807 74275.76 46971.89 -0.0472354 0.5836661 0.365499 ## ACF1 ## Training set -0.00685211 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## 2021 5855531 5750297 5960766 5694589 6016474 ## 2022 5721369 5511013 5931725 5399658 6043081 ## 2023 5587207 5242397 5932018 5059866 6114549 ## 2024 5453045 4951452 5954638 4685925 6220166 ## 2025 5318883 4641431 5996336 4282810 6354957 ## 2026 5184721 4314366 6055077 3853627 6515816 ## 2027 5050559 3971709 6129409 3400601 6700518 ## 2028 4916397 3614582 6218212 2925443 6907352 ## 2029 4782235 3243885 6320586 2429531 7134940 ## 2030 4648073 2860364 6435783 1914007 7382139 ### 전체 취업자수에 대한 Holt modeling autoplot(employees.ts[,2]) + autolayer(fitted(holt(employees.ts[,2])), series = &#39;적합값&#39;) + autolayer(holt(employees.ts[,2]), series = &#39;예측값&#39;) ### 교육서비스업 취업자수에 대한 Holt modeling autoplot(employees.ts[,3]) + autolayer(fitted(holt(employees.ts[,3])), series = &#39;적합값&#39;) + autolayer(holt(employees.ts[,3]), series = &#39;예측값&#39;) ### 코로나 신규확진자수(0-9세)에 대한 Holt modeling autoplot(wide.covid19.by.age.ts[,2]) + autolayer(fitted(holt(wide.covid19.by.age.ts[,2])), series = &#39;적합값&#39;) + autolayer(holt(wide.covid19.by.age.ts[,2]), series = &#39;예측값&#39;) 홀트 모델은 위와 같이 일정한 증가, 감소가 나타난다. 추세가 증가 추세이면 예측값이 계속 증가하게 되고 감소추세이면 계속 감소하게 된다. 특히 감소추세 일때 계속 감소하면 어느 순간 음수값을 가질수도 있다. 따라서 감소 추세가 있는 경우 어느정도에서 감소추세를 지연시킬 필요가 있다. holt() 함수에서는 damped 매개변수를 통해 감소추세를 지연시킬 수 있다. ### 전체 학생수에 대한 Holt modeling 비교 autoplot(students.total.ts[,1]) + autolayer(fitted(holt(students.total.ts[,1])), series = &#39;holt&#39;) + autolayer(fitted(holt(students.total.ts[,1], damped = TRUE)), series = &#39;holt damped&#39;) + autolayer(holt(students.total.ts[,1]), series = &#39;예측&#39;, PI = FALSE) + autolayer(holt(students.total.ts[,1], damped = TRUE), series = &#39;damped 예측&#39;, PI = FALSE) ### 전체 취업자수에 대한 Holt modeling 비교 autoplot(employees.ts[,2]) + autolayer(fitted(holt(employees.ts[,2])), series = &#39;holt&#39;) + autolayer(fitted(holt(employees.ts[,2], damped = TRUE)), series = &#39;holt damped&#39;) + autolayer(holt(employees.ts[,2]), series = &#39;예측&#39;, PI = FALSE) + autolayer(holt(employees.ts[,2], damped = TRUE), series = &#39;damped 예측&#39;, PI = FALSE) ### 코로나 신규확진자수(0-9세)에 대한 Holt modeling 비교 autoplot(wide.covid19.by.age.ts[,2]) + autolayer(fitted(holt(wide.covid19.by.age.ts[,2])), series = &#39;holt&#39;) + autolayer(fitted(holt(wide.covid19.by.age.ts[,2], damped = TRUE)), series = &#39;holt damped&#39;) + autolayer(holt(wide.covid19.by.age.ts[,2], h = 20), series = &#39;예측&#39;, PI = FALSE) + autolayer(holt(wide.covid19.by.age.ts[,2], h = 20, damped = TRUE), series = &#39;damped 예측&#39;, PI = FALSE) 추세 기울기 값에 따른 변동은 아래 plot과 같이 나타난다. 사실상 추세 기울기 값은 결과값에 큰 차이를 나타내지 않는다. autoplot(employees.ts[,2]) + autolayer(fitted(holt(employees.ts[,2], beta = 0.1)), series = &#39;beta = 0.1&#39;) + autolayer(fitted(holt(employees.ts[,2], beta = 0.2)), series = &#39;beta = 0.2&#39;) + autolayer(fitted(holt(employees.ts[,2], beta = 0.3)), series = &#39;beta = 0.3&#39;) + autolayer(fitted(holt(employees.ts[,2], beta = 0.4)), series = &#39;beta = 0.4&#39;) + autolayer(fitted(holt(employees.ts[,2], beta = 0.5)), series = &#39;beta = 0.5&#39;) + autolayer(fitted(holt(employees.ts[,2], beta = 0.6)), series = &#39;beta = 0.6&#39;) + autolayer(fitted(holt(employees.ts[,2], beta = 0.7)), series = &#39;beta = 0.7&#39;) + autolayer(fitted(holt(employees.ts[,2], beta = 0.8)), series = &#39;beta = 0.8&#39;) + autolayer(fitted(holt(employees.ts[,2], beta = 0.9)), series = &#39;beta = 0.9&#39;) 6.3.2.2 stats::HoltWinters() 함수 앞서 설명한 바와 같이 R에서 기초 통계 패키지로 제공하는 stat 패키지에서 홀트 모델을 구축하기 위해서는 HoltWinters() 함수를 제공한다. stats 패키지의 HoltWinters() 함수 매개변수인 gamma(계절성) 매개변수를 FALSE로 설정함으로써 홀트 모델을 구축할 수 있다. 계산방식의 차이로 인해 forecast::holt() 함수와는 다소 차이가 난다. ### 전체 학생수에 대한 Holt modeling HoltWinters(students.total.ts[,1], gamma = F) ## Holt-Winters exponential smoothing with trend and without seasonal component. ## ## Call: ## HoltWinters(x = students.total.ts[, 1], gamma = F) ## ## Smoothing parameters: ## alpha: 1 ## beta : 0 ## gamma: FALSE ## ## Coefficients: ## [,1] ## a 5995239 ## b -122491 plot(HoltWinters(students.total.ts[,1], gamma = F)) HoltWinters(students.total.ts[,1], alpha = 0.1, gamma = F) ## Holt-Winters exponential smoothing with trend and without seasonal component. ## ## Call: ## HoltWinters(x = students.total.ts[, 1], alpha = 0.1, gamma = F) ## ## Smoothing parameters: ## alpha: 0.1 ## beta : 0.9999339 ## gamma: FALSE ## ## Coefficients: ## [,1] ## a 5671013 ## b -257528 plot(HoltWinters(students.total.ts[,1], alpha = 0.1, gamma = F)) ### 전체 취업자수에 대한 Holt modeling plot(HoltWinters(employees.ts[,2], gamma = F)) ### 코로나 신규확진자수(0-9세)에 대한 Holt modeling plot(HoltWinters(wide.covid19.by.age.ts[,2], gamma = F)) 6.3.3 홀트-윈터(Holt-Winter) 모델 홀트-윈터(Holt-Winter) 모델은 단순 지수 평활 모델을 확장하여 추세와 계절성을 반영하는 모델이다. 홀트-윈터 모델은 ses 모델의 alpha, 홀트 모델의 beta에 계절 매개변수인 gamma까지 포함하기 때문에 삼중 지수 평활법이나 계절조정 지수 평활법이라고도 한다. 홀트-윈터 모델도 앞선 홀트 모델과 같이 ses() 함수에 추세 기울기 값인 beta 값과 계절 변수인 gamma 값을 추가하여 사용할 수도 있고 forecast 패키지에서 제공하는 hw() 함수를 사용하여 모델을 생성할 수도 있다. 다만 alpha, beta 등의 매개변수를 지정하지 않으면 자동 계산되어 적절한 값이 사용된다. 6.3.3.1 forecast::hw() 함수 홀트-윈터 모델은 가산법(additive)와 승산법(multiplicative)의 두가지 방법이 있다. autoplot(employees.ts[,2]) + autolayer(fitted(hw(employees.ts[,2])), series = &#39;hw 적합값&#39;) + autolayer(hw(employees.ts[,2], seasonal = &#39;additive&#39;), PI = FALSE, series = &#39;additive&#39;) + autolayer(hw(employees.ts[,2], seasonal = &#39;multiplicative&#39;), PI = FALSE, series = &#39;multiplicative&#39;) summary(hw(employees.ts[,2])) ## ## Forecast method: Holt-Winters&#39; additive method ## ## Model Information: ## Holt-Winters&#39; additive method ## ## Call: ## hw(y = employees.ts[, 2]) ## ## Smoothing parameters: ## alpha = 0.9985 ## beta = 0.0147 ## gamma = 1e-04 ## ## Initial states: ## l = 25433.0105 ## b = 35.8063 ## s = -214.0764 256.3016 260.68 226.9136 162.9304 313.7855 ## 278.5719 219.3763 -4.9043 -297.3507 -579.3511 -622.8768 ## ## sigma: 134.5373 ## ## AIC AICc BIC ## 1395.828 1403.674 1439.422 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ## Training set -14.96946 122.8152 78.83536 -0.0580682 0.301646 0.2487293 ## ACF1 ## Training set 0.07031624 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## Jan 2021 26132.22 25959.80 26304.64 25868.53 26395.91 ## Feb 2021 26190.42 25944.97 26435.88 25815.03 26565.82 ## Mar 2021 26487.18 26184.42 26789.93 26024.15 26950.20 ## Apr 2021 26794.28 26442.17 27146.39 26255.78 27332.78 ## May 2021 27033.23 26636.73 27429.74 26426.83 27639.63 ## Jun 2021 27107.08 26669.61 27544.55 26438.02 27776.14 ## Jul 2021 27156.96 26681.05 27632.87 26429.11 27884.80 ## Aug 2021 27020.82 26508.41 27533.22 26237.16 27804.47 ## Sep 2021 27099.44 26552.09 27646.80 26262.34 27936.55 ## Oct 2021 27147.90 26566.85 27728.95 26259.27 28036.53 ## Nov 2021 27158.21 26544.51 27771.91 26219.63 28096.78 ## Dec 2021 26702.45 26056.97 27347.94 25715.27 27689.63 ## Jan 2022 26308.32 25631.78 26984.86 25273.65 27342.99 ## Feb 2022 26366.53 25659.58 27073.48 25285.34 27447.71 ## Mar 2022 26663.28 25926.46 27400.09 25536.41 27790.14 ## Apr 2022 26970.38 26204.17 27736.59 25798.56 28142.20 ## May 2022 27209.33 26414.14 28004.53 25993.19 28425.48 ## Jun 2022 27283.18 26459.36 28107.00 26023.26 28543.10 ## Jul 2022 27333.06 26480.94 28185.18 26029.85 28636.27 ## Aug 2022 27196.92 26316.77 28077.07 25850.85 28542.99 ## Sep 2022 27275.54 26367.62 28183.47 25886.99 28664.10 ## Oct 2022 27324.00 26388.51 28259.49 25893.29 28754.71 ## Nov 2022 27334.31 26371.45 28297.17 25861.74 28806.88 ## Dec 2022 26878.55 25888.49 27868.61 25364.38 28392.72 autoplot(employees.ts[,3]) + autolayer(fitted(hw(employees.ts[,3])), series = &#39;hw 적합값&#39;) + autolayer(hw(employees.ts[,3], seasonal = &#39;additive&#39;), PI = FALSE, series = &#39;additive&#39;) + autolayer(hw(employees.ts[,3], seasonal = &#39;multiplicative&#39;), PI = FALSE, series = &#39;multiplicative&#39;) summary(hw(employees.ts[,3])) ## ## Forecast method: Holt-Winters&#39; additive method ## ## Model Information: ## Holt-Winters&#39; additive method ## ## Call: ## hw(y = employees.ts[, 3]) ## ## Smoothing parameters: ## alpha = 0.9993 ## beta = 1e-04 ## gamma = 1e-04 ## ## Initial states: ## l = 1803.8967 ## b = 1.4736 ## s = 4.0914 11.645 10.8291 12.0963 5.0654 13.0499 ## 15.2957 6.1821 -5.524 -14.7346 -27.3353 -30.661 ## ## sigma: 22.6819 ## ## AIC AICc BIC ## 1054.015 1061.862 1097.609 ## ## Error measures: ## ME RMSE MAE MPE MAPE MASE ## Training set -1.794203 20.70565 16.09606 -0.1054265 0.878707 0.3190346 ## ACF1 ## Training set 0.01039296 ## ## Forecasts: ## Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 ## Jan 2021 1743.702 1714.634 1772.770 1699.246 1788.158 ## Feb 2021 1748.476 1707.380 1789.571 1685.625 1811.326 ## Mar 2021 1762.544 1712.216 1812.873 1685.574 1839.515 ## Apr 2021 1773.212 1715.098 1831.326 1684.334 1862.090 ## May 2021 1786.372 1721.398 1851.346 1687.002 1885.742 ## Jun 2021 1796.939 1725.761 1868.117 1688.082 1905.797 ## Jul 2021 1796.151 1719.268 1873.035 1678.568 1913.735 ## Aug 2021 1789.618 1707.422 1871.813 1663.911 1915.325 ## Sep 2021 1798.101 1710.916 1885.286 1664.763 1931.439 ## Oct 2021 1798.296 1706.391 1890.201 1657.739 1938.853 ## Nov 2021 1800.569 1704.173 1896.964 1653.144 1947.993 ## Dec 2021 1794.467 1693.780 1895.153 1640.480 1948.453 ## Jan 2022 1761.168 1656.364 1865.971 1600.884 1921.451 ## Feb 2022 1765.941 1657.176 1874.706 1599.599 1932.283 ## Mar 2022 1780.010 1667.422 1892.598 1607.821 1952.199 ## Apr 2022 1790.677 1674.391 1906.964 1612.833 1968.522 ## May 2022 1803.838 1683.966 1923.709 1620.510 1987.165 ## Jun 2022 1814.405 1691.052 1937.757 1625.753 2003.056 ## Jul 2022 1813.617 1686.878 1940.356 1619.786 2007.447 ## Aug 2022 1807.083 1677.045 1937.121 1608.207 2005.960 ## Sep 2022 1815.567 1682.311 1948.823 1611.769 2019.365 ## Oct 2022 1815.761 1679.362 1952.160 1607.157 2024.366 ## Nov 2022 1818.034 1678.562 1957.506 1604.731 2031.337 ## Dec 2022 1811.932 1669.453 1954.411 1594.030 2029.834 가산법은 계절성의 변화 비교적 일정하게 나타날때 사용하는 방법이고 승산법은 계절성의 진폭이 추세에 비례하여 변동이 있을때 사용하는 방법이다. 따라서 미래 예측치를 산출할 때도 가산법은 예측치가 크게 변동되지 않지만 승산법은 먼 미래일 수록 예측값이 커지게 된다. 가산법과 승산법을 사용하는 방법은 hw() 함수에서 seasonal 매개변수를 통해 설정할 수 있다. seasonal 매개변수를 ’additive’로 설정하면 가산법, ’multiplicative’를 설정하면 승산법을 사용하여 모델이 구축된다. 사실상 가산법과 승산법 중 어느 방법을 선택해야하는 지를 선택하는 방법은 시각적으로 확인하거나 다음 장에서 설명할 모델 성능 비교 방법을 통해 선택해야한다. 6.3.3.2 stats::HoltWinters() 함수 ### 전체 취업자수에 대한 Holt modeling HoltWinters(employees.ts[,2]) ## Holt-Winters exponential smoothing with trend and additive seasonal component. ## ## Call: ## HoltWinters(x = employees.ts[, 2]) ## ## Smoothing parameters: ## alpha: 0.8076352 ## beta : 0.03404805 ## gamma: 1 ## ## Coefficients: ## [,1] ## a 26855.065147 ## b 5.905479 ## s1 -696.530450 ## s2 -655.242183 ## s3 -383.258290 ## s4 -42.097658 ## s5 302.244998 ## s6 336.581062 ## s7 320.213201 ## s8 185.326285 ## s9 180.483570 ## s10 233.705448 ## s11 246.451216 ## s12 -329.065147 plot(HoltWinters(employees.ts[,2])) plot(HoltWinters(employees.ts[,3])) 6.3.4 ETS 모델 ETS 모델은 Error, Trend, Season의 앞글자만 따서 만들었다고도 하고 ExponenTial Smoothing의 약자라고도 한다. 앞서 설명한 지수 평활 모델을 잔차(실제값 - 적합값)로 보정한 모델이다. ETS 모델은 모델을 구성하는 방법에 따라 여러가지 모델로 구분될 수 있다. 각 모델은 실 데이터의 측정식(measurement equation)과 측정식에서 추출된 추세, 계절성 등을 통해 추정되는 미래 예측값에 대한 상태식(state equation)에 따라 결정되는데 이를 상태공간모델(status space model)이라고 한다.13 상태공간모델에 의한 ETS 모델은 Error에 의한 가법 보정(A), 승법보정(M), 추세에 따른 가법 방법(A), 감쇄 가법 방법(Ad), 추세 없음(N), 계절성에 따른 계절성 없음(N), 가법 계절성(A), 승법 계절성(M)으로 구분된다. 이 8가지 방법을 활용하여 최종 ETS 모델을 결정할 수 있는데 모든 조합이 모델이 되지는 않는다. forecast의 ets() 함수에는 상태공간모델을 지정할 수 있지만 ets() 함수에서 자동적으로 선정해준다. ets 모델을 autoplot에 적용시키면 각각의 성분별로 plot을 확인할 수 있다. ets(students.total.ts[,1]) ### ETS(A,Ad,N)로 선정 error는 A, trend는 Ad, season은 N ## ETS(A,Ad,N) ## ## Call: ## ets(y = students.total.ts[, 1]) ## ## Smoothing parameters: ## alpha = 0.8929 ## beta = 0.8929 ## phi = 0.9401 ## ## Initial states: ## l = 8930071.6714 ## b = -36934.5936 ## ## sigma: 74403.08 ## ## AIC AICc BIC ## 567.8898 573.4898 574.4361 ets(students.total.ts[,1]) %&gt;% autoplot() ### 전체 학생수에 대한 ets 모델 ploting ets(students.total.ts[,1]) %&gt;% forecast() %&gt;% autoplot() ### 전체 학생수에 대한 예측치 ploting ets(employees.ts[,2]) ### ETS(M,Ad,A)로 모델 선정 ## ETS(M,Ad,A) ## ## Call: ## ets(y = employees.ts[, 2]) ## ## Smoothing parameters: ## alpha = 0.9989 ## beta = 1e-04 ## gamma = 2e-04 ## phi = 0.9744 ## ## Initial states: ## l = 25055.6086 ## b = 53.1073 ## s = -222.3076 255.8486 261.7129 227.3178 163.5351 319.1916 ## 274.8844 226.215 -5.605 -294.4144 -588.041 -618.3374 ## ## sigma: 0.0045 ## ## AIC AICc BIC ## 1372.968 1381.851 1419.126 ets(employees.ts[,2]) %&gt;% autoplot() ets(employees.ts[,2]) %&gt;% forecast() %&gt;% autoplot() ets(wide.covid19.by.age.ts[,2]) ### ETS(A,N,N)로 모델 선정 ## ETS(A,N,N) ## ## Call: ## ets(y = wide.covid19.by.age.ts[, 2]) ## ## Smoothing parameters: ## alpha = 0.3314 ## ## Initial states: ## l = 1.2458 ## ## sigma: 5.2609 ## ## AIC AICc BIC ## 2731.370 2731.450 2742.501 ets(wide.covid19.by.age.ts[,2]) %&gt;% autoplot() ets(wide.covid19.by.age.ts[,2]) %&gt;% forecast() %&gt;% autoplot() https://otexts.com/fppkr/expsmooth.html https://otexts.com/fpp2/ses.html https://m.blog.naver.com/PostView.nhn?blogId=sigmagil&amp;logNo=221502514892&amp;proxyReferer=https:%2F%2Fwww.google.com%2F https://otexts.com/fppkr/ets.html "],["arima-모델.html", "6.4 ARIMA 모델", " 6.4 ARIMA 모델 앞서 설명한 지수평활 모델은 이번 절에서 설명하는 ARIMA 모델과 함께 시계열 예측 모델에서 가장 많이 사용되어온 모델이다. ARIMA는 AutoRegression Integrated Moving Average의 앞글자만 딴 이름이다. 지수 평활 모델은 주어진 데이터에서 추세와 계절성을 계량화한 모델이지만 ARIMA 모델은 이름에서도 나타나듯이 자기상관과 이동평균을 수식화한 모델이다. 사실 ARIMA 모델은 ARMA(AutoRegression Moving Average)을 기반으로 한 모델이지만 ARMA 모델은 정상성 시계열에 한한 모델이기 때문에 비정상성 데이터를 정상화하는 단계를 포함하여 ARIMA 모델로 구현된다.14 ARIMA 모델은 arima(p, d, q)로 표현되는데 p는 AR모델의 차수, d는 비정상성 시계열을 정상성 시계열로 변환하기 위한 차분 차수, q는 이동평균 차수를 의미한다. 결국 ARIMA(p, d, q)모델은 데이터를 정상성 시계열로 만들기 위해 d번 차분한 데이터에 ARMA(p, q)모델을 적용하는 것과 동일하다. 6.4.1 자기회귀모델(AutoRegressive Model) 머신러닝을 공부할 때 가장 먼저 배우는 모델이 선형회귀모델이다. 선형회귀모델은 독립변수와 종속변수를 분리하고 두 변수간의 상관관계를 분석하여 모델링을 한다 . 앞선 장에서 시계열 선형회귀분석을 설명하였는데 이때의 독립변수는 시간이었고 종속변수는 예측을 원하는 변수를 설정하였다. 그러나 AR모델은 독립변수고 종속변수가 모두 하나의 변수를 사용한다는 점에서 일반 회귀모델과 다르다. 과거의 자기자신의 데이터와 현재 데이터간의 상관관계를 분석하여 회귀모델을 세우는 것이 AR 모델이다. AR(p) 모델은 자기 상관관계가 lag p까지 영향을 미치는 모델이다. AR(1)은 자신의 데이터에 lag 1을 취한 데이터간의 회귀분석 모델이고 AR(2)는 자신의 데이터에 lag 1과 lag 2 데이터 간의 다중 회귀분석 모델이다. 따라서 AR(1) 모델은 회귀계수가 하나이고 AR(2) 모델은 회귀계수가 2개이므로 AR(p) 모델은 회귀계수가 p개 존재하게 된다. 다음의 예는 자기회귀모델을 생성하고 ploting하는 예를 보이고 있다. arima.sim() 함수는 ARIMA 모형에 따른 랜덤 데이터를 생성하는 함수이다. library(tseries) ## Warning: package &#39;tseries&#39; was built under R version 4.0.3 set.seed(345) arima100 &lt;- arima.sim(model = list(order = c(1, 0, 0), ar = 0.9), n = 200) ### ARIMA(1,0,0)에 AR(1)의 회귀계수가 0.9인 데이터 200개 생성 arima100 %&gt;% autoplot(main = &#39;AR(1) model&#39;) kpss.test(arima100) ### kpss 테스트를 통해 생성된 데이터가 정상성인지 테스트 - 0.05보다 크므로 정상성, 차분 불필요 ## Warning in kpss.test(arima100): p-value greater than printed p-value ## ## KPSS Test for Level Stationarity ## ## data: arima100 ## KPSS Level = 0.26838, Truncation lag parameter = 4, p-value = 0.1 ndiffs(arima100, test = &#39;kpss&#39;) ### 비정상 제거를 위한 차분수 - 0이 나오므로 차분 불필요 ## [1] 0 set.seed(345) arima110 &lt;- arima.sim(model = list(order = c(1, 1, 0), ar = 0.9), n = 200) arima110 %&gt;% autoplot(main = &#39;AR(1), 차분 1 model&#39;) kpss.test(arima110) ### kpss 테스트를 통해 생성된 데이터가 정상성인지 테스트 - 0.05보다 작으므로 정상성, 차분 필요 ## Warning in kpss.test(arima110): p-value smaller than printed p-value ## ## KPSS Test for Level Stationarity ## ## data: arima110 ## KPSS Level = 3.2912, Truncation lag parameter = 4, p-value = 0.01 ndiffs(arima110, test = &#39;kpss&#39;) ### 비정상성을 제거하기 위해 필요한 차분수 ## [1] 1 ARIMA(1, 0, 0)의 ACF, PACF plot은 다음과 같이 나타난다. acf plot을 보면 자기 상관성이 전반적으로 높고 천천히 감소하는 형태(Tail off)를 보인다. 그리고 pacf plot은 lag 1에서 매우 높지만 2에서부터는 끊어진다.(cut off) ARIMA(1, 1, 0)도 유사한 형태를 나타낸다. arima100 %&gt;% ggtsdisplay() 6.4.2 이동평균 모델(Moving Average Model) 이동 평균을 가장 많이 볼 수 있는 응용은 주식 plot이다. 주식 plot에서는 3일 이동평균, 5일 이동평균, 10일 이동평균등 다양한 이동평균을 통해 해당 주식 주가의 전반적인 흐름을 파악한다. 보통 우리는 평균을 데이터의 전체합을 데이터의 갯수로 나누어 산출한다. 데이터의 전체적 흐름을 평균이라는 하나의 레벨로 표현하게 되는데 흔히 시계열 데이터에서도 마찬가지로 산출한다. 그러나 이 경우 오래된 데이터 일수록 최근 추세나 경향이 미치는 영향보다는 과거 추세가 강하게 들어가게 되므로 현재 데이터 추세나 경향에 둔감해지는 경향이 있다. 따라서 이동 평균은 최근의 데이터들에 대한 평균치를 산출함으로써 과거보다는 현재에 흐름에 맞는 평균을 산출할 수 있다는 장점이 있다. 이 이동 평균을 연속적으로 ploting 하면 데이터의 추세과 경향을 파악할 수 있다. 이동 평균 모델은 MA(q)로 표현하는데 q는 이동평균을 산출하는 차수를 의미한다. q가 1인 경우는 기준 시점값과 바로 이전값의 평균, 2인경우는 기준 시점값과 이전, 차이전 값과의 평균을 의미한다. 기준 시점값은 시계열 적으로 과거값으로 하나씩 이동할 수 있고 시계열 초기값까지 이동하면 이동평균 산출은 끝난다. 이동 평균 모델에서 하나 주의해야 할점은 이동 평균 모델의 계수를 적용하는 독립 변수가 오차항이라는 점이다. 앞선 자기회귀모델에서는 자기회귀계수를 자기자신의 lag 차수값에 적용하였지만 이동 평균 모델은 이동평균 계수를 오차항에 적용시킨다. (이해가 어렵지만 원리를 알고싶다면 참고문헌15을 참조하라) set.seed(345) arima001 &lt;- arima.sim(model = list(order = c(0, 0, 1), ma = 0.9), n = 200) ### ARIMA(1,0,0)에 AR(1)의 회귀계수가 0.9인 데이터 200개 생성 arima001 %&gt;% autoplot(main = &#39;MA(1) model&#39;) arima001 %&gt;% ggtsdisplay() kpss.test(arima001) ### kpss 테스트를 통해 생성된 데이터가 정상성인지 테스트 - 0.05보다 크므로 정상성, 차분 불필요 ## Warning in kpss.test(arima001): p-value greater than printed p-value ## ## KPSS Test for Level Stationarity ## ## data: arima001 ## KPSS Level = 0.090581, Truncation lag parameter = 4, p-value = 0.1 ndiffs(arima001, test = &#39;kpss&#39;) ### 비정상 제거를 위한 차분수 - 0이 나오므로 차분 불필요 ## [1] 0 set.seed(345) arima011 &lt;- arima.sim(model = list(order = c(0, 1, 1), ma = 0.9), n = 200) arima011 %&gt;% autoplot(main = &#39;MA(1), 차분 1 model&#39;) kpss.test(arima011) ### kpss 테스트를 통해 생성된 데이터가 정상성인지 테스트 - 0.05보다 작으므로 정상성, 차분 필요 ## Warning in kpss.test(arima011): p-value smaller than printed p-value ## ## KPSS Test for Level Stationarity ## ## data: arima011 ## KPSS Level = 3.5785, Truncation lag parameter = 4, p-value = 0.01 ndiffs(arima011, test = &#39;kpss&#39;) ### 비정상성을 제거하기 위해 필요한 차분수 ## [1] 1 ARIMA(0, 0, 1)의 ACF, PACF plot은 다음과 같이 나타난다. AR(1)모델의 acf는 점차 감소(tail off)하였고 pacf는 1에서 절단(cut off)되었지만 MA(1)모델에서는 acf plot이 1에서 절단(cut off)되고 pacf plot은 +와 -를 반복하지만 전반적으로 감소(tail off)하고 있다. arima001 %&gt;% ggtsdisplay() 6.4.3 ARIMA 모델 결정 ARIMA 모델을 사용하기 위해서는 p, d, q의 차수를 결정하는 것이 매우 중요하다. 차수를 결정하는 방법은 앞서 설명한 acf, pacf를 보고 판단할 수 있는데 forecast 패키지의 auto.arima() 함수에서는 자동으로 p, d, q의 차수를 결정해주기도 한다. 하지만 ARIMA 모델의 전반적인 동작을 이해하기 위해서는 acf와 pacf를 확인하여 모델을 결정하는 방법을 알아둘 필요가 있다. 앞의 예제에서 AR(1)과 MA(1)의 ACF와 PACF plot을 보았는데 두 경우가 비슷하지만 다른 특성이 있다. AR(1) 모델의 경우는 ACF plot이 점차 감소(tail off)하고 PACF plot의 절단(cut off) 차수가 1이었다. 반면 MA(1)의 경우는 ACF plot의 절단(cut off) 차수가 1이었고 PACF plot이 점차 감소(tail off)하였다. 위의 예제에서 보듯이 AR모델은 ACF plot이 점차 감소하며 PACF plot의 절단 차수가 p값을 의미한다. 반면 MA 모델은 PACF plot이 점차 감소하며 ACF plot의 절단차수가 q값을 의미한다. 이 과정에서 비정상성 시계열을 정상성 시계열로 만들기 위해 차분을 적용하는데 차분의 적용차수가 d값을 의미한다. 만약 AR과 MA가 동시에 나타나는 모델의 경우는 다음의 예에서 보듯이 ACF와 PACF가 모두 점차 감소하는 형태를 보인다. 반면 아래의 예제와 같이 p와 q가 모두 0보다 큰 경우는 ACF와 PACF plot으로 모델을 결정하는 것이 적절하지 않을 수 있다.16 이 경우에는 먼저 차분을 통해 정상성 시계열로 만든 후 ACF와 PACF를 다시 확인해봐야 하고 이 경우에도 적절한 차수를 찾기 어렵다면 여러가지 경우수를 설정하고 AIC, BIC, RMSE 등의 성능 분석 수치를 통해 가장 좋은 모델을 선정해야 한다. 이와 관련된 내용은 다음 장에서 다루겠다. set.seed(345) arima101 &lt;- arima.sim(model = list(order = c(1, 0, 1), ar = 0.9, ma = 0.9), n = 200) ### ARIMA(1,0,0)에 AR(1)의 회귀계수가 0.9인 데이터 200개 생성 arima101 %&gt;% autoplot(main = &#39;AR(1), MA(1) model&#39;) arima101 %&gt;% ggtsdisplay() ARIMA 모델을 학생수 시계열 데이터, 취업자수 시계열 데이터, 코로나 확진자 시계열 데이터에 적용해보면 다음과 같다. 앞서 설명한 바와 같이 forecast 패키지에서는 ARIMA모델을 자동으로 결정해주는 함수인 auto.arima()를 제공한다. 학생수 데이터를 ARIMA 모델에 적용하면 ACF와 PACF로 비교적 확실하게 확인이 가능한 모델을 선정할 수 있다. auto.arima(students.total.ts[,1]) ### 학생수의 ARIMA모형은 ARIMA(1, 2, 0)으로 선정됨 ## Series: students.total.ts[, 1] ## ARIMA(1,2,0) ## ## Coefficients: ## ar1 ## 0.3861 ## s.e. 0.2075 ## ## sigma^2 estimated as 1.174e+09: log likelihood=-236.71 ## AIC=477.42 AICc=478.12 BIC=479.41 students.total.ts[,1] %&gt;% ggtsdisplay() ### ACF가 tail off이고 PACF가 1에서 cut off 이므로 ARMA(1,0)모델 kpss.test(students.total.ts[,1]) ### kpss 테스트를 통해 생성된 데이터가 정상성인지 테스트 - 0.05보다 작으므로 정상성, 차분 필요 ## Warning in kpss.test(students.total.ts[, 1]): p-value smaller than printed p- ## value ## ## KPSS Test for Level Stationarity ## ## data: students.total.ts[, 1] ## KPSS Level = 0.7939, Truncation lag parameter = 2, p-value = 0.01 ndiffs(students.total.ts[,1], test = &#39;kpss&#39;) ### 비정상성을 제거하기 위해 필요한 차분수가 2이므로 최종 모델은 ARIMA(1, 2, 0) ## [1] 2 auto.arima(students.total.ts[,1]) %&gt;% forecast() %&gt;% autoplot() 전체 취업자 수는 계절성을 지니기 때문에 다음의 절에서 설명한다. 교육서비스업 취업자는 다음과 같이 ARIMA 모델이 결정된다. auto.arima(employees.ts[, 3]) ### 교육서비스업 취업자수의 ARIMA모형은 ARIMA(0, 1, 0)으로 선정됨 ## Series: employees.ts[, 3] ## ARIMA(0,1,0) ## ## sigma^2 estimated as 508.9: log likelihood=-430.83 ## AIC=863.65 AICc=863.7 BIC=866.21 kpss.test(employees.ts[, 3]) ### kpss 테스트를 통해 생성된 데이터가 정상성인지 테스트 - 0.05보다 작으므로 비정상성, 차분 필요 ## ## KPSS Test for Level Stationarity ## ## data: employees.ts[, 3] ## KPSS Level = 0.66909, Truncation lag parameter = 3, p-value = 0.01636 ndiffs(employees.ts[, 3], test = &#39;kpss&#39;) ### 비정상성을 제거하기 위해 필요한 차분수가 1 ## [1] 1 diff(employees.ts[, 3]) %&gt;% ggtsdisplay() ### 1차 차분을 해본 결과 ACF, PACF 모두 절단(Cut off)이므로 ARMA(0,0) auto.arima(employees.ts[, 3]) %&gt;% forecast() %&gt;% autoplot() ### ARIMA(0,1,0)은 랜덤 워크 모델 코로나 확진자 데이터의 자동 ARIMA 모형은 (2, 1, 1)로 나타난다. kpss.test와 ndiffs를 통해 차분이 1인 경우 정상성이 되는 것을 확인할 수 있으나 p, q값이 모두 0보다 큰 수이기 때문에 ACF와 PACF plot으로 차수를 결정하는 것이 적절하지 않다. auto.arima(wide.covid19.by.age.ts[,2]) ### 교육서비스업 취업자수의 ARIMA모형은 ARIMA(0, 1, 0)으로 선정됨 ## Series: wide.covid19.by.age.ts[, 2] ## ARIMA(2,1,1) ## ## Coefficients: ## ar1 ar2 ma1 ## 0.1126 -0.1775 -0.6535 ## s.e. 0.0868 0.0688 0.0726 ## ## sigma^2 estimated as 26.74: log likelihood=-920.47 ## AIC=1848.93 AICc=1849.07 BIC=1863.76 kpss.test(wide.covid19.by.age.ts[,2]) ### kpss 테스트를 통해 생성된 데이터가 정상성인지 테스트 - 0.05보다 작으므로 비정상성, 차분 필요 ## Warning in kpss.test(wide.covid19.by.age.ts[, 2]): p-value smaller than printed ## p-value ## ## KPSS Test for Level Stationarity ## ## data: wide.covid19.by.age.ts[, 2] ## KPSS Level = 3.2656, Truncation lag parameter = 5, p-value = 0.01 ndiffs(wide.covid19.by.age.ts[,2], test = &#39;kpss&#39;) ### 비정상성을 제거하기 위해 필요한 차분수가 1 ## [1] 1 diff(wide.covid19.by.age.ts[,2]) %&gt;% ggtsdisplay() ### 1차 차분을 해본 결과 ACF, PACF 모두 절단(Cut off)이므로 ARMA(0,0) 6.4.4 Seasonal ARIMA 모델 위에서 살펴본 모델은 비계절성 ARIMA 모델이었다. 계절성을 지니는 데이터는 비계절성 ARIMA 모델로는 적절히 모델링이 어렵기 때문에 계절성 ARIMA 모델에 적합시켜야 한다. 계절성 ARIMA는 비계절성 ARIMA의 p, d, q 차수 외에 계절성 차수인 P, D, Q와 관측주기 m을 추가적으로 결정해야 하고 ARIMA(p, d, q)(P, D, Q)m으로 표기한다. employees.ts[, 2] %&gt;% ggtsdisplay() ### 전체 취업자수는 ACF plot을 볼때 12주기마다 계절성이 있음. summary(auto.arima(employees.ts[, 2])) ### 학생수의 ARIMA모형은 ARIMA(0, 1, 0)(0, 1, 1)[12]으로 선정됨 ## Series: employees.ts[, 2] ## ARIMA(0,1,0)(0,1,1)[12] ## ## Coefficients: ## sma1 ## -0.4246 ## s.e. 0.1648 ## ## sigma^2 estimated as 15320: log likelihood=-518.14 ## AIC=1040.27 AICc=1040.42 BIC=1045.11 ## ## Training set error measures: ## ME RMSE MAE MPE MAPE MASE ## Training set -17.24831 114.3934 73.75538 -0.06622242 0.2787589 0.2327018 ## ACF1 ## Training set -0.01264952 employees.ts.seasadj &lt;- employees.ts[, 2] %&gt;% stl(s.window=&#39;periodic&#39;) %&gt;% seasadj() ### 계절성을 제외 employees.ts.seasadj %&gt;% ggtsdisplay() ### 계절성을 제외한 데이터는 비정상성 있음 diff(employees.ts.seasadj) %&gt;% ggtsdisplay() ### 계절성 제외 데이터를 1차분한 결과는 ARMA(0,0) employees.ts[, 2] %&gt;% diff(lag =12) %&gt;% ggtsdisplay() ### 계절성이 있기 때문에 계절성(12)로 차분 데이터를 구해 계절성을 점검 employees.ts[, 2] %&gt;% diff(lag =12) %&gt;% kpss.test() ###계절성 차분 데이터가 비정상성 ## Warning in kpss.test(.): p-value smaller than printed p-value ## ## KPSS Test for Level Stationarity ## ## data: . ## KPSS Level = 1.0661, Truncation lag parameter = 3, p-value = 0.01 employees.ts[, 2] %&gt;% diff(lag =12) %&gt;% ndiffs() ### 계절성 차분 데이터의 차분 수를 구함 ## [1] 1 employees.ts[, 2] %&gt;% diff(lag =12) %&gt;% diff() %&gt;% kpss.test() ### 계절성 차분 데이터의 1차 차분 데이터는 정상성 ## Warning in kpss.test(.): p-value greater than printed p-value ## ## KPSS Test for Level Stationarity ## ## data: . ## KPSS Level = 0.11032, Truncation lag parameter = 3, p-value = 0.1 employees.ts[, 2] %&gt;% diff(lag =12) %&gt;% diff() %&gt;% ggtsdisplay() ### 계절성 차분 데이터의 ACF와 PACF를 확인하면 ARMA(0,0) arima010010 &lt;- arima(employees.ts[, 2], order = c(0,1,0), seasonal = c(0,1,0)) arima010011 &lt;- arima(employees.ts[, 2], order = c(0,1,0), seasonal = c(0,1,1)) summary(arima010010) ### 육안으로 구한 ARIMA(0,1,0)(0,1,0)[12]모델의 성능 치수 ## ## Call: ## arima(x = employees.ts[, 2], order = c(0, 1, 0), seasonal = c(0, 1, 0)) ## ## ## sigma^2 estimated as 16703: log likelihood = -521.29, aic = 1044.58 ## ## Training set error measures: ## ME RMSE MAE MPE MAPE MASE ## Training set -15.05233 120.5067 78.00443 -0.05780757 0.2945335 0.4009317 ## ACF1 ## Training set -0.01939813 summary(arima010011) ### 육안으로 구한 ARIMA(0,1,0)(0,1,0)[12]모델의 성능 치수 ## ## Call: ## arima(x = employees.ts[, 2], order = c(0, 1, 0), seasonal = c(0, 1, 1)) ## ## Coefficients: ## sma1 ## -0.4246 ## s.e. 0.1648 ## ## sigma^2 estimated as 15042: log likelihood = -518.14, aic = 1040.27 ## ## Training set error measures: ## ME RMSE MAE MPE MAPE MASE ## Training set -17.24831 114.3934 73.75538 -0.06622242 0.2787589 0.3790922 ## ACF1 ## Training set -0.01264952 forecast010010 &lt;- arima010010 %&gt;% forecast() forecast010011 &lt;- arima010011 %&gt;% forecast() autoplot(employees.ts[, 2]) + autolayer(forecast010011, PI = F, series = &#39;010011&#39;) + autolayer(forecast010010, PI = F, series = &#39;010010&#39;) 위의 예제에서 육안으로 확인한 ARIMA(0,1,0)(0,1,0)[12]모델의 RMSE값은 120.50과 auto.arima()함수를 통한 ARIMA(0,1,0)(0,1,1)[12]모델의 RMSE값은 114.39이다. 일반적으로 RMSE값이 작은 모델이 성능이 좋은 모델이므로 ARIMA(0,1,0)(0,1,1)모델이 보다 우수한 것으로 볼 수 있다. 이와 같이 육안으로 확인한 ARIMA모델은 불완전하다. 따라서 육안으로 확인하거나 auto.arima 모델의 p, q값의 주위 모델을 반드시 확인하여 성능 수치가 더 우수한 모델을 찾는 과정을 거쳐야 한다. https://icim.nims.re.kr/post/easyMath/68 https://otexts.com/fppkr/MA.html https://otexts.com/fpp2/non-seasonal-arima.html "],["tbats-모델.html", "6.5 TBATs 모델", " 6.5 TBATs 모델 앞선 ETS 모델과 ARIMA 모델은 계절성을 처리할 수 있는 방법을 제공하지만 문제는 다중 계절성을 지는 경우이다. 예를 들어 시간별 데이터는 하루내에서도 계절성을 가질 수 있고 주간적으로도 계절성을 가질 수 있으며 월간적으로, 연간적으로도 계절성을 가질 수 있다. ETS 모델과 ARIMA 모델은 연간(frequency = 1), 분기간(frequency = 4), 월간(frequency = 12) 까지의 계절성을 지원하고 주간(frequency = 52) 이상의 계절성을 지원하지 못한다. 또한 계절성이 동적으로 변동되는 경우는 ETS, ARIMA 모델이 지원하지 못한다. 따라서 이렇게 긴 주기의 계절성을 찾아내는 모델이나 변동성을 지니는 계절성 데이터에 대한 모델을 구축해야 할 때 사용하는 모델이 tBats모델이다. tBats 모델은 Box-Cox 변환17, ARMA 에러, 추세와 계절성 컴포넌트를 사용한 지수평활 상태공간 모델이다.18 코로나 확진자 데이터의 경우 2020년 9월 경 한차례 증가가 있었다가 2020년 12월 또 한차례 증가가 발생했다. 이것을 이중 계절성으로 파악한다면 ETS나 ARIMA모형으로는 모델링이 불가하다. 하지만 tBats 모델은 다음과 같이 모델이 가능하다. wide.covid19.by.age.ts[,2] %&gt;% tbats() %&gt;% forecast() %&gt;% autoplot() ### 코로나 확진자 데이터에 대한 tBats 모델 https://otexts.com/fpp3/ftransformations.html https://pkg.robjhyndman.com/forecast/reference/tbats.html "],["prophet-모델.html", "6.6 prophet 모델", " 6.6 prophet 모델 Prophet 모델은 페이스북에서 자사 데이터를 기반으로 개발한 시계열 모델로 prophet 패키지를 통해 R과 Python에서 사용할 수 있다. 이 모델은 연도별, 주별, 일별 계절성 및 휴일 효과에 적합한 비선형 추세에 알맞은 가법 모델을 통해 시계열 데이터를 예측한다. (무슨 말인지 몰라도 상관없다) 페이스북에서는 prophet 모델이 ‘빠르고 정확하다,’ ‘완전 자동화되어 있다,’ ‘예측을 조절할수 있다,’ ’R과 Python에서 사용할 수 있다’고 홍보하고 있다.19 하지만 예측 방법론을 페이스북에서 공개하지 않는다. 이 부분은 시계열 분석 방법론을 연구하는 연구자들에게는 단점이지만 시계열 분석을 실무에서 사용하는 사람들은 오히려 장점이 될 수 있다.(머리아프게 공부하지 않고 그냥 쓰면 되니까) prophet 모델은 시계열 데이터를 추세(t), 계절성(s), 휴일(h), 오차의 특성(feature)로 분리한다. 추세(t)는 반복이 되지 않는 추세, 계절성(s)은 계절성과 같은 반복적인 변화, 휴일(h)은 공휴일과 같이 달력상에서의 불규칙한 특성(feature)을 말한다. 여기에 오차가 더해지는데 이 오차는 특정 모델로 적용이 어려운 정규분포를 따르는 오차라고 가정한다.20 prophet 모델은 ARIMA 모델 같이 시계열 데이터의 구조를 통해 관계를 분석하는 모델과 달리 데이터 구조가 어떻던 데이터에 적합한 커브를 그리는데 목표를 두고 있다. 이렇게 함으로써 여러 주기를 가지는 계절성에 쉽게 사용할 수 있고, ARIMA 모델과 같이 일정한 데이터 주기를 맞추기 위해 데이터를 채워넣는 작업을 피할수 있고, 매우 빠르게 다양한 모델 스펙을 경험할 수 있고, 에 적합시킬 수 있으며, 회귀에 경험이 많은 분석가들의 개념에 쉽게 이해될 수 있는 형태의 매개변수들을 사용한다는 장점이 있다고 한다. prophet 모델을 적용하기 위해서는 prophet() 함수를 사용한다. prophet() 함수는 data.frame 객체를 사용하는데 data.frame에는 컬럼 이름이 ’ds’와 ’y’으로 설정된 두개의 데이터 필드가 필요하다. ds 컬럼은 date 데이터 타입이어야 하며 y 컬럼은 수치 컬럼이어야 한다. library(prophet) students.prophet &lt;- data.frame(ds = as.Date(paste0(students.total$연도, &#39;-01-01&#39;)), y = students.total$학생수계) model.prophet.students &lt;- prophet(students.prophet) future.students &lt;- make_future_dataframe(model.prophet.students, periods = 10, freq = &#39;year&#39;) forecast.students &lt;- predict(model.prophet.students, future.students) plot(model.prophet.students, forecast.students) + ggrepel::geom_text_repel(aes(label = scales::number(y, big.mark = &#39;,&#39;, accuracy = 1)), vjust = 1, size = 3) + labs(title = &#39;prophet model&#39;, x = &#39;연도&#39;, y = &#39;학생수&#39;) + scale_y_continuous(labels = scales::number_format(big.mark = &#39;,&#39;)) prophet_plot_components(model.prophet.students, forecast.students) employees.prophet &lt;- data.frame(ds = employees[,1], y = employees[,2]) model.prophet.employees &lt;- prophet(employees.prophet) future.employees &lt;- make_future_dataframe(model.prophet.employees, periods = 10, freq = &#39;month&#39;) forecast.employees &lt;- predict(model.prophet.employees, future.employees) plot(model.prophet.employees, forecast.employees) + labs(title = &#39;월별 전체 취업자수 추세(prophet model)&#39;, x = &#39;연월&#39;, y = &#39;취업자수&#39;) + scale_y_continuous(labels = scales::number_format(big.mark = &#39;,&#39;)) prophet_plot_components(model.prophet.employees, forecast.employees) covid.prophet &lt;- data.frame(ds = wide.covid19.by.age$date, y = wide.covid19.by.age$`0-9세`) model.prophet.covid &lt;- prophet(covid.prophet, yearly.seasonality=TRUE, daily.seasonality=TRUE, weekly.seasonality=TRUE) future.covid &lt;- make_future_dataframe(model.prophet.covid, periods = 100, freq = &#39;day&#39;) tail(future.covid, 10) ## ds ## 393 2021-05-11 ## 394 2021-05-12 ## 395 2021-05-13 ## 396 2021-05-14 ## 397 2021-05-15 ## 398 2021-05-16 ## 399 2021-05-17 ## 400 2021-05-18 ## 401 2021-05-19 ## 402 2021-05-20 forecast.covid &lt;- predict(model.prophet.covid, future.covid) plot(model.prophet.covid, forecast.covid) + labs(title = &#39;일별 코로나 확진자수 추세(0-9세, prophet model)&#39;, x = &#39;연월&#39;, y = &#39;확진자수&#39;) + scale_y_continuous(labels = scales::number_format(big.mark = &#39;,&#39;)) prophet_plot_components(model.prophet.covid, forecast.covid) https://facebook.github.io/prophet/ https://peerj.com/preprints/3190.pdf "],["neural-network-모델.html", "6.7 Neural Network 모델", " 6.7 Neural Network 모델 시계열 데이터에 대한 신경망 모델은 forecast 패키지에서 제공하는 nnetar() 함수를 사용하여 구축할 수 있다. nnetar()로 구축되는 모델은 싱글 히든 레이어을 사용한 신경망 모델이다. 일반적으로 딥러닝은 히든 레이어를 3개 이상 구축한 경우를 말하기 때문에 딥러닝이라고까지는 언급할 수 없으나 시계열 데이터를 신경망 이론에 적합하여 만들수 있는 모델이라는데 의미가 있다. nnetar() 함수에 구축된 모델은 계절성이 없는 경우는 NNAR(p, k)이며 계절성이 없는 경우는 NNAR(p, P, k)[m]으로 표현된다. p값은 히든 레이어에서 예측값을 산출하기 위해 사용하는 과거 데이터의 갯수이고 k값은 히든 레이어에 존재하는 신경세포의 갯수이다. P는 계절성에 대한 lag 값이다. nnetar() 함수는 p와 P 값을 자동으로 산정하고 k 값은 (p + P +1)/2 값으로 설정한다.21 NNAR모델의 단점중에 하나는 예측구간의 계산이 원활하지 못하다는 점이다. forecast() 함수에서 ‘PI = TRUE’ 매개변수를 설정하면 예측구간이 계산되지만 계산량이 많아 시간이 걸린다. ### 학생수에 대한 NNAR 모델은 NNAR(1, 1)모델 students.total.ts[,1] %&gt;% nnetar() %&gt;% forecast(PI = TRUE) %&gt;% autoplot() ### 전체 취업자수에 대한 모델은 NNAR(1, 1, 2)[12] 모델 employees.ts[, 2] %&gt;% nnetar() %&gt;% forecast(PI = TRUE) %&gt;% autoplot() ### 코로나 확진자수에 대한 모델은 NNAR(22, 12) 모델(예측값을 위해 22개의 과거 데이터를 활용했고 히든레이어에 12개의 신경세포를 생성 ) wide.covid19.by.age.ts[,2] %&gt;% nnetar() %&gt;% forecast(h = 100, PI = TRUE) %&gt;% autoplot() ## Warning in nnetar(.): Series too short for seasonal lags https://otexts.com/fpp3/nnetar.html "]]
