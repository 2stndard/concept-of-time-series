```{r message=FALSE, warning=FALSE, include=FALSE}
library(dplyr)
library(xts)
students <- read.csv('./students.csv', skip = 16, header = TRUE, na = '-', strip.white = TRUE, stringsAsFactors = TRUE)
students[, 3:18] <- apply(students[, 3:18], 2, function(y) as.numeric(gsub(",", "", y)))
students.total.xts <- students %>% filter(지역규모 == '계') %>% select(-지역규모)
students.total.xts <- as.xts(students.total.xts, order.by = as.Date(paste0(students.total.xts[,1], '-01-01'), format = '%Y-%m-%d'))
library(timetk)
students.total.ts <- students %>% 
  filter(지역규모 == '계') %>% 
  select(3:18) %>%
  ts(start = c(1999), frequency = 1)
employees <- read.csv('./산업별_취업자_20210206234505.csv', header = TRUE, na = '-', strip.white = TRUE, stringsAsFactors = TRUE)
colnames(employees) <- c('time', 'total', 'employees.edu')
employees.ts <- ts(employees, start = c(2013, 01), frequency = 12)
```

# 시계열 forecasting Part II - 시계열 모델링 알고리즘

**A future like the past:**

It is obvious from this description that all statistical techniques are based on the assumption that existing patterns will continue into the future. This assumption is more likely to be correct over the short term than it is over the long term, and for this reason these techniques provide us with reasonably accurate forecasts for the immediate future but do quite poorly further into the future (unless the data patterns are extraordinarily stable).

For this same reason, these techniques ordinarily *cannot* predict when the rate of growth in a trend will change significantly---for example, when a period of slow growth in sales will suddenly change to a period of rapid decay.

Such points are called *turning points*. They are naturally of the greatest consequence to the manager, and, as we shall see, the forecaster must use different tools from pure statistical techniques to predict when they will occur.[^forecasting-ii-1]

[^forecasting-ii-1]: <https://hbr.org/1971/07/how-to-choose-the-right-forecasting-technique>

본 장에서는 세가지 데이터를 이용하여 알고리즘을 적용한다. 첫번째 데이터는 교육통계홈페이지에서 다운로드 받은 students 데이터로 1999년부터 2020년까지의 전국 학생수 데이터이고, 두번째 데이터는 KOSIS에서 다운로드 받은 경제활동인구조사 데이터 중 전체 취업자 데이터로 2003.1월부터 2020년 12월까지의 데이터, 세번째 데이터는 두번째 데이터와 같은 조사에서 얻어진 데이터로 교육서비스업 데이터이다. 첫번째 데이터는 년별 데이터이기 때문에 추세는 보이지만 계절성은 없고 두번째와 세번째 데이터는 월별 데이터이지만 두번째 데이터는 세번째 데이터보다 계절성이 더 짙은 데이터이다.

## Simple 모델링 알고리즘

simple 모델링 알고리즘은 Rob Hyndman의 'Forecasting : principals and practice'에서 그룹핑한 알고리즘과 명칭을 사용했다.[^forecasting-ii-2] 따라서 Simple 모델링이라는 명칭과 알고리즘들은 일반적인 분류는 아닐수 있다.

[^forecasting-ii-2]: <https://otexts.com/fpp2/>

사실 Simple 알고리즘을 보면 '이게 무슨 예측이야?'라고 생각할 수도 있다. 하지만 우리가 매우 쉽게 접하고 사용하는 '평균'이라는 것도 통계적 모델링에 하나라고 보면 Simple 알고리즘도 충분히 시계열 데이터의 모델링으로 볼 수도 있다.

Simple 모델링의 대부분은 매우 간단한 개념을 함수화 하여 미래 예측에 활용할 수 있도록 제작되었다. Simple 모델링에서 제시하는 대부분의 함수는 forecast 패키지(앞에서 설명한 Rob Hyndman이 주도하여 제작된 패키지임)에서 제공하는 함수를 위주로 설명하고자 한다. [^forecasting-ii-3]

[^forecasting-ii-3]: <https://otexts.com/fpp2/simple-methods.html>

-   평균 모델(forecast::meanf)

평균 모델은 우리가 흔히 알고 있는 평균이 앞으로의 미래에도 적용하는 방법이다. forecast 패키지에서는 meanf() 함수를 통해 시계열 데이터의 평균을 활용한 미래 예측값을 반환하는 함수를 제공한다. 이 함수에서는 평균 모델에 의한 점 예측값(Point Forecast)뿐 아니라 예측구간 80%와 95%를 산출해 준다. 매개변수를 설정함으로써 이 예측구간을 Bootstrap 방법을 통해 산출할 수도 있다. meanf() 함수의 입력 데이터는 숫자 벡터나 ts 클래스 객체를 사용한다. meanf()함수의 결과를 plot하기 위해서는 autoplot() 함수에 meanf() 결과 객체를 전달하여 ploting 할 수 있다.

```{r meanf, warning=FALSE, message=FALSE}
library(forecast)
summary(meanf(students.total.ts[,1]))
autoplot(meanf(students.total.ts[,1]))
autoplot(meanf(students.total.ts[,1], bootstrap = TRUE))
autoplot(meanf(employees.ts[,2]))
autoplot(meanf(employees.ts[,3]))
```

-   단순(Naive) 모델

단순(Naive) 모델은 시계열 측정값의 마지막 값이 지속될 것이라는 가정하에 향후 데이터값을 예측하는 모델이다. 이 모델은 경제 금융 시계열 모델에서 많이 사용된다. [^forecasting-ii-4] 앞선 평균 모델과 달리 Naive 모델의 예측구간은 예측 시간이 늘어날수록 범위가 늘어난다. 일반적으로 시계열 모델의 예측구간은 예측기간이 늘어날 수록 범위가 넓어지는 경향을 지닌다.

[^forecasting-ii-4]: <https://otexts.com/fpp2/simple-methods.html>

```{r naive}
summary(naive(students.total.ts[,1]))
autoplot(naive(students.total.ts[,1]))
summary(naive(employees.ts[,2]))
autoplot(naive(employees.ts[,2]))
summary(naive(employees.ts[,2]))
autoplot(naive(employees.ts[,3]))
```

-   계절성 단순(Seasonal Naive) 모델

계절성 단순(Seasonal Naive) 모델은 단순(Naive) 모델에서 계절성을 추가한 모델이다. 계절성(Seasonal Pattern)은 주기성(Cyclic Pattern)과 다르다. 계절성은 일정한 주기를 가지고 반복되는 패턴을 의미하지만 주기성은 패턴은 반복되지만 주기가 일정하지 않다는 점에서 다르다. 주기성의 주기는 일반적으로 2년보다 크기때문에 여러 연도에 걸쳐 나타나지만 계절성은 일반적으로 달력의 특성에 연관되어 주기를 갖는 경우가 일반적이다. [^forecasting-ii-5]

[^forecasting-ii-5]: <https://robjhyndman.com/hyndsight/cyclicts/>

```{r}
summary(snaive(students.total.ts[,1], 10))
autoplot(snaive(students.total.ts[,1], 10))
summary(snaive(employees.ts[,2], 10))
autoplot(snaive(employees.ts[,2], 10))
summary(snaive(employees.ts[,3], 10))
autoplot(snaive(employees.ts[,3], 10))
```

-   random work 모델

랜덤 워크는 시간적으로 다음값이 시간적으로 현재값의 영향을 받는다는 이론이다. 주식의 예에서 보면 내일의 종가는 오늘의 종가에 랜덤한 값이 더해지거나 빼져서 결정되는 것과 같은 이치이다. 랜덤 워크에는 어제값 이외에 의미있는 정보가 없기 때문에 예측이 복잡하지 않다[^forecasting-ii-6]. 앞에서 설명한 Naive 모델은 마지막 값이 지속되는 예측인데 이것이 결국 랜덤 워크와 동일한 결과를 가지게 된다. 랜덤 워크는 시간적으로 하나 앞선 값과 현재값을 뺀 차이값들은 백색잡음이 되어야한다는 조건을 만족해야한다. 랜덤 워크 모델은 드리프트가 없는 모델과 드리프트가 존재하는 모델의 두가지 종류가 있다. 드리프트가 존재하는 모델은 랜덤워크 모델을 기반으로 하지만 예측값이 시간의 흐름에 따라 증가하거나 감소하는 모델이다.

[^forecasting-ii-6]: <https://robjhyndman.com/files/solutions.pdf>

```{r}
summary(rwf(students.total.ts[,1]))
autoplot(rwf(students.total.ts[,1]))
summary(rwf(employees.ts[,2]))
autoplot(rwf(employees.ts[,2]))
summary(rwf(employees.ts[,2]))
autoplot(rwf(employees.ts[,3]))

summary(rwf(students.total.ts[,1], drift = TRUE))
autoplot(rwf(students.total.ts[,1], drift = TRUE))
summary(rwf(employees.ts[,2], drift = TRUE))
autoplot(rwf(employees.ts[,2], drift = TRUE))
summary(rwf(employees.ts[,2], drift = TRUE))
autoplot(rwf(employees.ts[,3], drift = TRUE))
```

위에서 설명한 모델들을 하나의 plot으로 그려보면 모델 간의 차이를 살펴볼 수 있다.

```{r simple_total}
autoplot(meanf(students.total.ts[,1], h = 10), PI = FALSE, series = 'Mean') + 
  autolayer(naive(students.total.ts[,1], h = 10), PI = FALSE, series = 'Naive') +
  autolayer(snaive(students.total.ts[,1], h = 10), PI = FALSE, series = 'Snaive') +
  autolayer(rwf(students.total.ts[,1], h = 10), PI = FALSE, series = 'RW') +
  autolayer(rwf(students.total.ts[,1], h = 10, drift = TRUE), PI = FALSE, series = 'RW with drift')

autoplot(meanf(employees.ts[,2], h = 10), PI = FALSE, series = 'Mean') + 
  autolayer(naive(employees.ts[,2], h = 10), PI = FALSE, series = 'Naive') +
  autolayer(snaive(employees.ts[,2], h = 10), PI = FALSE, series = 'Snaive') +
  autolayer(rwf(employees.ts[,2], h = 10), PI = FALSE, series = 'RW') +
  autolayer(rwf(employees.ts[,2], h = 10, drift = TRUE), PI = FALSE, series = 'RW with drift')

autoplot(meanf(employees.ts[,3], h = 10), PI = FALSE, series = 'Mean') + 
  autolayer(naive(employees.ts[,3], h = 10), PI = FALSE, series = 'Naive') +
  autolayer(snaive(employees.ts[,3], h = 10), PI = FALSE, series = 'Snaive') +
  autolayer(rwf(employees.ts[,3], h = 10), PI = FALSE, series = 'RW') +
  autolayer(rwf(employees.ts[,3], h = 10, drift = TRUE), PI = FALSE, series = 'RW with drift')
```

## Regression 모델

## Exponential Smoothing 모델

## ARIMA 모델

## TBAT 모델

## Neural Network 모델

## Bootstrapping과 Begging 모델
