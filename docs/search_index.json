[["시계열-데이터-handling.html", "Chapter 4 시계열 데이터 Handling", " Chapter 4 시계열 데이터 Handling 이 장에서는 시계열 데이터를 시간단위로 다루는 방법을 설명할 것이다. 우리는 시간 단위로 기록된 데이터를 항상 다루어왔다. 데이터의 월 평균, 데이터의 전월 대비 변동량 등을 산출하기 위해서는 데이터를 월 단위로 구분하여 평균을 구하거나 전월 데이터를 산출하여 당월 데이터와의 차이를 구하는 등의 작업을 해야한다. R에서 주로 사용하는 data.frame에서는 행렬 인덱스나 조건을 []를 이용하여 전달함으로써 데이터를 검색하고 일부 데이터를 subsetting하거나 dplyr 패키지에서 제공하는 select, filter, group_by, arrange, mutate 등의 함수를 많이 사용하여 작업을 수행할 수 있다. 물론 data.frame에 저장된 시계열 데이터는 dplyr에서 제공하는 함수를 사용할 수 있지만 ts나 xts의 시계열 class의 객체에 대해서는 적용이 되지 않는다. 또한 시계열 데이터는 타 데이터에는 없는 시간적 특성(예를 들어 1분은 60초, 국가마다 년, 월을 표현하하는 방식의 차이, Time Zone)이 있기 때문에 이를 잘 활용하기 위해서는 시계열 데이터의 핸들링 방법을 익혀둘 필요가 있다. 시간을 주로 다루는 ‘lubridate’ 패키지는 시간을 다루기 위한 많은 함수를 제공하는데 이 장에서는 시계열 데이터를 잘 활용하기 위해 lubridate 패키지를 활용하여 시간 인덱스를 다루는 방법에 대해 설명하고자 한다. "],["시계열-데이터-정보-다루기.html", "4.1 시계열 데이터 정보 다루기", " 4.1 시계열 데이터 정보 다루기 시계열 데이터는 년, 월, 일, 시, 분, 초, 타임존 등의 여러 데이터가 결합되어 생성된 시간을 인덱스로 사용하는 데이터이다. 그래서 시계열 데이터를 잘 활용하기 위해서는 시간 인덱스의 여러 요소들을 추출해내야 목적에 맞는 활용이 가능해진다. 함수명 설명 함수명 설명 함수명 설명 year() 연도 추출 hour() 시간 추출 week() 1월1일으로부터의 주수 month() 월 추출 minute() 분 추출 quater(), semester() 1월1일으로부터의 분기수, 반기수 day() 일 추출 second() 초 추출 am(), pm() 오전, 오후의 논리값 wday() 요일 추출 yday() 1월1일으로부터의 날수 leap_year() 윤년 여부의 논리값 library(lubridate) test.time.date &lt;- Sys.time() test.time.char &lt;- as.character(Sys.time()) test.time.xts &lt;- as.xts(Sys.time()) year(test.time.date) ## [1] 2021 month(test.time.char) ## [1] 2 day(test.time.xts) ## [1] 5 yday(test.time.date) ## [1] 36 qday(test.time.char) ## [1] 36 wday(test.time.xts, label = T, abbr = T) ## [1] 금 ## Levels: 일 &lt; 월 &lt; 화 &lt; 수 &lt; 목 &lt; 금 &lt; 토 hour(test.time.date) ## [1] 0 minute(test.time.char) ## [1] 3 second(test.time.xts) ## [1] 22.18109 week(test.time.date) ## [1] 6 quarter(test.time.char, with_year = T) ## [1] 2021.1 semester(test.time.xts, with_year = T) ## [1] 2021.1 am(test.time.date) ## [1] TRUE pm(test.time.char) ## [1] FALSE leap_year(test.time.date) ## [1] FALSE "],["시계열-데이터-연산.html", "4.2 시계열 데이터 연산", " 4.2 시계열 데이터 연산 시간의 연산은 일반적으로 오늘로부터 며칠후, 언제로부터 몇개월전 등과 같은 연산을 의미한다. lubridate 패키지에서는 시간의 연산을 위해 몇개의 함수를 제공하는데 다음과 같은 연산들을 지원한다. 다만 앞선 장에서는 ts 와 xts 클래스의 시계열 객체는 본 절에서 다루는 시계열 데이터 연산 중 일부가 지원되지 않기 때문에 llubridate 패키지에서 제공하는 data.frame 클래스의 시간 더하기/빼기 lubridate 패키지에서는 시간의 더하기나 빼기 연산을 지원한다. 일반적인 정수를 이용하여 더하거나 빼면 일을 기준으로 과거나 미래를 산출할 수 있고 lubridate에서 제공하는 years(), months(), days() 등의 함수를 이용하면 년단위, 월단위, 일단위의 연산도 가능하다. as.Date(&#39;2021-01-01&#39;) - as.Date(&#39;1980-01-01&#39;) # 1980년 1월 1일 이후 날짜 수 ## Time difference of 14976 days today &lt;- today() today + 100 # 오늘부터 100일 후 ## [1] &quot;2021-05-16&quot; today - months(2) # 오늘부터 2개월 전 ## [1] &quot;2020-12-05&quot; today - years(1) #오늘부터 1년전 ## [1] &quot;2020-02-05&quot; 시계열 데이터 기간 앞선 예에서 1980년 1월 1일부터 오늘까지는 14,976일로 계산되었다. 그러나 우리는 보통 몇년 몇월 몇일로 표현된다. lubridate에서는 이렇게 몇년 몇월 몇일로 변환하는 것을 interval()함수를 사용하여 계산한다. 하지만 바로 계산되는 것은 아니고 interval()함수에 의해 반환되는 값은 interval 클래스의 데이터값으로 시작점으로부터의 초를 기록한다. 이렇게 변환된 interval 객체를 올바르게 표현하기 위해서는 interval 객체를 period 나 duration 클래스 객체로 변환하여야 한다. interval 함수는 함수형태로 사용이 가능하고 %–% 연산자를 사용할 수도 있다. interval &lt;- interval(as.Date(&#39;1980-01-01&#39;), as.Date(&#39;2021-12-31&#39;)) as.period(interval) # 년월일 형태로 기간 반환 ## [1] &quot;41y 11m 30d 0H 0M 0S&quot; as.duration(interval) # 경과 초 형태로 기간 반환 ## [1] &quot;1325376000s (~42 years)&quot; interval &lt;- &#39;1980-01-01&#39; %--% &#39;2021-12-31&#39; as.period(interval) # 년월일 형태로 기간 반환 ## [1] &quot;41y 11m 30d 0H 0M 0S&quot; 위의 예제와 같이 internal은 시간 범위(time spans)를 표현하는데 lubridate는 period와 duration의 두가지 시간 범위(time spans) 클래스를 제공한다. lubridate에서 제공하는 period 함수는 복수형태(years(), months() 등)로 표현된 함수를 사용하고 duration 함수는 함수의 접두어를 ’d’를 사용하여 표현한다. 두가지 형태의 internal을 제공하는 이유는 시간의 타임라인은 숫자의 라인과 동일하지 않기 때문이다. duration은 항상 수학적으로 동일한 결과를 제공한다. 하지만 period는 우리가 흔히 생각하는 시간 범위의 결과를 제공한다. 예를 들어 duration의 1년 후는 시작일로부터 365일 후가 되는 날짜를 리턴하지만 period의 1년 후는 연도가 1이 더해진 날짜를 리턴한다. 두가지의 결과가 동일할 것이라고 생각되지만 윤년이 낀 경우는 duration의 결과는 period의 결과와 달라진다. 또 duration 함수에 정수 시퀀스를 넣어주면 해당 연산에 의한 vector값이 얻어진다.2 as.Date(&#39;2011-01-01&#39;) + years(1) ## [1] &quot;2012-01-01&quot; as.Date(&#39;2011-01-01&#39;) + dyears(1) ## [1] &quot;2012-01-01 06:00:00 UTC&quot; leap_year(2012) ## [1] TRUE as.Date(&#39;2012-01-01&#39;) + years(1) ## [1] &quot;2013-01-01&quot; as.Date(&#39;2012-01-01&#39;) + dyears(1) ## [1] &quot;2012-12-31 06:00:00 UTC&quot; as.Date(&#39;2012-01-01&#39;) + weeks(0:10) ## [1] &quot;2012-01-01&quot; &quot;2012-01-08&quot; &quot;2012-01-15&quot; &quot;2012-01-22&quot; &quot;2012-01-29&quot; ## [6] &quot;2012-02-05&quot; &quot;2012-02-12&quot; &quot;2012-02-19&quot; &quot;2012-02-26&quot; &quot;2012-03-04&quot; ## [11] &quot;2012-03-11&quot; as.Date(&#39;2012-01-01&#39;) + dweeks(0:10) ## [1] &quot;2012-01-01&quot; &quot;2012-01-08&quot; &quot;2012-01-15&quot; &quot;2012-01-22&quot; &quot;2012-01-29&quot; ## [6] &quot;2012-02-05&quot; &quot;2012-02-12&quot; &quot;2012-02-19&quot; &quot;2012-02-26&quot; &quot;2012-03-04&quot; ## [11] &quot;2012-03-11&quot; https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html "],["시계열-데이터-반올림.html", "4.3 시계열 데이터 반올림", " 4.3 시계열 데이터 반올림 시간의 계산에서도 숫자의 계산과 같이 올림, 내림, 반올림 등이 가능하다. 숫자의 계산에서는 소수점 세째자리, 천단위 반올림, 올림 등과 같이 반올림될 단위를 지정해야 하는데 시간의 올림, 반올림 연산에도 월에서 반올림을 할것인지 일에서 반올림을 할 것인지와 같은 단위를 지정해야 한다.3 lubridate 패키지 lubridate 패키지에서는 시간 데이터의 반올림을 위해 round_date(), 내림을 위해 floor_date(), 올림을 위해 ceiling_date() 함수를 제공한다. 매개변수로 ‘day,’ ‘week,’ ‘month,’ ‘halfyear,’ ‘year’ 등을 설정하여 반올림, 올림, 내림의 기본 단위를 지정할 수 있다. x &lt;- as.Date(&quot;2009-08-03&quot;) round_date(x, &quot;day&quot;) # 일단위로 반올림 ## [1] &quot;2009-08-03&quot; round_date(x, &quot;week&quot;) # 주단위로 반올림 ## [1] &quot;2009-08-02&quot; round_date(x, &quot;month&quot;) # 월단위로 반올림 ## [1] &quot;2009-08-01&quot; round_date(x, &quot;halfyear&quot;) # 반기단위로 반올림 ## [1] &quot;2009-07-01&quot; round_date(x, &quot;year&quot;) # 년단위로 반올림 ## [1] &quot;2010-01-01&quot; floor_date(x, &quot;day&quot;) # 일단위로 내림 ## [1] &quot;2009-08-03&quot; floor_date(x, &quot;week&quot;) # 주단위로 내림 ## [1] &quot;2009-08-02&quot; floor_date(x, &quot;month&quot;) # 월단위로 내림 ## [1] &quot;2009-08-01&quot; floor_date(x, &quot;halfyear&quot;) # 반기 단위로 내림 ## [1] &quot;2009-07-01&quot; floor_date(x, &quot;year&quot;) # 년단위로 내림 ## [1] &quot;2009-01-01&quot; ceiling_date(x, &quot;day&quot;) # 일단위로 올림 ## [1] &quot;2009-08-04&quot; ceiling_date(x, &quot;week&quot;) # 주단위로 올림 ## [1] &quot;2009-08-09&quot; ceiling_date(x, &quot;month&quot;) # 월단위로 올림 ## [1] &quot;2009-09-01&quot; ceiling_date(x, &quot;halfyear&quot;) # 반기 단위로 올림 ## [1] &quot;2010-01-01&quot; ceiling_date(x, &quot;year&quot;) # 년단위로 올림 ## [1] &quot;2010-01-01&quot; days_in_month(as.Date(&#39;2012-2&#39;, format = &#39;%Y-%d&#39;)) # 말일을 구하는 코드 ## Feb ## 29 xts 패키지 xts 클래스 데이터 객체에서는 위의 예제를 적용할 수 없다. 다만 xts 패키지에서는 floor_date와 ceiling_date와 유사한 기능을 수행하는 함수, first(), last()를 제공한다. first()는 함수에서 지정된 단위의 첫번째 날짜를 리턴하고 last()는 지정된 단위의 마지막 날짜를 리턴한다. endpoints 함수는 기본값으로 매월 마지막 날짜를 반환하지만 매개변수를 설정함으로써 매주 마지막날, 매월 마지막날, 매년 마지막날 등을 반환할 수 있다 x &lt;- xts(1:100, Sys.Date()+1:100) first(x, 10) ## [,1] ## 2021-02-06 1 ## 2021-02-07 2 ## 2021-02-08 3 ## 2021-02-09 4 ## 2021-02-10 5 ## 2021-02-11 6 ## 2021-02-12 7 ## 2021-02-13 8 ## 2021-02-14 9 ## 2021-02-15 10 first(x, &#39;1 day&#39;) ## [,1] ## 2021-02-06 1 first(x, &#39;4 days&#39;) ## [,1] ## 2021-02-06 1 ## 2021-02-07 2 ## 2021-02-08 3 ## 2021-02-09 4 first(x, &#39;month&#39;) ## [,1] ## 2021-02-06 1 ## 2021-02-07 2 ## 2021-02-08 3 ## 2021-02-09 4 ## 2021-02-10 5 ## 2021-02-11 6 ## 2021-02-12 7 ## 2021-02-13 8 ## 2021-02-14 9 ## 2021-02-15 10 ## 2021-02-16 11 ## 2021-02-17 12 ## 2021-02-18 13 ## 2021-02-19 14 ## 2021-02-20 15 ## 2021-02-21 16 ## 2021-02-22 17 ## 2021-02-23 18 ## 2021-02-24 19 ## 2021-02-25 20 ## 2021-02-26 21 ## 2021-02-27 22 ## 2021-02-28 23 last(x, 10) ## [,1] ## 2021-05-07 91 ## 2021-05-08 92 ## 2021-05-09 93 ## 2021-05-10 94 ## 2021-05-11 95 ## 2021-05-12 96 ## 2021-05-13 97 ## 2021-05-14 98 ## 2021-05-15 99 ## 2021-05-16 100 last(x, &#39;2 weeks&#39;) ## [,1] ## 2021-05-03 87 ## 2021-05-04 88 ## 2021-05-05 89 ## 2021-05-06 90 ## 2021-05-07 91 ## 2021-05-08 92 ## 2021-05-09 93 ## 2021-05-10 94 ## 2021-05-11 95 ## 2021-05-12 96 ## 2021-05-13 97 ## 2021-05-14 98 ## 2021-05-15 99 ## 2021-05-16 100 https://rdrr.io/cran/lubridate/man/round_date.html "],["시계열-데이터-grouping.html", "4.4 시계열 데이터 Grouping", " 4.4 시계열 데이터 Grouping 시계열 데이터를 사용할 때 많이 사용하는 계산은 월별 평균, 주별 합계 등 일정 단위별로 그룹핑한 후 그룹함수를 적용하여 산출하는 작업이다. 아쉽게도 앞서 사용한 lubridate 패키지에서는 시계열 데이터를 주단위, 월단위, 년단위 등으로 그룹핑하는 함수를 제공하지 않는다. 따라서 lubridate 함수를 이용하여 그룹화하기 위해서는 dplyr에서 제공하는 pipe 연산자와 함수를 같이 사용하여 산출할 수 있다. 하지만 앞장에서 소개한 timetk 패키지에서는 그룹핑하여 평균을 내거나 합계를 내는 함수를 제공하기 때문에 이를 사용할 수도 있다. lubridate 패키지 먼저 그룹핑을 하기 위한 단위를 설정하기 위해 lubridate 패키지의 year, month, week 등의 함수를 사용하여 해당 일의 년, 월, 주등을 산출하고 mutate 함수를 사용하여 컬럼으로 만들어준다. 다음 group_by 함수를 사용하여 데이터를 그룹핑하고 summarise 함수를 통해 sum, mean 등의 그룹 함수를 사용하여 원하는 값을 산출한다. library(dplyr) loan &lt;- read.csv(&#39;./한국장학재단_일일대출실행통계_20191231.csv&#39;, header = TRUE, na = &#39;-&#39;, strip.white = TRUE, stringsAsFactors = TRUE) loan$기준일자 &lt;- as.Date(loan$기준일자) loan %&gt;% mutate(month = month(기준일자), year = year(기준일자)) %&gt;% group_by(month, year) %&gt;% summarise(total.신규실행건수 = sum(당일신규실행건수), total.신규실행액수 = sum(당일신규실행금액.억원.)) ## # A tibble: 12 x 4 ## # Groups: month [12] ## month year total.신규실행건수 total.신규실행액수 ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 1 2019 47507 1059 ## 2 2 2019 305948 5965 ## 3 3 2019 146234 2183 ## 4 4 2019 57716 602 ## 5 5 2019 25083 261 ## 6 6 2019 0 0 ## 7 7 2019 40107 376 ## 8 8 2019 353268 6071 ## 9 9 2019 115432 1671 ## 10 10 2019 57523 511 ## 11 11 2019 27571 238 ## 12 12 2019 0 0 timetk 패키지 timetk 패키지에서는 그룹핑을 위해 summarise_by_time() 함수를 제공한다. 매개변수로 .date_var(시간컬럼), .by(그룹핑 단위) 등을 설정하고 산출하기 원하는 컬럼명과 그룹함수를 기재하여 원하는 값을 얻을 수 있다. library(timetk) loan %&gt;% summarise_by_time(.date_var = 기준일자, .by = &#39;week&#39;, total.신규실행건수 = sum(당일신규실행건수), total.신규실행액수 = sum(당일신규실행금액.억원.), mean.건수 = mean(당일신규실행건수)) ## # A tibble: 53 x 4 ## 기준일자 total.신규실행건수 total.신규실행액수 mean.건수 ## &lt;date&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2018-12-30 0 0 0 ## 2 2019-01-06 4386 178 366. ## 3 2019-01-13 3649 94 130. ## 4 2019-01-20 12247 182 437. ## 5 2019-01-27 51926 1120 1854. ## 6 2019-02-03 14866 231 531. ## 7 2019-02-10 51965 960 1856. ## 8 2019-02-17 131982 2613 4714. ## 9 2019-02-24 96869 1903 3460. ## 10 2019-03-03 46744 712 1669. ## # ... with 43 more rows loan %&gt;% summarise_by_time(.date_var = 기준일자, .by = &#39;month&#39;, total.신규실행건수 = sum(당일신규실행건수), total.신규실행액수 = sum(당일신규실행금액.억원.), mean.건수 = mean(당일신규실행건수)) ## # A tibble: 12 x 4 ## 기준일자 total.신규실행건수 total.신규실행액수 mean.건수 ## &lt;date&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2019-01-01 47507 1059 516. ## 2 2019-02-01 305948 5965 2732. ## 3 2019-03-01 146234 2183 1179. ## 4 2019-04-01 57716 602 481. ## 5 2019-05-01 25083 261 202. ## 6 2019-06-01 0 0 0 ## 7 2019-07-01 40107 376 323. ## 8 2019-08-01 353268 6071 2849. ## 9 2019-09-01 115432 1671 962. ## 10 2019-10-01 57523 511 464. ## 11 2019-11-01 27571 238 238. ## 12 2019-12-01 0 0 0 loan %&gt;% summarise_by_time(.date_var = 기준일자, .by = &#39;quarter&#39;, total.신규실행건수 = sum(당일신규실행건수), total.신규실행액수 = sum(당일신규실행금액.억원.), mean.건수 = mean(당일신규실행건수)) ## # A tibble: 4 x 4 ## 기준일자 total.신규실행건수 total.신규실행액수 mean.건수 ## &lt;date&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2019-01-01 499689 9207 1523. ## 2 2019-04-01 82799 863 227. ## 3 2019-07-01 508807 8118 1383. ## 4 2019-10-01 85094 749 234. xts 패키지 data.frame 클래스의 시계열 객체는 위와 같이 dplyr 패키지의 기능을 이용해 그룹핑하고 그룹함수를 적용용하지만 xts 클래스에서는 시간 유닛별로 그룹핑하여 그룹함수를 적용할 수 있는 함수를 지원한다. 따라서 연 평균, 월 합계와 같은 작업에 편리하게 사용할 수 있다. loan.xts &lt;- as.xts(loan[, -c(1, 2)], order.by = loan$기준일자) apply.monthly(loan.xts[,1], sum) ## 당일신규실행건수 ## 2019-01-31 47507 ## 2019-02-28 305948 ## 2019-03-31 146234 ## 2019-04-30 57716 ## 2019-05-31 25083 ## 2019-06-30 0 ## 2019-07-31 40107 ## 2019-08-31 353268 ## 2019-09-30 115432 ## 2019-10-31 57523 ## 2019-11-30 27571 ## 2019-12-31 0 apply.weekly(loan.xts[,1], sum) %&gt;% head(10) ## 당일신규실행건수 ## 2019-01-01 0 ## 2019-01-13 4386 ## 2019-01-20 3649 ## 2019-01-27 12247 ## 2019-02-03 51926 ## 2019-02-10 14866 ## 2019-02-17 51965 ## 2019-02-24 131982 ## 2019-03-03 96869 ## 2019-03-10 46744 apply.quarterly(loan.xts[,1], sum) ## 당일신규실행건수 ## 2019-03-31 499689 ## 2019-06-30 82799 ## 2019-09-30 508807 ## 2019-12-31 85094 "],["시계열-데이터-rolling.html", "4.5 시계열 데이터 Rolling", " 4.5 시계열 데이터 Rolling 주식투자를 하는 분들은 주식거래 프로그램에서 많은 시계열 그래프들을 보게된다. 이들 그래프 중에 어떤 그래프에는 MA(5), MA(10)과 같은 표기가 된 line plot을 볼 수 있는데 이를 이동평균이라고 한다. 최근 5일 평균, 최근 10일 평균과 같이 평균의 기준 범위가 날짜별로 달라지면서 평균을 구하게 되는데 이와 같이 기준일에서 특정 기간의 일, 월의 집합 함수를 적용하는 과정을 rolling이라 하고 rolling의 기간을 rolling window라고 한다. rolling도 앞선 group과 같이 lubridate 패키지에서 제공하는 함수를 dplyr 함수와 파이프라인을 사용하는 방법, timetk 패키지를 사용하는 방법, xts 패키지를 사용하는 방법을 설명하고자 한다. lubridate 패키지 lubridate 패키지를 사용하여 data.frame 클래스 객체에 대한 rolling은 좀 복잡하다. 하지만 zoo 패키지에서 제공하는 roll* 함수를 사용하면 비교적 쉽게 rolling을 수행할 수있어 이 방법을 소개하고자 한다. 사실 이 방법에서는 lubridate 패키지 함수는 사용되지 않는데 mutate 함수를 이용하여 새로운 컬럼을 생성하는데 각 컬럼을 생성하는 함수로 zoo 패키지의 roll* 함수를 사용한다. roll* 함수는 rollapply()와 rollmean()의 두가지를 제공하는데 rollapply는 apply함수를 rolling용으로 수정한 버젼이고 rollapply 함수에 mean을 적용하는 경우가 많기 때문에 추가적으로 이동평균을 구하는 함수를 제공한다. library(zoo) loan %&gt;% mutate(ma3 = rollmean(당일신규실행건수, k = 3, fill = NA), sum3 = rollapply(당일신규실행건수, 3, sum, fill = NA)) %&gt;% select(당일신규실행건수, ma3, sum3) %&gt;% head(10) ## 당일신규실행건수 ma3 sum3 ## 1 0 NA NA ## 2 0 0.0000 0 ## 3 0 0.0000 0 ## 4 0 422.6667 1268 ## 5 1268 589.3333 1768 ## 6 500 602.3333 1807 ## 7 39 181.0000 543 ## 8 4 167.3333 502 ## 9 459 181.0000 543 ## 10 80 182.0000 546 timetk 패키지 ma3 &lt;- slidify(mean, .period = 3, .align = &quot;center&quot;) sum3 &lt;- slidify(sum, .period = 3, .align = &quot;center&quot;) loan %&gt;% mutate(ma3 = ma3(당일신규실행건수), sum3 = sum3(당일신규실행건수)) %&gt;% select(당일신규실행건수, ma3, sum3) %&gt;% head(10) ## 당일신규실행건수 ma3 sum3 ## 1 0 NA NA ## 2 0 0.0000 0 ## 3 0 0.0000 0 ## 4 0 422.6667 1268 ## 5 1268 589.3333 1768 ## 6 500 602.3333 1807 ## 7 39 181.0000 543 ## 8 4 167.3333 502 ## 9 459 181.0000 543 ## 10 80 182.0000 546 xts 패키지 "],["시계열-데이터-filtering.html", "4.6 시계열 데이터 filtering", " 4.6 시계열 데이터 filtering "],["시계열-데이터-subsetting.html", "4.7 시계열 데이터 subsetting", " 4.7 시계열 데이터 subsetting "]]
