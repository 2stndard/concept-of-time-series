<<<<<<< HEAD
[["시계열-데이터-타입-및-import.html", "Chapter 2 시계열 데이터 타입 및 Import", " Chapter 2 시계열 데이터 타입 및 Import 시계열 데이터는 시간을 인덱스로 사용해야하기 때문에 반드시 시간형 데이터 클래스가 존재하거나 이에 준하는 정보가 포함되어야 한다. R에서는 시간을 인덱스로 허용하는 데이터 클래스를 몇가지 제공하고 있는데 그 클래스에 따라 데이터 처리 함수, plot 함수, 모델 생성 함수 등의 사용법이 다르기 때문에 주의 깊게 설정해야 한다. 또한 각각의 데이터 클래스들이 장단점을 가지기 때문에 데이터 간의 변환을 통해 사용해야할 경우도 있다. 이 장에서는 R에서 많이 사용하는 날짜/시간 데이터 클래스와 시계열 전용 객체를 소개하고 데이터를 R로 불러들여 시계열 객체로 저장하는 방법에 대해 알아본다. 여기서 생성된 시계열 데이터를 사용하여 앞으로 시계열 모델링, 예측에 사용할 것이다. "],["날짜시간-데이터-클래스.html", "2.1 날짜/시간 데이터 클래스", " 2.1 날짜/시간 데이터 클래스 앞서 설명한 것과 같이 시계열 분석을 위한 시계열 데이터에는 반드시 시간이 표현된 데이터가 포함되어야 한다. 따라서 R이 특정 데이터를 시간으로 이해하기 위해서는 R이 이해할 수 있는 형태로 시간을 표기해야 한다. R이 이해하는 시간 데이터의 형태는 date , POSIXct, POSIXlt, yearmon, yearqtr클래스 등이 있다. 2.1.1 date 클래스 R 에서 기본적으로 제공하는 시간 표현 클래스로 1970년 이후의 달력 상의 날짜 수를 기록하는 데이터 클래스이다. 양수일 경우 1970년 이후의 날짜이며 음수인 경우 1970년 이전의 날짜를 표시한다. date class는 실제 R내부에 저장 시에는 정수 형태로 저장되지만 출력 시에는 ‘yyyy-mm-dd’ 형태로 표현된다. date 클래스는 특별한 패키지가 필요하지 않고 바로 사용할 수 있다. date 타입의 데이터를 생성하기 위해서는 아래와 같이 as.Date()를 사용한다. (date &lt;- as.Date(c(&#39;2021-01-31&#39;, &#39;2021-02-28&#39;, &#39;2021-03-31&#39;))) [1] &quot;2021-01-31&quot; &quot;2021-02-28&quot; &quot;2021-03-31&quot; (date &lt;- as.Date(c(&#39;21/01/31&#39;, &#39;21/02/28&#39;, &#39;21/03/31&#39;), format = &#39;%y/%m/%d&#39;)) [1] &quot;2021-01-31&quot; &quot;2021-02-28&quot; &quot;2021-03-31&quot; unclass(date) [1] 18658 18686 18717 코드 설명 as.Date()는 벡터로 전달된 데이터를 date 클래스로 변환 변환하기 위해서는 전달된 벡터가 date format을 갖추어야 하나 갖추지 못한 경우는 format 매개변수로 설정 가능하며 많이 사용되는 format 지정자는 다음 절에 설명 date class의 클래스를 해체(unclass())하면 내부적으로 저장된 1970년 이후의 날짜수가 보임 2.1.2 POSIXct, POSIXlt class date 클래스는 1970년 이후 일의 수를 기록하는 클래스이지만 POSIXct 와 POSIXlt 클래스는 1970년 이후 시간을 초 단위로 기록하는 데이터 클래스이다. POSIXct는 date 클래스와 같이 1970년이후의 시간을 초 단위의 정수로 기록하는 클래스이고 POSIXlt는 년, 월, 일, 시, 분, 초의 정보를 리스트형태로 기록하는 클래스이다. POSIXlt는 1900년 이후로 계산되어 리스트가 만들어 진다. # character를 POSIXct class 로 변환 as.POSIXct(&#39;2021-01-31 12:34:56&#39;) [1] &quot;2021-01-31 12:34:56 KST&quot; # POSIXct를 해제하면 정수 unclass(as.POSIXct(&#39;2021-01-31 12:34:55&#39;)) [1] 1612064095 attr(,&quot;tzone&quot;) [1] &quot;&quot; # character를 POSIXlt class 로 변환 as.POSIXlt(&#39;2021-01-31 12:34:56&#39;) [1] &quot;2021-01-31 12:34:56 KST&quot; # POSIXlt를 해제하면 list unclass(as.POSIXlt(&#39;2021-12-31 12:34:56&#39;)) $sec [1] 56 $min [1] 34 $hour [1] 12 $mday [1] 31 $mon [1] 11 $year [1] 121 $wday [1] 5 $yday [1] 364 $isdst [1] 0 $zone [1] &quot;KST&quot; $gmtoff [1] NA # POSIXlt에서 1900년 이후 연도를 추출 as.POSIXlt(&#39;2021-12-31 12:34:56&#39;)$year [1] 121 코드 설명 as.POSIXct()는 벡터로 전달된 데이터를 POSIXct 클래스로 변환 POSIXct class를 해체(unclass())하면 내부적으로 저장된 1970년 이후의 해당 시간까지의 초 수가 보임 as.POSIXlt()는 벡터로 전달된 데이터를 POSIXlt 클래스로 변환 POSIXlt class를 해체하면 리스트로 저장된 날짜 속성이 보임 POSIXlt에서 날짜 속성을 뽑아내려면 $속성명을 사용 2.1.3 yearmon, yearqtr class yearmon과 yearqtr 클래스는 모두 zoo 패키지에서 제공하는 클래스이다. 따라서 두 클래스를 사용하기 위해서는 zoo 패키지를 설치하고 로딩해야 한다. yearmon과 yearqtr 클래스는 연, 월로 표현되거나 년, 분기로 표현된 시간 데이터가 있을 때 사용한다. yearmon 클래스는 연, 월별 데이터를 표현하는 클래스이고 yearqtr는 연, 분기 데이터를 표현하는 클래스이다. yearmon 클래스는 1월을 0으로 2월을 1/12 = 0.083, 12월을 11/12 = 0.917로 표기하고 yearqtr 클래스는 각 분기마다 0.25씩 더해서 저장되지만 표현될 때는 우리가 쓰는 시간 형태로 표현된다. if(!require(zoo)) { install.packages(&#39;zoo&#39;) library(zoo) } # character를 yearmon class로 변환 as.yearmon(&quot;2007-02&quot;) [1] &quot;2 2007&quot; # yearmon class를 해제하면 double unclass(as.yearmon(&quot;2007-02&quot;)) [1] 2007.083 # 날짜가 있어도 yearmon은 년, 월까지만 인식 as.yearmon(&quot;2007-02-01&quot;) [1] &quot;2 2007&quot; # character를 yearqtr class로 변환(1분기) as.yearqtr(&quot;2007-01&quot;) [1] &quot;2007 Q1&quot; # yearqtr class를 해제하면 double unclass(as.yearqtr(&quot;2007-04&quot;)) [1] 2007.75 코드 설명 yearmon, yearqtr 클래스를 사용하기 위해서는 zoo 패키지를 먼저 로딩해야 함. as.yearmon()로 날짜 문자열이나 date 클래스를 yearmon 클래스로 변환 yearmon 클래스를 해체하면 정수 부분이 연도이고 소수점부분이 월(month/12)로 표현된 실수로 보임 as.yearmon()에 연월일을 전달해도 년월만 인식 as.yearqtr()로 날짜 문자열이나 date 클래스를 yearqtr 클래스로 변환 yearmon 클래스를 해체하면 정수 부분이 연도이고 소수점부분이 분기(분기/4)로 표현된 실수로 보임 2.1.4 날짜, 시간 포맷 날짜와 시간을 표현하는 방법은 여러가지가 있다. R에서는 as.Date(), as.POSIXct()등과 같은 시간 클래스 생성 함수에서 format을 사용하여 다양한 날짜와 시간의 표현을 지원한다. format 매개변수에 의해 표현되는 날짜, 시간 표기는 날짜 표현 방법, 시간 클래스의 지역 설정(timezone)에 따라 달라진다. 예를 들어 우리나라 지역 설정은 %B, %b가 ‘January,’ ‘Jan’ 이 아닌 ’1월’로 표기된다. standard date format codes Code Value Example %d 월의 날짜(정수) 23 %m 월(정수) 12 %B 전체 월 이름 January %b 축약형 월 이름 Jan %Y 4자리 연도 2010 %y 2자리 연도 10 %a 요일 수 as.Date(&#39;01/12/2010&#39;, format = &#39;%d/%m/%Y&#39;) [1] &quot;2010-12-01&quot; Sys.setlocale(&quot;LC_ALL&quot;, &quot;English&quot;) [1] &quot;LC_COLLATE=English_United States.1252;LC_CTYPE=English_United States.1252;LC_MONETARY=English_United States.1252;LC_NUMERIC=C;LC_TIME=English_United States.1252&quot; as.Date(&#39;01jan21&#39;, format = &#39;%d%b%y&#39;) [1] &quot;2021-01-01&quot; Sys.setlocale(&quot;LC_ALL&quot;, &quot;Korean&quot;) [1] &quot;LC_COLLATE=Korean_Korea.949;LC_CTYPE=Korean_Korea.949;LC_MONETARY=Korean_Korea.949;LC_NUMERIC=C;LC_TIME=Korean_Korea.949&quot; as.Date(&#39;011월21&#39;, format = &#39;%d%b%y&#39;) [1] &quot;2021-01-01&quot; 코드 설명 format이 %d/%m/%Y형태로 표시된 문자열을 date형태로 변환 timezone을 영국으로 설정 format이 %d%b%y형태로 표시된 문자열을 date형태로 변환 timezone을 한국으로 설정 format이 %d%b%y형태로 표시된 문자열을 date형태로 변환 "],["시계열-데이터-객체object.html", "2.2 시계열 데이터 객체(Object)", " 2.2 시계열 데이터 객체(Object) R에서는 일반적으로 데이터 프레임에 데이터를 저장하는 경우가 많다. 시계열 데이터도 데이터프레임에 저장할 수 도 있다. 하지만 시계열 데이터는 시간 인덱스를 기반으로 검색, 분할, 집계, 병합과 같은 데이터 핸들링이 이루어지기 때문에 데이터 프레임보다는 시계열 데이터를 처리하는 객체에서 처리하는 것이 효과적이다. 따라서 R에서는 시간 인덱스를 기반으로 데이터를 처리하기 위한 특별한 데이터 객체를 제공하고 있다.2 R에서 사용할 수 있는 시계열 데이터 객체는 R에서 자체적으로 에서 제공하는 객체도 있지만 시계열 패키지를 통해 사용하는 객체도 있다. 2.2.1 ts : R base(stats) ts 객체(Object)는 R에서 가장 기본적으로 활용되는 시계열 데이터 타입이다. ts 객체는 stats 패키지를 로딩해야 사용할 수 있지만 R이 실행될 때 기본적으로 로딩되기 때문에 바로 활용할 수 있다. 또한 stats 패키지에 포함된 다양한 시계열 데이터 처리 함수에서 다루는 객체이기 때문에 많이 사용된다.3 ts 객체는 앞서 설명한 바와 같이 R에서 기본적으로 제공하는 시계열 객체라는 장점이 있지만 사용상의 단점도 있다. 우리는 시계열 데이터를 사용할 때 외부에서 생성된 시계열 데이터를 R로 불러들여 사용하는 경우가 일반적이다. 이 경우 외부에서 생성된 데이터는 일반적으로 데이터의 시간이 같이 기록되어 있고 사용자는 기록된 시간을 불러들여 사용하고 싶을 것이다. 하지만 ts 객체는 생성시에 데이터에 기록된 시간을 사용하는 것이 아닌 객체 생성시에 시계열 데이터의 주기(1은 연도 데이터, 12는 월 데이터 등)를 설정해야 하고 시작일, 종료일을 설정하여 날짜를 자체 설정하도록 규정하고 있다. 따라서 외부에서 생성된 데이터에 결측치가 존재하는 경우 후처리 과정이 필요할 수도 있다. ts 데이터 객체는 다음과 같이 생성할 수 있다. ts(1:10, frequency = 4, start = c(1959, 2)) Qtr1 Qtr2 Qtr3 Qtr4 1959 1 2 3 1960 4 5 6 7 1961 8 9 10 코드 설명 1959년 2분기(start = c(1959, 2))부터 주기가 4(분기,frequency = 4)인 ts 객체 생성 2.2.2 xts xts는 extensible time-series의 준말로 xts 패키지를 로딩해야 활용할 수 있는 데이터 객체이다. xts는 뒤에서 다룰 모델링 패키지(forecast, fable, modeltime)에서 사용되지 않는 시계열 객체이다. 하지만 시계열 데이터 핸들링을 위한 다양한 함수를 제공하기 때문에 간단히 데이터를 확인하거나 데이터를 원하는 형태로 변환하는데 쉬운 함수들을 제공한다. 그래서 xts 객체를 사용하여 원하는 형태로 데이터를 만들고 다른 시계열 객체로 변환하는 것도 좋은 방법이다. xts로 데이터를 핸들링 하는 방법은 다음 장에서 설명한다. xts 클래스를 사용하기 위해서는 먼저 xts 패키지를 설치하고 로딩해야 한다. 필자는 패키지를 로딩 할 때 다음과 같이 설치, 로딩을 한다. if(!require(xts)) { install.packages(&#39;xts&#39;) library(xts) } 코드 설명 require()는 library()와 같이 패키지를 로딩하는 함수이지만 다른 함수안에서 사용하는 것을 목적으로 만들어진 함수임. 로딩에 성공하면 TRUE, 로딩에 실패하면 FALSE를 리턴함 만약, 패키지 로딩에 실패하면(!require(xts)) 패키지를 설치(install.packages('xts'))하고 로딩(library(xts))함. xts 데이터 객체 생성은 다음과 같이 생성할 수 있다. xts(rnorm(5), as.Date(&quot;2008-08-01&quot;) + 0:4) [,1] 2008-08-01 0.2798354 2008-08-02 -1.0746538 2008-08-03 -1.2448951 2008-08-04 -0.4899046 2008-08-05 -0.8599308 as.xts(rnorm(5), as.Date(&quot;2008-08-01&quot;) + 0:4) [,1] 2008-08-01 0.49760493 2008-08-02 2.24577970 2008-08-03 -0.27255456 2008-08-04 0.04923382 2008-08-05 2.50263825 코드 설명 2008년 8월 1일 부터 5일치(as.Date(\"2008-08-01\") + 0:4) 데이터를 가지는 xts object 생성 2008년 8월 1일 부터 5일치 데이터를 가지는 xts 객체로 변환 xts()는 xts 객체를 생성하는 함수이나 as.xts()는 timeSeries, ts, irts, fts, matrix, data.frame, zoo 객체를 xts객체로 변환하는 함수이다.4 다음과 같은 차이가 발생한다. ts &lt;- ts(1:10, frequency = 4, start = c(1959, 2)) xts(ts) Error in xts(ts): order.by requires an appropriate time-based object as.xts(ts) [,1] 1959 Q2 1 1959 Q3 2 1959 Q4 3 1960 Q1 4 1960 Q2 5 1960 Q3 6 1960 Q4 7 1961 Q1 8 1961 Q2 9 1961 Q3 10 코드 설명 xts를 생성해야하나 인덱스가 정해지지 않아 에러 발생 ts 객체의 특성을 해석하여 인덱스를 설정하여 xts로 변환 ts, xts는 모두 시계열 데이터를 다루는 객체이지만 xts가 보다 시계열 데이터를 다루는데 유연한 함수가 많다. 최근에는 ts 객체에도 동일하게 적용할 수 있는 xts 함수가 제공되고 있는데, xts 매뉴얼에 의하면 as.xts와 reclass를 활용하는 것이 xts를 사용하는 것보다 이익이 있다고 명기하고 있다.5 # 시계열 데이터 형태로 보이지 않음 head(ts) [1] 1 2 3 4 5 6 # 시계열 형태로 보임 head(as.xts(ts)) [,1] 1959 Q2 1 1959 Q3 2 1959 Q4 3 1960 Q1 4 1960 Q2 5 1960 Q3 6 2.2.3 tsibble 최근 R에서 사용하는 데이터 핸들링 방법으로 가장 인기있는 것이 tidyverse 를 사용하는 방법이다. 이 방법을 시계열 데이터 작업에도 사용하기 할 수 있도록 해주는 방법으로 제공되는 것이 tidyverts 패밀리 패키지들을 사용하는 것이다. tidyverts는 tidyverse처럼 단독으로 제공되는 패키지는 아니지만 시계열 데이터를 저장할 수 있는 객체 패키지인 tsibble, 시계열 예측을 위한 fable, 시계열 특성 추출과 통계를 위한 feast, 최근에 페이스 북에서 개발된 prophet 모델을 사용하기 위한 fable.prophet 패키지 등이 포함한다.6 tsibble 객체는 tsibble 패키지를 통해 제공되는 시계열 데이터 객체로써 tidy 데이터 원칙7을 준용하여 준용하여 시계열 데이터를 다룰 수 있도록 한 tibble 객체를 시계열 데이터에서 사용할 수 있도록 확장한 객체이다. tsibble 객체는 tibble에서 각 관찰치(observation)를 고유하게 식별할 수 있는 컬럼 혹은 컬럼의 집합인 key와 시간의 순서가 지정되는 index를 필요로 한다. 즉 tibble 객체에서는 key로 특정 관찰치를 식별할 수 있지만 tsibble에서는 key를 통해 관찰치를 고유하게 식별하고 관찰치들은 다시 시간(index)에 따라 구분될 수 있다. 따라서 tsibble은 key와 index를 사용하여 고유한(unique) 관찰치의 고유한 데이터를 식별하게 된다.8 tsibble 객체를 사용하기 위해서는 우선 tsibble 패키지를 설치하고 로딩해야한다. 다음과 같이 설치는 install.package 함수를 사용하고 로딩은 library 함수를 사용한다. if(!require(tsibble)) { install.packages(&#39;tsibble&#39;) library(tsibble) } tsibble 패키지를 로딩 한 후에 tsibble 객체를 생성할 수 있다. tsibble 객체를 생성하는 방법은 tsibble() 을 사용해서 직접 tsibble 객체를 생성할 수도 있고 데이터 프레임으로 생성된 객체를 as.tsibble()를 사용해 tsibble 객체로 변환하는 방법이 있다. 이 중 데이터 프레임을 tsibble 객체로 변환하는 방법은 다음과 같다. library(dplyr) x &lt;- data.frame(date = as.Date(&#39;2008-01-01&#39;) + 0:9, id = 1:10, x1 = rnorm(10), x2= rep(&#39;a&#39;, 10)) as_tsibble(x, key = id, index = date) # A tsibble: 10 x 4 [1D] # Key: id [10] date id x1 x2 &lt;date&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; 1 2008-01-01 1 -2.24 a 2 2008-01-02 2 0.0603 a 3 2008-01-03 3 -0.291 a 4 2008-01-04 4 1.36 a 5 2008-01-05 5 -0.667 a 6 2008-01-06 6 1.82 a 7 2008-01-07 7 0.0140 a 8 2008-01-08 8 -0.189 a 9 2008-01-09 9 0.204 a 10 2008-01-10 10 -1.37 a as_tsibble(x, index = date) # A tsibble: 10 x 4 [1D] date id x1 x2 &lt;date&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; 1 2008-01-01 1 -2.24 a 2 2008-01-02 2 0.0603 a 3 2008-01-03 3 -0.291 a 4 2008-01-04 4 1.36 a 5 2008-01-05 5 -0.667 a 6 2008-01-06 6 1.82 a 7 2008-01-07 7 0.0140 a 8 2008-01-08 8 -0.189 a 9 2008-01-09 9 0.204 a 10 2008-01-10 10 -1.37 a 코드설명 tsibble로 변환할 데이터 프레임 x를 생성. date 컬럼은 ‘2008년 1월 1일’(as.Data('2008-01-01'))부터 10일후 까지( + 0:9)이고 id 컬럼은 1부터 10까지(1:10), x1은 정규분포 랜덤값 10개(rnorm(10)), x2는 ‘a’(rep('a', 10))로 채움 as.tsibble()로 x를 tsibble로 변환하는데 key값은 id(key = id), index 값은 date(index = date)로 설정. as.tsibble()로 x를 tsibble로 변환하는데 key값은 생략하고, index 값은 date(index = date)로 설정. Eric Zivo, Working with Financial Time Series Data in R, 2014, https://faculty.washington.edu/ezivot/econ424/Working%20with%20Time%20Series%20Data%20in%20R.pdf ts, R document , https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/ts, 2021.1.31 https://www.rdocumentation.org/packages/xts/versions/0.12.1/topics/as.xts.methods https://cran.r-project.org/web/packages/xts/xts.pdf https://tidyverts.org/ https://tidyr.tidyverse.org/articles/tidy-data.html https://github.com/tidyverts/tsibble "],["시계열-데이터-import.html", "2.3 시계열 데이터 Import", " 2.3 시계열 데이터 Import 시계열(Time Series) 데이터를 R에서 직접 생성할 수도 있으나 대부분의 경우는 다양한 파일 포맷(Excel, CSV, SPSS 등)으로 저장된 파일에서 읽어 들이는 방법이 일반적이다. 일반적으로 데이터 파일에서 데이터를 읽어 들여 시계열 데이터로 저장하는 방법은 다음과 같은 과정을 거친다. read_excel(), read.csv()을 사용하여 엑셀 파일을 읽어 데이터를 데이터 프레임에 저장 읽어온 데이터가 적절한 데이터 타입으로 불러들여졌는지 확인하고 적절치 않은 데이터 타입으로 설정된 경우 적절히 변환 읽어온 데이터 중 시간을 기록한 데이터 컬럼을 as.Date()를 사용하여 date 클래스로 변환 시간 컬럼이 생성된 데이터 프레임을 as.ts(), as.xts(), as.tsibble() 등을 사용하여 사용하기 원하는 시계열 객체로 변환 여기에서는 다양한 파일 포맷 중 Excel과 CSV파일에서 시계열 데이터를 읽어 들여 활용하는 방법을 설명한다. 2.3.1 엑셀 파일 데이터를 엑셀 파일에서 읽어 들여 데이터 프레임에 저장 후 저장된 데이터 프레임을 시계열 데이터 타입으로 변환할 수 있다. 다음 예제에서 사용하는 자료는 연도별 학교급별 학생수 자료로 한국교육개발원 교육통계 서비스 홈페이지9에서 다운로드하였으며 연도별 시계열 데이터 샘플로 사용한다. read_excel()을 통해 excel 파일을 바로 읽어 들일 수 있다. read_excel()을 사용하기 위해서는 먼저 readxl 패키지가 필요하다. 앞에서 소개한 엑셀 데이터를 데이터 프레임으로 읽어 들이는 방법은 아래와 같다. 하나 주의해야하는 점은 col_type으로 적절한 데이터 타입을 미리 알려주지 않으면 엉뚱한 데이터가 들어온다는 것이다. 이 데이터 파일에서의 문제는 숫자에 천 단위 구분 기호(,)가 포함되어 있기 때문에 해당 컬럼이 numeric이라고 설정해주지 않으면 엉뚱한 데이터 타입(POSIXct)으로 불러들인다는 점이다. library(readxl) students.all &lt;- read_excel(&quot;./students.xlsx&quot;, skip = 16, na = &#39;-&#39;, sheet = 1, col_types = c(&#39;text&#39;, &#39;text&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;)) students &lt;- students.all %&gt;% filter(지역규모 == &#39;계&#39;) %&gt;% select(-지역규모) head(students) # 데이터 확인 # A tibble: 6 x 17 연도 학생수계 유치원 초등학교 중학교 고등학교계 일반계고 전문계고 일반고 &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1999 8658358 534166 3935537 1.90e6 2251140 1399389 851751 0 2 2000 8535867 545263 4019991 1.86e6 2071468 1324482 746986 0 3 2001 8414423 545142 4089429 1.83e6 1911173 1259975 651198 0 4 2002 8361933 550256 4138366 1.84e6 1795509 1220146 575363 0 5 2003 8379775 546531 4175626 1.85e6 1766529 1224452 542077 0 6 2004 8371630 541713 4116195 1.93e6 1746560 1232010 514550 0 # ... with 8 more variables: 특목고 &lt;dbl&gt;, 특성화고 &lt;dbl&gt;, 자율고 &lt;dbl&gt;, # 특수학교 &lt;dbl&gt;, 공민학교 &lt;dbl&gt;, 고등공민 &lt;dbl&gt;, 고등기술학교 &lt;dbl&gt;, # 각종학교 &lt;dbl&gt; 코드 설명 readxl 패키지를 로딩 ‘지역규모’ 컬럼이 ’계’인 데이터만 사용할 것이므로 filter()를 사용하여 원하는 데이터만 걸러내고 더이상 지역규모 컬럼이 필요없으니 제거 read_excel()을 이용하여 ‘students.xlsx’파일의 데이터를 읽음. 데이터 파일의 처음 16줄은 skip,(skip = 16)’-’로 표기된 데이터는 NA로 처리(na = '-'), 첫번째 엑셀 시트 데이터를 읽고(sheet = 1), 컬럼별 데이터 타입을 설정 불러들인 데이터는 데이터프레임으로 저장된다. 데이터 프레임도 시계열 객체를 담아 사용할 수 있는데 이를 위해서는 반드시 시간 인덱스로 사용할 컬럼이 필요하다. 불러들인 데이터에는 시간 인덱스로 사용할 수 있는 컬럼이 ‘연도’ 컬럼이다. 이 컬럼을 date 컬럼으로 바꾸는 과정은 다음과 같다. students$연도 &lt;- as.Date(paste0(students$연도, &#39;-01-01&#39;)) 코드 설명 연도만 있는 데이터를 date형태로 바꾸려면 먼저 월, 일을 추가해야하기 때문에 paste0()를 사용하여 연도에 ‘-01-01’ 문자열을 붙임. ’연도-01-01’로 만들어지 문자열을 as.Date()로 date 클래스로 변환 변환된 데이터를 student.from.excel$연도에 저장 연도 컬럼을 date 클래스로 변환한 데이터 프레임을 사용하여 ts, xts, tsibble 시계열 데이터로 변환한다. 하나 주의해야할 사항은 각각의 클래스로 변환하는 함수명이 다르다. students.ts &lt;- ts(students, frequency = 1, start = 1999) students.xts &lt;- as.xts(students[,-1], order.by = students$연도) students.tsibble &lt;- students %&gt;% mutate(연도 = yearmonth(paste0(students$연도, &#39;-01-01&#39;))) students.tsibble &lt;- as_tsibble(students.tsibble, index = 연도) 코드 설명 ts()로 student.from.excel 데이터 프레임의 데이터를 ts 객체로 변환하는데 연간 데이터이므로 주기를 1(frequency = 1)로 시작년을 1999년(start = 1999)으로 설정 as.xts()로 student.from.excel 데이터 프레임의 데이터를 xts 객체로 변환하는데 시간 인덱스를 student.from.excel$연도로 설정(order.by = student.from.excel$연도) tsibble로 변환할 데이터프레임을 미리 만들어두는데 시간인덱스로 사용할 컬럼을 yearmonth 클래스로 변환해 둠 as_tsibble()을 사용하여 students.tsibble 객체를 tsibble 객체로 변환 2.3.2 CSV 파일 CSV 파일은 데이터 필드의 구분자를 ’,’로 사용하는 형태의 텍스트 파일로 Comma Seperated Value의 준말이다. 데이터간의 호환을 위해 광범위하게 사용되는 파일 포맷이다. R에서 CSV 파일을 읽을 수 있는 함수는 여러가지가 있지만 여기서는 read.csv() 을 사용하는 방법을 설명한다. CSV 파일로 데이터를 읽어들이는 예제는 월별 데이터는 통계청 KOSIS 홈페이지의 경제활동인구조사의 산업별 취업자수에서 다운받은 월간 취업자수와 교육서비스업 취업자수 데이터를 사용한다. 이 데이터는 통계청 KOSIS 홈페이지에서 다운로드10받을 수 있는데 ’국내통계 &gt; 노동 &gt; 경제활동인구조사 &gt; 취업자 &gt; 산업별 취업자’에서 시점을 2013.1월부터 2020.12월까지, 산업구분을 전체 계와 교육서비스업으로 설정 후 행렬전환 기능을 사용하여 행에 기간, 열에 산업을 설정한 후 다운로드 받았는데 필자의 github에서 다운받을 수 있다.(csv 파일을 다운로드 받는 방법은 다음의 사이트를 참조하길 바란다. &lt;https://technical-support.tistory.com/54&gt;) 아래와 같이 read.csv 함수를 통해 csv파일을 읽어들일수 있다. employees &lt;- read.csv(&#39;./산업별_취업자_20210206234505.csv&#39;, header = TRUE, na = &#39;-&#39;, strip.white = TRUE, stringsAsFactors = TRUE) colnames(employees) &lt;- c(&#39;time&#39;, &#39;total&#39;, &#39;employees.edu&#39;) 코드설명 read.csv()를 사용하여 csv 파일의 데이터를 읽어오는데 csv 파일의 첫줄은 헤더줄로 설정(header = TRUE), ’-’로 기록된 데이터는 NA로 설정(na = '-'), 빈칸은 제거(strip.white = TRUE), 문자열은 factor로 설정(stringsAsFactors = TRUE) 컬럼명을 time, total, employees.edu 로 설정 읽어 들인 데이터가 저장된 employees 데이터프레임에는 시계열 객체에서 사용할 수 있는 시간 인덱스 컬럼이 없다. 따라서 time 컬럼을 date 클래스로 바꿔준다. employees$time &lt;- as.Date(paste0(employees$time, &#39;. 01&#39;), format = &#39;%Y. %m. %d&#39;) 코드설명 employees$time 컬럼에 저장된 데이터 형태는 ‘연도네자리. 월두자리’의 형태로 되어있기 때문에 우선 ’연도네자리. 월두자리. 일두자리’로 맞추기 위해 paste0()를 사용하여.’ 01’을 붙여줌 생성된 문자열을 date 클래스로 바꾸기 위해 as.Date()를 사용하는데 문자열 형태가 date 클래스의 기본형태가 아니기 때문에 R이 년월일을 제대로 읽을 수 있도록 format 매개변수를 사용하여 문자열 형태에서 날짜 정보를 추출하기 위한 정보(‘%Y. %m. %d’)를 전달 시간 인덱스로 사용될 date 클래스가 생성되었으므로 ts, xts, tsibble 객체로 변환한다. employees.ts &lt;- ts(employees, start = c(2013, 01), frequency = 12) employees.xts &lt;- xts(employees[,2:3], order.by = employees[,1]) employees.tsibble &lt;- as_tsibble(employees, index = time) 코드설명 ts()를 사용하여 employees를 ts 클래스로 변환하는데 시작월을 2013년 1월로 설정(start = c(2013, 01)), 월별 데이터이기 때문에 시계열 주기를 12(frequency = 12)로 설정 xts()를 사용하여 employees를 xts 클래스로 변환하는데 사용하는 데이터는 employees의 두번쨰와 세번째 컬럼만을 선택(employees[,2:3])하고 시간인덱스로 첫번째 컬럼(order.by = employees[,1])을 사용한다. as_tsibble()을 사용하여 employees를 tsibble 클래스로 변환하는데 인덱스 컬럼을 time컬럼으로 설정 2.3.3 추가 실습 데이터 생성 앞서 생성한 두개의 데이터 셋(students, employees)에 더하여 하나의 추가 데이터 셋을 더 생성할 것이다. 일별 데이터로써 코로나 확진자 수 데이터 셋을 생성할 것이다. 코로나 데이터 셋은 통계청 KOSIS 홈페이지의 코로나 현황 홈페이지에서 다운로드 받았다. 앞서 생성한 연별 데이터(students), 월별 데이터(employees)에 추가적으로 일별 데이터를 생성한다. 2.3.3.1 일별 데이터 - 코로나 확진자 수 일별 코로나 확진자 수는 통계청 KOSIS 홈페이지에서 다운로드11받았고 필자의 github에서 다운로드 받을 수 있다. 이 데이터 셋을 사용하기 위해서는 spread()를 사용하여 긴(long) 형태의 데이터 프레임을 넓은(wide) 형태의 데이터프레임이 필요하다. 먼저 read.csv()를 이용하여 파일의 데이터를 읽어 들인다. covid19 &lt;- read.csv(&#39;./covid19.csv&#39;, header = TRUE, na = &#39;-&#39;, strip.white = TRUE, stringsAsFactors = TRUE) colnames(covid19) &lt;- c(&#39;category&#39;, &#39;status&#39;, &#39;date&#39;, &#39;value&#39;) covid19 &lt;- covid19[, c(3, 1, 2, 4)] 코드 설명 read.csv()를 사용하여 csv 파일의 데이터를 읽어 오는데 csv 파일의 첫줄은 헤더 줄로 설정(header = TRUE), ’-’로 기록된 데이터는 NA로 설정(na = '-'), 빈칸은 제거(strip.white = TRUE), 문자열은 factor로 설정(stringsAsFactors = TRUE) 컬럼명을 ‘category,’ ‘status,’ ‘date,’ ’value’로 설정 데이터프레임을 보기쉽게 하기 위해 컬럼의 순서를 바꿈 날짜 컬럼을 만들기 위해 date 컬럼의 데이터를 date 클래스로 바꾼다. covid19$date &lt;- as.Date(covid19$date, &quot;%Y. %m. %d&quot;) 코드 설명 읽어들인 데이터의 date 컬럼의 데이터 클래스를 바꾸기 위해 as.Date()를 사용하는데 문자열 형태가 date 클래스의 기본형태가 아니기 때문에 R이 년월일을 제대로 읽을 수 있도록 format 매개변수를 사용하여 문자열 형태에서 날짜 정보를 추출하기 위한 정보(‘%Y. %m. %d’)를 전달 읽어 들인 데이터 중에 연령대별 데이터만 사용하기 위해 category 컬럼에서 ’세’를 포함한 행만 선택하는데 지역구분중에 ’세종’이 있기 때문에 ’세종’만 추가적으로 제외한다.그 다음 데이터에 NA로 기록된 결측치를 처리한다. 결측치를 처리하는 방법으로 여러가지가 있지만 여기서는 일단 0을 넣어주는 방법으로 결측치를 처리하였다. covid19 &lt;- covid19 %&gt;% filter(grepl(&#39;세&#39;, category)) %&gt;% filter(category != &#39;세종&#39;) covid19$value &lt;- ifelse(is.na(covid19$value), 0, covid19$value) 코드 설명 grepl()은 문자열에서 특정 문자가 존재하면 TRUE를 반환하는 함수임. category에서 ’세’문자가 존재하는 행을 골라내고, 다시 그 결과중에 ’세종’이 아닌 행만 골라내서 covid19에 저장함 is.na()로 covid1$value이 NA인지 검사하고 만약(ifelse) NA라면 0을 넣고 아니면 원래값(covid19$value)을 넣어 줌. 이제 사용해야할 데이터의 처리가 완료되었다. 시계열 데이터 처리에는 긴(long) 형태의 데이터보다는 넓은(wide) 형태의 데이터가 좋기 때문에 spread()를 사용하여 긴 형태를 좁은 형태로 바꾸었다. covid19 &lt;- tidyr::spread(covid19, category, value) 코드 설명 covid19 데이터프레임의 category의 변수들을 컬럼화하고 해당 컬럼에 넣을 데이터는 value로 채워 넣음 데이터 정리가 다 끝났으므로 ts, xts, tsibble 객체로 변환한다. covid19.ts &lt;- ts(covid19[, 2:10], frequency = 365) covid19.xts &lt;- as.xts(covid19[, 3:10], order.by = covid19$date) covid19.tsibble &lt;- as_tsibble(covid19, index = date) 코드 설명 ts()를 사용하여 covid19를 ts로 변환하는데 covid19의 두번째부터 10번째컬럼(covid19[, 2:10])까지를 사용하고 일별 데이터이기 때문에 시계열 주기를 365로 설정(frequency = 365) xts()를 사용하여 covid19를 xts로 변환하는데 covid19의 세번째부터 10번째컬럼(covid19[, 3:10])까지를 사용하고 시간인덱스를 covid19$date로 설정(order.by = covid19\\$date) as_tsibble()을 사용하여 covid19를 tsibble로 변환하는데 시간인덱스를 date로 설정(index = date) https://kess.kedi.re.kr/userfile/6711778 https://kosis.kr/statisticsList/statisticsListIndex.do?parentId=D.1&amp;menuId=M_01_01&amp;vwcd=MT_ZTITLE&amp;parmTabId=M_01_01&amp;entrType=btn#content-group https://kosis.kr/covid/covid_index.do "]]
=======
[["index.html", "Untitled Chapter 1 시계열 데이터", " Untitled 이기준1 2021-03-02 Chapter 1 시계열 데이터 우리는 연도별 학생수, 날짜별 기온 변화 등과 같이 시간의 흐름에 따라 수집된 데이터를 흔히 볼 수 있다. 특히 가장 흔하게 볼 수 있는 시계열 데이터는 주식시장에서 볼 수 있는데 주식에 관련된 대부분의 데이터가 시계열 데이터이다. 시계열 데이터는 과거 시간의 흐름에 따라 데이터를 확인하고 앞으로 데이터가 어떻게 흘러갈껀가를 예측하기 위해 사용된다. 지금까지의 시계열 데이터를 활용하는 사례중에 우리 곁에 가장 가까이서 많이 쓰는 사례는 뭐니뭐니해도 우리나라의 계절 절기가 아닐까 한다. 우리나라 달력에는 입동, 우수, 초복 등 날씨가 변경되는 각종 절기가 표현되는데 우리 조상들은 오랜 시간동안 1년 중 시간의 변화에 따라 기후의 변화를 파악했다. 이를 절기로 기록했고 이를 통해 기후의 변화를 예측했다. 지금도 이런 시간적 변화에 따라 발생하는 데이터의 변화량을 파악하는 응용이 많이 있는데, 특히 경제지표 예측, 상품 수요 예측, 관광객 수요 예측, 전기 수요 예측 등과 같이 경제, 경영 분야뿐만 아니라 많은 산업에서 많이 사용되고 있다. 이와 같이 시계열 데이터는 과거의 데이터 패턴을 분석하여 유사한 데이터 흐름이 지속된다는 가정하에 미래 특정한 기간동안의 데이터 흐름을 분석하기 위해 사용되고 있다. 특히 시간적 변화에 따라 앞으로의 결과를 예측하는 것은 정부의 정책을 수립하는데, 기업에서 비지니스 전략을 수립하는 과정에서 많이 사용되고 있기 때문에 시계열 데이터에 대한 중요성이 매우 높다. 최근 머신러닝이 발달함에 따라 데이터를 기반으로 예측하는 알고리즘들이 많이 소개되고 사용되고 있다. 그 알고리즘들은 지도학습(Supervised Learning), 비지도학습(Unsupervised Learning), 강화학습(Reinforcement learning) 등으로 분류한다. 이런 알고리즘을 사용하여 모델을 생성하고 새로운 데이터가 주어졌을때 해당 모델을 통해 예측 값을 산출해내는 작업을 수행한다. 그러나 시계열 데이터를 위한 모델은 지도학습, 비지도학습, 강화학습의 범주에 포함시키지 않는다. 하지만 Azure, AWS, H2O와 같은 머신러닝 플랫폼에서는 대부분 시계열 분석을 위한 알고리즘을 포함하고 있고 맥킨지에 의하면 시계열 데이터의 가치는 텍스트나 오디오, 비디오보다 높다고 평가하고 있다.2 이와 같이 중요한 시계열 데이터의 모델링과 예측방법은 최근 머신러닝 알고리즘을 시계열 데이터에 적용하여 미래 예측을 하는 방법들이 속속 소개되고 있고 Facebook에서는 자사에서 개발한 시계열 데이터 분석 알고리즘(Prophet)을 소개하는 등 시계열 데이터에 대한 예측 알고리즘도 발전하고 있다. 이제 당신은 시계열 데이터를 저장하고, 시각화하고, 핸들링하고, 모델링하고, 예측하는 여정을 시작하게 된다. 국가교육통계연구본부장, standard@kedi.re.kr https://www.mckinsey.com/~/media/mckinsey/featured%20insights/artificial%20intelligence/notes%20from%20the%20ai%20frontier%20applications%20and%20value%20of%20deep%20learning/notes-from-the-ai-frontier-insights-from-hundreds-of-use-cases-discussion-paper.ashx "],["시계열-데이터란.html", "1.1 시계열 데이터란?", " 1.1 시계열 데이터란? 시계열(Time Series) 데이터는 일정한 시간에 따른 순차적 정보량을 기록한 데이터이다 . 기록되는 순차적 정보량은 여러 측정치가 가능한데 대부분의 경우 가격, 온도, 인구수 등 수치적 측정치나 특성(Feature) 등이 기록되지만 이들을 핸들링하는 인덱스는 시간형 타입으로 설정되거나 시간을 나타낼 수 있는 타입으로 설정되어야 한다. 사실 시계열 데이터이든 관찰치 데이터이든 데이터를 예측한다는 것은 데이터간의 특정한 패턴을 찾아내고 이 패턴이 반복될 경우 패턴의 결과를 미리 산출하는 과정이다. 빅데이터의 사례를 얘기할 때 빠지지 않고 얘기나오는 미국의 ’Target’의 미성년 고객에게 보낸 임신용품 쿠폰 사례를 봐도 그렇다. 타겟에서 무향티수, 마그네슘 보충재를 사는 고객들은 임신중일 확률이 높다는 구매 패턴을 가지고 있었기 때문이다. 이렇게 데이터간의 패턴을 어떻게 뽑아낼 것이냐가 예측 성능을 좌우한다. 그렇다면 시계열 데이터는 어떤 특성을 가지고 패턴을 어떻게 뽑아내야 할까? 시계열 데이터는 데이터에서 예측가능한 특성을 뽑아내고 예측 불가능한 특성을 제거하는 과정을 거쳐서 예측 모델을 생성한다. 이는 마치 껍질을 벗겨내고 알맹이를 취하는 탈곡과정과 유사하다. 향후 미래 예측에 사용되는 패턴이 담겨있는 알맹이를 뽑아내고 예측이 불가능한 찌꺼기인 백색잡음을 제거하는 형태로 예측은 진행된다. www.freepik.com 따라서 시계열 데이터는 다른 데이터 셋과 달리 시간이 하나의 특성이기 때문에 다른 데이터에서 보이지 않는 다음과 같은 몇가지 특성을 지닌다. "],["시계열-데이터의-특성.html", "1.2 시계열 데이터의 특성", " 1.2 시계열 데이터의 특성 1.2.1 고정된 시간 독립변수 일반적으로 데이터 분석시에는 독립변수와 종속변수간의 관계를 분석하는 것이 목적인 경우가 많다. 종속변수의 행동을 예측하기 위해서는 하나 혹은 여러개의 독립변수가 필요하고 이들간의 관계성을 도출함으로서 향후 독립변수에 따라 종속변수의 예측값을 도출한다. 예를 들어 자동차의 속도가 빠를수록 제동거리는 길수밖에 없다. 이를 그래프 상으로 보면 양의 상관관계를 보이는데 이 경우는 제동거리를 종속변수로, 자동차 속도를 독립변수로 분석할 수 있다. 그러나 시계열 데이터는 독립변수가 시간으로 고정된다. 따라서 시계열 데이터는 타 변수와의 상관관계 없이 분석이 된다는 점에서 다른 데이터와의 차이가 있다. 시계열 데이터를 구축하는데 중요한 요소는 시간 간격이 동일해야 한다는 점이다. 예를 들어 매월마다 측정된 어떤 물품의 판매량이 있다면 데이터 전체적으로 매월 데이터가 기록되어야 하지만 특정 기간동안 주간 데이터로 기록된다던지 분기데이터로 기록되면 올바른 시계열 데이터로 볼 수 없다. 매시간, 매일, 매월, 매분기, 매년 등 데이터가 기록된 간격이 일정해야 시계열 데이터를 다루기 위한 다양한 함수들에 적용이 가능함. 이것은 간격이 일정하더라도 결측치에 의해 모든 간격의 데이터가 기록되지 않은 것과는 다르다. 결측치가 있는 데이터는 시계열 데이터의 plot을 만들고 EDA(Exploratory Data Analysis)를 수행할 수는 있으나 모델링을 하고 예측에 적용하기 위해서는 결측치를 적절히 처리하는 것이 중요하다. 1.2.2 자기 상관관계 최근 우리나라는 저출산 고령화 사회에 접어들었다고 한다. 우리나라의 출생아수는 지속적으로 줄고 있는 추세가 몇년째 계속되고 있다고 뉴스에서 보도되고 있다. 작년에 비해 올해가 줄었고 재작년에 비해 작년이 줄었다. 우리나라에 특별한 사건이나 이슈가 발생하지 않는 이상 이러한 추세는 반복될 것이다. 이와 같이 과거의 데이터가 현재의 데이터에 영향을 주는 경향을 자기상관이라고 한다. 시계열 데이터는 일련의 시간간의 흐름에 따라 기록되는 데이터들의 집합이기 때문에 인접한 시간의 데이터간의 상관관계가 존재하는 경우가 많다. 일반적으로 상관관계는 서로 다른 두개의 변수간의 영향성을 살펴본다. 기온과 아이스크림 판매량, 자동차 속도와 제동거리 등과 같이 한 변수가 움직일때 다른 변수가 어떻게 움직이는지를 살펴보는 것이 상관관계이고 이를 수치화하는 것이 상관계수이다. 하지만 자기 상관관계는 자기 자신의 n번째 과거 데이터(n차 지연(lag) 데이터)와 현재 데이터간의 상관관계를 의미한다. 상관관계가 존재한다는 것은 n차 지연데이터와 현재 데이터간의 상관계수가 높다는 점을 의미한다. 아래 그림의 왼쪽 표는 1999년부터 2020년까지의 우리나라 유,초,중,고등학교의 전체 학생수를 나타내고 있다. 1년전 전체 학생수와 전체 학생수에 대한 plot은 오른쪽의 plot이다. 이 plot을 보면 1년전 학생수가 증가하면 전체 학생수가 증가하는 매우 관계성이 높은 plot이 나타난다. 이는 전체 학생수는 자기 자신의 데이터와의 상관성, 즉 자기 상관성이 매우 높다고 말할 수 있다. 1.2.3 추세 경향성(Trend) 시계열 데이터는 장기적으로 점차 증가하거나 점차 감소하는 추세에 대한 경향성을 보이는 경우가 있다. 사실 시계열 데이터 분석에서 우리가 가장 원하는 것이 데이터가 그동안 어떤 추세를 보였고 이 추세가 유지된다면 앞으로 어떻게 미래를 대응해야 할지를 결정하기 위한 정보이다. 따라서 이 추세 경향성을 어떻게 찾아낼 것인가가 시계열 분석에서 중요한 부분이다. 아래의 그림은 위에서 살펴본 우리나라 총학생수의 plot이다. plot에서도 보다시피 우리나라의 총 학생수는 전반적으로 감소하는 추세에 있다. 2003년에서부터 2007년까지는 추세가 유지되었지만 이후 급격히 감소하는 추세가 있음을 눈으로 쉽게 확인할 수 있다. 추세 경향성은 시간의 흐름에 따라 나타나는 인구, 경기, 기술, 환경 등의 변화에 따라 영향을 받는 데이터의 중장기적인 지속적 데이터의 변동을 말하는데 시간축에 따라 발생하는 데이터 변동에 대한 그래프에서 확인이 가능하다. 이 추세변동성을 해석할때는 변동성을 단순한 선형회귀로 단정하여 예측하지 않도록 주의해야 한다. 추세 경향성을 선형회귀로 분석할 때는 앞서 언급한 자기 상관관계가 있는지를 먼저 확인한 후에 적용해야 한다. 자기 상관관계가 있는 경우에는 선형회귀외에 다른 시계열 분석방법을 함께 고려하고 성능을 분석하여 더 좋은 모델을 사용하도록 해야한다. 1.2.4 계절성(Seasonality), 순환성(Cyclic) 시계열 데이터는 중장기적인 추세경향성외에 데이터가 달력(Calender)상의 날짜나 기간에 따라 주기적으로 변화하거나 장기적인 시간의 흐름에 따라 오르거나 내리는 추세가 반복되는 변동성을 가지는 경우가 있다. 달력 상의 날짜나 기간에 따라 데이터가 변동되는 경우의 대표적인 예가 아이스크림 판매량, 익사자자의 수, 발렌타인데이의 초콜렛 판매량, 크리스마스 기간의 소매 판매량, 설, 추석의 고속도로 이용자수 등이다. 이는 앞으로 사용할 우리나라 월별 전체 취업자수 plot에서도 명확하게 나타난다. 아래의 그림은 2013년부터 2020년까지의 우리나라의 월별 신규 취업자수 plot이다. plot을 보면 매년 겨울에는 신규 취업자수는 전반적으로 줄어들고 봄부터 증가하고 여름에 잠시 줄어들며 가을에 다소 회복했다가 다시 겨울이 시작하면서 줄어드는 계절성을 보인다. 이와 같이 계절성은 봄, 여름, 가을, 겨울과 같은 계절, 일, 주, 월, 분기와 같은 기간의 변화에 따라 주기적으로 변동하는 시계열 성질을 말한다. 이에 비해 순환성은 일정한 기간의 특징없이 데이터의 변동성이 반복되거나 1년을 넘겨 주기적으로 발생하는 데이터의 반복성을 말한다. 계절성과 순환성은 혼동되는 경우가 많다. 계절성은 주기가 고정된 기간에 대한 순환성이고 순환성은 변동적 기간에 대한 순환성이고 일반적으로 순환성의 주기가 계절성 주기보다 길기 때문에 계절성은 언제쯤 데이터 피크(Peak)가 나타날지 예측이 가능하나 순환성은 데이터 피크에 대한 예측이 어려운 성질이 있다. 1.2.5 불확실성(Uncertainty) 우리는 아침마다 일기예보를 확인 한다. 일기예보는 오늘 비가 올 확률을 알려준다 .일기예보를 확인한 사람들은 비 올 확률을 보고 우산을 가져갈지 안가져갈지에 대한 판단을 한다. 기상청에서는 우리에게 주는 정보는 결국 불확실성인 것이다. 아래의 그림은 기상청에서 제공하는 태풍의 경로3이다. 태풍이 앞으로 어떻게 이동할지를 시간대별로 예측한 그림으로 현재 서귀포 부근에 상륙한 태풍은 부산, 독도를 지나 일본 삿포로로 빠져나갈 것이라고 예측하고 있다. 하지만 그 태풍의 경로를 둘러싸고 있는 범위를 보면 태풍위치 70% 확률 반경의 범위가 보인다. 결국 태풍의 경로는 70%의 확률로 그 범위안에 있을것이라는 것이다. 여기서 하나 주의해아할 것은 태풍의 경로가 70% 범위라는 것은 태풍이 그 경로를 지나갈 확률이 70%라는 것이 아니고 수많은 예측을 수행했을 때 태풍의 경로 예측치의 70%가 해당 범위내에 있다는 것이다. 좀 이해하기 어렵고 말장난 같을 수 있을 것이다. 하지만 두가지 모두에서 중요한 것은 ‘미래 예측치는 현재로써는 정확히 모른다’는 것이다. 따라서 시계열 모델의 해석에는 반드시 불확실성에 대한 고려가 반드시 수반되어야 한다. 시계열 분석을 통해 예측된 미래 데이터는 사용된 모델에 적합한 확률 분포 모델(Probability Distribution)을 통한 신뢰구간이 같이 제공되어 평가되어야 한다. 일반적으로 미래 예측을 말할 때에는 앞서 말한 예측분포(forecast distribution)의 평균을 말하는 경우가 많다 이를 나타낼 때는 “모자 기호(hat)”을 붙여서 \\(\\hat{x}\\) 로 표현하는 경우가 많다. 하지만 예측분포의 중앙값을 사용하는 경우도 있다. 대부분의 시계열 모델은 불확실성을 표현하기 위한 신뢰구간을 제공한다. 시계열 예측의 신뢰구간의 이해에서 가장 먼저 생각해야하는 것은 시계열 예측은 예측 기간이 길수록 예측의 신뢰구간이 점점 넓어진다는 것이다. 결국 먼 미래의 예측이 더 힘들고 어렵다는 의미이다. https://www.weather.go.kr/HELP/html/help_tpi001.jsp "]]
>>>>>>> ec6ccd86dfb64c15fcfa2f13539595210c5a93bc
