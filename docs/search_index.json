[["시계열-forecasting-part-iii-시계열-분석-framework.html", "Chapter 7 시계열 forecasting Part III - 시계열 분석 Framework", " Chapter 7 시계열 forecasting Part III - 시계열 분석 Framework 얼마전까지만 해도 시계열 분석을 위해서 다수의 모델을 비교하기 위해서는 각각의 모델을 따로 구축한 후 성능분석 지수들을 비교하여 가장 좋은 모델을 선택하는 것이 일반적이었다. 다행히 forecast 패키지에서 시계열 분석을 위한 많은 모델을 지원하지만 모델을 생성하기 위한 사용법이 다 달라서 모델을 하나하나 만들고 분석해야한다. 하지만 최근의 머신러닝 모델 선택의 추세는 머신러닝 프레임워크 위에서 동일한 인터페이스로 여러 모델을 동시에 만들고 이에 대한 성능분석 테이블을 만들어서 제공하는 방법을 사용한다. 최근의 시계열 모델링에서도 이러한 흐름이 적용되는데 시계열 분석 전용 프레임워크들이 속속 소개되고 있다. 이번 장에서는 시계열 분석 전용 프레임워크인 fable과 modeltime으로 여러 시계열 모델을 생성하고 분석하는 방법을 소개하고자 한다. "],["성능분석-지수.html", "7.1 성능분석 지수", " 7.1 성능분석 지수 시계열 분석 모델간의 성능을 분석하기 위해서는 예측 정확도 평가 판단용 지수들을 사용하여야 한다. 대부분의 예측 정확도 평가 지수는 시계열 모델을 통해 생성된 모델의 적합값과 실제값의 차이인 오차항을 평가하여 산출된다. forecast 패키지에서 제공하는 accuracy() 함수를 사용하면 간단히 여러 성능지수를 간단히 구할 수 있다. 7.1.1 RMSE(Root Means Squaread Error) RMSE는 성능평가에 대표적으로 쓰이는 지수이다. 오차항(Error)을 제곱(Squared)한 값들의 평균(Mean)을 제곱근(Root)한 값이다. 오차항을 제곱하기 때문에 큰 오차는 더욱 크게 계산되는 패널티가 존재한다. 산출 방법은 RMSE의 뒤에서부터 차근히 계산해 나가면 구할 수 있다. 오차항을 대상으로 산출한 지수이기 때문에 이 수치가 작을수록 더 좋은 모델로 볼 수 있다. ets &lt;- ets(students.total.ts[,1]) arima &lt;- auto.arima(students.total.ts[,1]) (students.total.ts[,1] - fitted(ets))^2 %&gt;% mean() %&gt;% sqrt() ## [1] 65403.96 forecast::accuracy(ets) ## ME RMSE MAE MPE MAPE MASE ## Training set -13547.67 65403.96 42008.54 -0.1655554 0.523083 0.326878 ## ACF1 ## Training set 0.007506032 (students.total.ts[,1] - fitted(arima))^2 %&gt;% mean() %&gt;% sqrt() ## [1] 31836.18 forecast::accuracy(arima) ## ME RMSE MAE MPE MAPE MASE ## Training set 318.6795 31836.18 25035.55 0.01478297 0.3325939 0.1948073 ## ACF1 ## Training set -0.01551196 7.1.2 MAE MAE는 오차항(Error)의 절대값(Absolute)들의 평균(Mean)값이다. 오차항들은 양수 또는 음수로 나타나기 때문에 부호를 뗀 절대값의 평균으로 실제값과 모델에 의해 산출된 값의 평균으로 이해하면 쉽게 이해된다. 오차항을 대상으로 산출한 지수이기 때문에 작을수록 더 좋은 모델로 볼 수 있다 (students.total.ts[,1] - fitted(ets)) %&gt;% abs() %&gt;% mean() ## [1] 42008.54 (students.total.ts[,1] - fitted(arima)) %&gt;% abs() %&gt;% mean() ## [1] 25035.55 7.1.3 MPE MPE는 오차항(Error)의 백분률(Precentage)의 평균(Mean)을 의미한다. 오차항의 백분률은 실제값에서 적합값을 뺀 오차항을 실제값으로 나눈 값이다. 실제값이 101이고 적합값이 100이라면 101-100 = 1이 오차항이고 이 오차항 1을 실제값 101로 나눈 값(1/101)이 오차항의 백분률이다. 이들 값의 평균이 MPE값이다. 백분률의 평균값이기 때문에 1보다 작은 값이며 제곱이나 절대값이 취해지지 않았기 때문에 값의 크기로 우수 모델을 나눌 수 없다. 다만 이 지수는 모델에 비해 실제값이 위쪽방향(overestimate)에 위치하는지, 아래쪽 방향(underestimate)에 위치하는지에 대한 판단에 주로 사용된다.2 ((students.total.ts[,1] - fitted(ets)) / students.total.ts[,1] * 100) %&gt;% mean() ## [1] -0.1655554 ((students.total.ts[,1] - fitted(arima)) / students.total.ts[,1] * 100) %&gt;% mean() ## [1] 0.01478297 7.1.4 MAPE MAPE는 오차항(Error)의 백분률(Precentage)의 절대값의 평균(Mean)을 의미한다. 앞의 MPE값과 유사하게 산출되는 값이지만 이 값은 MAE값과 더 관계가 있다. MAE 값은 오차항의 절대값 평균이지만 MAPE는 오차항 백분률의 절대값 평균이기 때문이다. 예를 들자면 두개의 오차항이 모두 1이라하더라도 실제값이 10일때 오차항 1과 실제값이 100일때 오차항 1은 다르기 때문이다. MAE를 구할때는 실제값에 관련없이 1이라는 값은 동일하게 계산되지만 MAPE에서는 동일한 1값이라도 실제값에 따라 다르게 계산된다. 이 값은 앞의 RMSE와 MAE와 가장 다른 점은 백분율을 사용하기 때문에 결과값들이 Y축 값에 의존적이지 않다는 점이다. 실제값과 적합값이 같으면(정확하게 예측하면) 분자가 0이 되기 때문에 MPE값은 0이다. 결국 0과 가까운 값일 수록 예측 성능이 우수하다고 평가할 수 있다. 다만 MPE나 MAPE 모두 치명적인 약점을 지니는데 실제값이 0인 경우 산출이 어렵다는 점(오차항을 실제값으로 나눠야하는데 분모가 0이 되면 값을 구할수 없으니까)과 실제값이 매우 작은 경우에는 MAPE값이 매우 커질 수 있다는 점이다. ((students.total.ts[,1] - fitted(ets)) / students.total.ts[,1] * 100) %&gt;% abs() %&gt;% mean() ## [1] 0.523083 ((students.total.ts[,1] - fitted(arima)) / students.total.ts[,1] * 100) %&gt;% abs() %&gt;% mean() ## [1] 0.3325939 https://www.dataquest.io/blog/understanding-regression-error-metrics/ "],["fable.html", "7.2 fable", " 7.2 fable fable is designed for tsibble objects, forecast is designed for ts objects. fable handles many time series at a time, forecast handles one time series at a time. fable can fit multiple models at once, forecast fits one model at a time. forecast produces point forecasts and prediction intervals. fable produces point forecasts and distribution forecasts. In fable, you can get prediction intervals from the forecast object using hilo() and in plots using autoplot(). fable handles ensemble forecasting easily whereas forecast has no facilities for ensembles. fable has a more consistent interface with every model specified as a formula. Automated modelling in fable is obtained by simply not specifying the right hand side of the formula. This was shown in the ARIMA() and ETS() functions here. 7.2.1 미래 학생수 예측 split &lt;- floor(nrow(students.tsibble) * 0.8) n &lt;- nrow(students.tsibble) students.tsibble.tr &lt;- students.tsibble[1:split, ] students.tsibble.test &lt;- students.tsibble[(split+1):n, ] library(fable) ## Warning: package &#39;fable&#39; was built under R version 4.0.3 ## Loading required package: fabletools ## Warning: package &#39;fabletools&#39; was built under R version 4.0.3 ## ## Attaching package: &#39;fabletools&#39; ## The following objects are masked from &#39;package:forecast&#39;: ## ## accuracy, forecast library(fable.prophet) ## Warning: package &#39;fable.prophet&#39; was built under R version 4.0.3 ## Loading required package: Rcpp model.fable.studetns &lt;- students.tsibble.tr %&gt;% model(ets = ETS(학생수계), arima = ARIMA(학생수계), naive = NAIVE(학생수계), tslm = TSLM(학생수계), rw = RW(학생수계), mean = MEAN(학생수계), nnetar = NNETAR(학생수계), prophet = prophet(학생수계) ) ## Warning: 5 errors (1 unique) encountered for prophet ## [5] &#39;origin&#39; must be supplied forecast.fable.students &lt;- model.fable.studetns %&gt;% forecast(h = 10) forecast.fable.students %&gt;% autoplot(students.tsibble, level = NULL) ## Warning: Removed 50 row(s) containing missing values (geom_path). forecast.fable.students %&gt;% accuracy(students.tsibble.test) %&gt;% arrange(RMSE) ## Warning: The future dataset is incomplete, incomplete out-of-sample data will be treated as missing. ## 10 observations are missing between 2021 and 2030 ## # A tibble: 40 x 11 ## .model 지역규모 .type ME RMSE MAE MPE MAPE MASE RMSSE ## &lt;chr&gt; &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ets 특별/광역시~ Test -3.19e3 12018. 11184. -0.111 0.451 NaN NaN ## 2 arima 특별/광역시~ Test -5.84e4 63489. 58439. -2.37 2.37 NaN NaN ## 3 nnetar 특별/광역시~ Test -2.33e5 261541. 233453. -9.53 9.53 NaN NaN ## 4 naive 특별/광역시~ Test -2.94e5 320533. 293517. -11.9 11.9 NaN NaN ## 5 rw 특별/광역시~ Test -2.94e5 320533. 293517. -11.9 11.9 NaN NaN ## 6 tslm 특별/광역시~ Test -1.02e6 1030881. 1022804. -41.0 41.0 NaN NaN ## 7 mean 특별/광역시~ Test -1.02e6 1030881. 1022804. -41.0 41.0 NaN NaN ## 8 arima 계 Test NaN NaN NaN NaN NaN NaN NaN ## 9 arima 면지역 Test NaN NaN NaN NaN NaN NaN NaN ## 10 arima 시 Test NaN NaN NaN NaN NaN NaN NaN ## # ... with 30 more rows, and 1 more variable: ACF1 &lt;dbl&gt; best.model.fable.students &lt;- model.fable.studetns %&gt;% select(ets, prophet) best.model.fable.students %&gt;% forecast(h = 10) %&gt;% autoplot(students.tsibble, alpha = 0.6) + autolayer(fitted(best.model.fable.students)) + geom_point(aes(x = 연도, y = 학생수계)) ## Plot variable not specified, automatically selected `.vars = .fitted` ## Warning in max(ids, na.rm = TRUE): max에 전달되는 인자들 중 누락이 있어 -Inf를 ## 반환합니다 ## Warning in max(ids, na.rm = TRUE): max에 전달되는 인자들 중 누락이 있어 -Inf를 ## 반환합니다 ## Warning in max(ids, na.rm = TRUE): max에 전달되는 인자들 중 누락이 있어 -Inf를 ## 반환합니다 ## Warning in max(ids, na.rm = TRUE): max에 전달되는 인자들 중 누락이 있어 -Inf를 ## 반환합니다 ## Warning in max(ids, na.rm = TRUE): max에 전달되는 인자들 중 누락이 있어 -Inf를 ## 반환합니다 ## Warning in max(ids, na.rm = TRUE): max에 전달되는 인자들 중 누락이 있어 -Inf를 ## 반환합니다 ## Warning in max(ids, na.rm = TRUE): max에 전달되는 인자들 중 누락이 있어 -Inf를 ## 반환합니다 ## Warning in max(ids, na.rm = TRUE): max에 전달되는 인자들 중 누락이 있어 -Inf를 ## 반환합니다 ## Warning in max(ids, na.rm = TRUE): max에 전달되는 인자들 중 누락이 있어 -Inf를 ## 반환합니다 ## Warning in max(ids, na.rm = TRUE): max에 전달되는 인자들 중 누락이 있어 -Inf를 ## 반환합니다 ## Warning: Removed 50 row(s) containing missing values (geom_path). ## Warning: Removed 105 row(s) containing missing values (geom_path). 7.2.2 미래 취업자수 예측 employees$yearmonth &lt;- yearmonth(employees$time) employees.tsibble &lt;- as_tsibble(employees, index = yearmonth) split &lt;- floor(nrow(employees.tsibble) * 0.9) n &lt;- nrow(employees.tsibble) employees.tsibble.tr &lt;- employees.tsibble[1:split, ] employees.tsibble.test &lt;- employees.tsibble[(split+1):n, ] model.fable.employees &lt;- employees.tsibble.tr %&gt;% model(ets = ETS(total), arima = ARIMA(total), naive = NAIVE(total), tslm = TSLM(total), rw = RW(total), mean = MEAN(total), nnetar = NNETAR(total), prophet = prophet(total) ) forecast.fable.employees &lt;- model.fable.employees %&gt;% forecast(h = 24) forecast.fable.employees %&gt;% autoplot(employees.tsibble, level = NULL) forecast.fable.employees %&gt;% accuracy(employees.tsibble.test) %&gt;% arrange(RMSE) ## Warning: The future dataset is incomplete, incomplete out-of-sample data will be treated as missing. ## 14 observations are missing between 2021 1 and 2022 2 ## # A tibble: 8 x 10 ## .model .type ME RMSE MAE MPE MAPE MASE RMSSE ACF1 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 naive Test 83.4 259. 247. 0.301 0.917 NaN NaN 0.203 ## 2 rw Test 83.4 259. 247. 0.301 0.917 NaN NaN 0.203 ## 3 mean Test 560. 611. 560. 2.07 2.07 NaN NaN 0.203 ## 4 tslm Test 560. 611. 560. 2.07 2.07 NaN NaN 0.203 ## 5 ets Test -730. 740. 730. -2.71 2.71 NaN NaN -0.0628 ## 6 prophet Test -827. 839. 827. -3.07 3.07 NaN NaN -0.397 ## 7 arima Test -833. 840. 833. -3.10 3.10 NaN NaN -0.289 ## 8 nnetar Test -833. 920. 833. -3.10 3.10 NaN NaN 0.485 best.model.fable.employees &lt;- model.fable.employees %&gt;% select(naive, rw) best.model.fable.employees %&gt;% forecast(h = 12) %&gt;% autoplot(employees.tsibble, level = NULL, lwd = 1) + autolayer(fitted(best.model.fable.employees), lwd = 1) + geom_point(aes(x = yearmonth, y = total)) + labs(title = &#39;전체 취업자수 예측&#39;, x = &#39;년월&#39;, y = &#39;취업자수&#39;) ## Plot variable not specified, automatically selected `.vars = .fitted` ## Warning: Removed 2 row(s) containing missing values (geom_path). 7.2.3 미래 코로나 확진자수 예측 fill.covid19.by.age.tsibble &lt;- fill_gaps(wide.covid19.by.age.tsibble, `0-9세` = 0) split &lt;- floor(nrow(fill.covid19.by.age.tsibble) * 0.9) n &lt;- nrow(fill.covid19.by.age.tsibble) fill.covid19.by.age.tsibble.tr &lt;- fill.covid19.by.age.tsibble[1:split, ] fill.covid19.by.age.tsibble.test &lt;- fill.covid19.by.age.tsibble[(split+1):n, ] model.covid19.by.age.tsibble &lt;- fill.covid19.by.age.tsibble.tr %&gt;% model(ets = ETS(`0-9세`), arima = ARIMA(`0-9세`), naive = NAIVE(`0-9세`), tslm = TSLM(`0-9세`), rw = RW(`0-9세`), mean = MEAN(`0-9세`), nnetar = NNETAR(`0-9세`), prophet = prophet(`0-9세`) ) forecast.covid19.by.age.tsibble &lt;- model.covid19.by.age.tsibble %&gt;% forecast(h = 120) forecast.covid19.by.age.tsibble %&gt;% autoplot(fill.covid19.by.age.tsibble, level = NULL) forecast.covid19.by.age.tsibble %&gt;% accuracy(fill.covid19.by.age.tsibble.test) %&gt;% arrange(RMSE) ## Warning: The future dataset is incomplete, incomplete out-of-sample data will be treated as missing. ## 89 observations are missing between 2021-02-10 and 2021-05-09 ## # A tibble: 8 x 10 ## .model .type ME RMSE MAE MPE MAPE MASE RMSSE ACF1 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 prophet Test -6.32 10.5 8.89 -38.9 46.6 NaN NaN 0.371 ## 2 naive Test -8.39 11.4 10 -51.7 55.8 NaN NaN 0.234 ## 3 rw Test -8.39 11.4 10 -51.7 55.8 NaN NaN 0.234 ## 4 ets Test -12.4 14.6 13.1 -70.9 72.4 NaN NaN 0.234 ## 5 mean Test 15.6 17.4 15.6 61.8 61.8 NaN NaN 0.234 ## 6 tslm Test 15.6 17.4 15.6 61.8 61.8 NaN NaN 0.234 ## 7 arima Test -16.8 18.7 16.9 -92.1 92.5 NaN NaN 0.281 ## 8 nnetar Test -23.9 25.7 23.9 -126. 126. NaN NaN 0.391 best.model.covid19.by.age.tsibble &lt;- model.covid19.by.age.tsibble %&gt;% select(prophet) best.model.covid19.by.age.tsibble %&gt;% forecast(h = 120) %&gt;% autoplot(fill.covid19.by.age.tsibble, lwd = 1, alpha = 0.6) + autolayer(fitted(best.model.covid19.by.age.tsibble), lwd = 1) + geom_point(aes(x = date, y = `0-9세`)) + labs(title = &#39;코로나 확진자수 예측&#39;, x = &#39;년월일&#39;, y = &#39;확진자수&#39;) ## Plot variable not specified, automatically selected `.vars = .fitted` "],["modeltime-1.html", "7.3 modeltime", " 7.3 modeltime Just follow the modeltime workflow, which is detailed in 6 convenient steps: Collect data and split into training and test sets Create &amp; Fit Multiple Models Add fitted models to a Model Table Calibrate the models to a testing set. Perform Testing Set Forecast &amp; Accuracy Evaluation Refit the models to Full Dataset &amp; Forecast Forward 7.3.1 linear_reg 함수(tidymodels, parsnip, modeltime 패키지) 본 절에서 parship 패키지와 modeltime 패키지를 사용하여 선형 회귀 모델을 생성하는 방법을 소개한다. parsnip 패키지는 머신러닝 패키지인 ‘caret’ 패키지를 개발한 Max Kuhn이 개발한 패키지이다. 이 패키지는 R, Spark, Stan 등의 엔진에서 사용하는 함수들이 함수마다 다른 인수를 사용하기 때문에 사용자들이 사용하기 힘들다는 점에 착안하여 인수 이름을 표준화하여 사용할 수 있는 인터페이스를 제공한다.3 parsnip은 R의 여러 패키지에서 유사한 기능으로 제공하는 함수들을 사용하는 표준화된 접근 방법을 제공하는데 이 패키지를 사용하여 전체적인 머신러닝 모델을 생성하기 위해서는 몇가지 더 필요한 패키지를 사용해야한다. tidymodels(tidy 타입의 모델생성), skim(데이터 탐색), rsample(훈련용, 테스트용 데이터 분리), reciepes(데이터 전처리), yardstick(성능 분석)등의 패키지를 사용하는 방법이 많이 사용되고 있다. 그러나 시계열 모델에서는 tidymodels, modeltime 패키지를 사용할 수 있다. modeltime은 tidymodels 환경에서 시계열 데이터의 예측 프레임워크로 forecast 패키지에서 제공하는 대부분의 예측 방법을 제공하며 facebook에서 개발된 prophet 알고리즘까지 제공한다.4 tidymodels, parsnip, modeltime 패키지를 사용하여 시계열 데이터 선형 회귀 모델은 다음의 순서와 같이 만들 수 있다. 트레이닝 셋과 테스트 셋을 나눈다. (권장되지만 필수는 아니다.) linear_reg(), set_engine(), fit() 함수를 사용하여 선형 회귀모델을 생성한다. 먼저 linear_reg()함수를 통해 선형 회귀분석을 선언한다. 이 후 set_engine() 함수를 사용하여 선형 회귀 모델을 선정하는 계산방법을 지정한다. 아래의 예제에서는 ‘lm’ 방법을 지정함으로써 최소제곱법을 사용하여 선형 회귀 모델을 선정하게 된다. 마지막으로 모델링을 위한 포뮬라와 데이터를 fit() 함수를 통해 전달함으로서 최종 모델이 생성된다.5 생성된 모델을 modeltime_table() 함수에 적용하여 모델 테이블을 생성한다. 향후 설명하겠지만 모델 테이블에 여러 모델을 전달할 수 있는데 모델 테이블에 전달된 각각의 모델은 추후 성능비교 테이블이 제공되기 때문에 여러 모델의 성능을 비교하는데 편리하게 사용될 수 있다 . modeltime_calibrate() 함수를 사용하여 테스트 데이터를 사용하여 모델을 교정한다. 앞서 테스트 셋을 나누지 않은 경우는 전체 데이터 셋을 사용할 수 있다. modeltime_forecast() 함수를 사용하여 미래 데이터를 생성한다. 이후 plot_modeltime_forecast() 함수를 사용하여 plotting을 생성한다. 7.3.2 미래 학생수 예측 library(modeltime) ## Warning: package &#39;modeltime&#39; was built under R version 4.0.3 library(parsnip) ## Warning: package &#39;parsnip&#39; was built under R version 4.0.3 ## ## Attaching package: &#39;parsnip&#39; ## The following object is masked from &#39;package:fabletools&#39;: ## ## null_model library(tidymodels) ## Warning: package &#39;tidymodels&#39; was built under R version 4.0.3 ## -- Attaching packages -------------------------------------- tidymodels 0.1.2 -- ##  broom 0.7.4  rsample 0.0.8 ##  dials 0.0.9  tune 0.1.2 ##  infer 0.5.4  workflows 0.2.1 ##  modeldata 0.1.0  yardstick 0.0.7 ##  recipes 0.1.15 ## Warning: package &#39;broom&#39; was built under R version 4.0.3 ## Warning: package &#39;dials&#39; was built under R version 4.0.3 ## Warning: package &#39;infer&#39; was built under R version 4.0.3 ## Warning: package &#39;modeldata&#39; was built under R version 4.0.3 ## Warning: package &#39;recipes&#39; was built under R version 4.0.3 ## Warning: package &#39;rsample&#39; was built under R version 4.0.3 ## Warning: package &#39;tune&#39; was built under R version 4.0.3 ## Warning: package &#39;workflows&#39; was built under R version 4.0.3 ## Warning: package &#39;yardstick&#39; was built under R version 4.0.3 ## -- Conflicts ----------------------------------------- tidymodels_conflicts() -- ## x yardstick::accuracy() masks fabletools::accuracy(), forecast::accuracy() ## x scales::discard() masks purrr::discard() ## x dplyr::filter() masks stats::filter() ## x xts::first() masks dplyr::first() ## x recipes::fixed() masks stringr::fixed() ## x infer::generate() masks fabletools::generate() ## x dplyr::lag() masks stats::lag() ## x xts::last() masks dplyr::last() ## x parsnip::null_model() masks fabletools::null_model() ## x rsample::populate() masks Rcpp::populate() ## x yardstick::spec() masks readr::spec() ## x recipes::step() masks stats::step() ### 트레이닝 셋과 테스트 셋을 나눈다 students.total$연도 &lt;- as.Date(paste0(students.total$연도, &#39;-01-01&#39;)) splits.students &lt;- initial_time_split(students.total, prop = 0.8) model_fit_arima &lt;- arima_reg() %&gt;% set_engine(engine = &quot;auto_arima&quot;) %&gt;% fit(학생수계 ~ 연도, data = training(splits.students)) ## frequency = 5 observations per 5 years model_fit_ets &lt;- exp_smoothing() %&gt;% set_engine(engine = &quot;ets&quot;) %&gt;% fit(학생수계 ~ 연도, data = training(splits.students)) ## frequency = 5 observations per 5 years model_fit_prophet &lt;- prophet_reg() %&gt;% set_engine(engine = &quot;prophet&quot;) %&gt;% fit(학생수계 ~ 연도, data = training(splits.students)) ## Disabling weekly seasonality. Run prophet with weekly.seasonality=TRUE to override this. ## Disabling daily seasonality. Run prophet with daily.seasonality=TRUE to override this. ## n.changepoints greater than number of observations. Using 12 model_fit_lm &lt;- linear_reg() %&gt;% set_engine(&quot;lm&quot;) %&gt;% fit(학생수계 ~ as.numeric(연도), data = training(splits.students)) model_fit_nnetar &lt;- nnetar_reg() %&gt;% set_engine(&quot;nnetar&quot;) %&gt;% fit(학생수계 ~ 연도, data = training(splits.students)) ## frequency = 5 observations per 5 years model_fit_tbats &lt;- seasonal_reg() %&gt;% set_engine(&quot;tbats&quot;) %&gt;% fit(학생수계 ~ 연도, data = training(splits.students)) ## frequency = 5 observations per 5 years (models_tbl &lt;- modeltime_table( model_fit_arima, model_fit_ets, model_fit_prophet, model_fit_lm, model_fit_nnetar, model_fit_tbats)) ## # Modeltime Table ## # A tibble: 6 x 3 ## .model_id .model .model_desc ## &lt;int&gt; &lt;list&gt; &lt;chr&gt; ## 1 1 &lt;fit[+]&gt; ARIMA(1,2,0) ## 2 2 &lt;fit[+]&gt; ETS(A,A,N) ## 3 3 &lt;fit[+]&gt; PROPHET ## 4 4 &lt;fit[+]&gt; LM ## 5 5 &lt;fit[+]&gt; NNAR(1,1,10)[5] ## 6 6 &lt;fit[+]&gt; BATS(0.732, {0,0}, 1, -) (calibration_tbl &lt;- models_tbl %&gt;% modeltime_calibrate(new_data = testing(splits.students))) ## # Modeltime Table ## # A tibble: 6 x 5 ## .model_id .model .model_desc .type .calibration_data ## &lt;int&gt; &lt;list&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; ## 1 1 &lt;fit[+]&gt; ARIMA(1,2,0) Test &lt;tibble [5 x 4]&gt; ## 2 2 &lt;fit[+]&gt; ETS(A,A,N) Test &lt;tibble [5 x 4]&gt; ## 3 3 &lt;fit[+]&gt; PROPHET Test &lt;tibble [5 x 4]&gt; ## 4 4 &lt;fit[+]&gt; LM Test &lt;tibble [5 x 4]&gt; ## 5 5 &lt;fit[+]&gt; NNAR(1,1,10)[5] Test &lt;tibble [5 x 4]&gt; ## 6 6 &lt;fit[+]&gt; BATS(0.732, {0,0}, 1, -) Test &lt;tibble [5 x 4]&gt; calibration_tbl %&gt;% modeltime_forecast( new_data = testing(splits.students), actual_data = students.total ) %&gt;% plot_modeltime_forecast( .interactive = FALSE ) ## Warning in max(ids, na.rm = TRUE): max에 전달되는 인자들 중 누락이 있어 -Inf를 ## 반환합니다 calibration_tbl %&gt;% modeltime_accuracy() ## # A tibble: 6 x 9 ## .model_id .model_desc .type mae mape mase smape rmse rsq ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 ARIMA(1,2,0) Test 79663. 1.28 0.509 1.27 8.52e4 0.998 ## 2 2 ETS(A,A,N) Test 16449. 0.263 0.105 0.263 1.75e4 0.998 ## 3 3 PROPHET Test 101824. 1.65 0.650 1.67 1.15e5 0.996 ## 4 4 LM Test 500003. 7.99 3.19 7.67 5.05e5 0.998 ## 5 5 NNAR(1,1,10)[5] Test 369674. 5.99 2.36 5.76 4.22e5 0.775 ## 6 6 BATS(0.732, {0,0}, 1, ~ Test 18767. 0.302 0.120 0.301 2.20e4 0.998 model_fit_ets &lt;- exp_smoothing() %&gt;% set_engine(engine = &quot;ets&quot;) %&gt;% fit(학생수계 ~ 연도, data = students.total) ## frequency = 5 observations per 5 years model_fit_tbats &lt;- seasonal_reg() %&gt;% set_engine(&quot;tbats&quot;) %&gt;% fit(학생수계 ~ 연도, data = students.total) ## frequency = 5 observations per 5 years (models_tbl &lt;- modeltime_table( model_fit_ets, model_fit_tbats)) ## # Modeltime Table ## # A tibble: 2 x 3 ## .model_id .model .model_desc ## &lt;int&gt; &lt;list&gt; &lt;chr&gt; ## 1 1 &lt;fit[+]&gt; ETS(A,AD,N) ## 2 2 &lt;fit[+]&gt; BATS(0.641, {0,0}, 0.819, -) models_tbl %&gt;% modeltime_forecast( h = &#39;10 years&#39;, actual_data = students.total ) %&gt;% plot_modeltime_forecast( .interactive = FALSE ) ## Warning: Expecting the following names to be in the data frame: .conf_hi, .conf_lo. ## Proceeding with &#39;.conf_interval_show = FALSE&#39; to visualize the forecast without confidence intervals. ## Alternatively, try using `modeltime_calibrate()` before forecasting to add confidence intervals. 7.3.3 미래 취업자수 예측 ### 트레이닝 셋과 테스트 셋을 나눈다 splits.employees &lt;- initial_time_split(employees, prop = 0.9) model_fit_arima &lt;- arima_reg() %&gt;% set_engine(engine = &quot;auto_arima&quot;) %&gt;% fit(total ~ time, data = training(splits.employees)) ## frequency = 12 observations per 1 year model_fit_ets &lt;- exp_smoothing() %&gt;% set_engine(engine = &quot;ets&quot;) %&gt;% fit(total ~ time, data = training(splits.employees)) ## frequency = 12 observations per 1 year model_fit_prophet &lt;- prophet_reg() %&gt;% set_engine(engine = &quot;prophet&quot;) %&gt;% fit(total ~ time, data = training(splits.employees)) ## Disabling weekly seasonality. Run prophet with weekly.seasonality=TRUE to override this. ## Disabling daily seasonality. Run prophet with daily.seasonality=TRUE to override this. model_fit_lm &lt;- linear_reg() %&gt;% set_engine(&quot;lm&quot;) %&gt;% fit(total ~ as.numeric(time) + factor(month(time, label = TRUE), ordered = FALSE), data = training(splits.employees)) model_fit_nnetar &lt;- nnetar_reg() %&gt;% set_engine(&quot;nnetar&quot;) %&gt;% fit(total ~ time, data = training(splits.employees)) ## frequency = 12 observations per 1 year model_fit_tbats &lt;- seasonal_reg() %&gt;% set_engine(&quot;tbats&quot;) %&gt;% fit(total ~ time, data = training(splits.employees)) ## frequency = 12 observations per 1 year (models_tbl &lt;- modeltime_table( model_fit_arima, model_fit_ets, model_fit_prophet, model_fit_lm, model_fit_nnetar, model_fit_tbats)) ## # Modeltime Table ## # A tibble: 6 x 3 ## .model_id .model .model_desc ## &lt;int&gt; &lt;list&gt; &lt;chr&gt; ## 1 1 &lt;fit[+]&gt; ARIMA(0,1,1)(0,1,1)[12] ## 2 2 &lt;fit[+]&gt; ETS(A,AD,A) ## 3 3 &lt;fit[+]&gt; PROPHET ## 4 4 &lt;fit[+]&gt; LM ## 5 5 &lt;fit[+]&gt; NNAR(1,1,10)[12] ## 6 6 &lt;fit[+]&gt; TBATS(1, {0,0}, 0.971, {&lt;12,3&gt;}) (calibration_tbl &lt;- models_tbl %&gt;% modeltime_calibrate(new_data = testing(splits.employees))) ## # Modeltime Table ## # A tibble: 6 x 5 ## .model_id .model .model_desc .type .calibration_data ## &lt;int&gt; &lt;list&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; ## 1 1 &lt;fit[+]&gt; ARIMA(0,1,1)(0,1,1)[12] Test &lt;tibble [10 x 4]&gt; ## 2 2 &lt;fit[+]&gt; ETS(A,AD,A) Test &lt;tibble [10 x 4]&gt; ## 3 3 &lt;fit[+]&gt; PROPHET Test &lt;tibble [10 x 4]&gt; ## 4 4 &lt;fit[+]&gt; LM Test &lt;tibble [10 x 4]&gt; ## 5 5 &lt;fit[+]&gt; NNAR(1,1,10)[12] Test &lt;tibble [10 x 4]&gt; ## 6 6 &lt;fit[+]&gt; TBATS(1, {0,0}, 0.971, {&lt;12,3&gt;}) Test &lt;tibble [10 x 4]&gt; calibration_tbl %&gt;% modeltime_forecast( new_data = testing(splits.employees), actual_data = employees ) %&gt;% plot_modeltime_forecast( .interactive = FALSE ) ## Warning in max(ids, na.rm = TRUE): max에 전달되는 인자들 중 누락이 있어 -Inf를 ## 반환합니다 calibration_tbl %&gt;% modeltime_accuracy() ## # A tibble: 6 x 9 ## .model_id .model_desc .type mae mape mase smape rmse rsq ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 ARIMA(0,1,1)(0,1,1)[12] Test 833. 3.10 4.60 3.05 840. 0.795 ## 2 2 ETS(A,AD,A) Test 730. 2.71 4.03 2.68 740. 0.757 ## 3 3 PROPHET Test 824. 3.06 4.55 3.02 833. 0.760 ## 4 4 LM Test 728. 2.71 4.02 2.67 738. 0.762 ## 5 5 NNAR(1,1,10)[12] Test 658. 2.45 3.63 2.41 715. 0.361 ## 6 6 TBATS(1, {0,0}, 0.971, {&lt;~ Test 903. 3.36 4.99 3.30 913. 0.724 model_fit_lm &lt;- linear_reg() %&gt;% set_engine(&quot;lm&quot;) %&gt;% fit(total ~ as.numeric(time) + factor(month(time, label = TRUE), ordered = FALSE), data = employees) model_fit_nnetar &lt;- nnetar_reg() %&gt;% set_engine(&quot;nnetar&quot;) %&gt;% fit(total ~ time, data = employees) ## frequency = 12 observations per 1 year (models_tbl &lt;- modeltime_table( model_fit_lm, model_fit_nnetar)) ## # Modeltime Table ## # A tibble: 2 x 3 ## .model_id .model .model_desc ## &lt;int&gt; &lt;list&gt; &lt;chr&gt; ## 1 1 &lt;fit[+]&gt; LM ## 2 2 &lt;fit[+]&gt; NNAR(1,1,10)[12] models_tbl %&gt;% modeltime_forecast( h = &#39;3 years&#39;, actual_data = employees ) %&gt;% plot_modeltime_forecast( .interactive = FALSE ) ## Warning: Expecting the following names to be in the data frame: .conf_hi, .conf_lo. ## Proceeding with &#39;.conf_interval_show = FALSE&#39; to visualize the forecast without confidence intervals. ## Alternatively, try using `modeltime_calibrate()` before forecasting to add confidence intervals. 7.3.4 미래 코로나 확진자수 예측 ### 트레이닝 셋과 테스트 셋을 나눈다 splits.covid19 &lt;- initial_time_split(wide.covid19.by.age, prop = 0.9) model_fit_arima &lt;- arima_reg() %&gt;% set_engine(engine = &quot;auto_arima&quot;) %&gt;% fit(`0-9세` ~ date, data = training(splits.covid19)) ## frequency = 7 observations per 1 week model_fit_ets &lt;- exp_smoothing() %&gt;% set_engine(engine = &quot;ets&quot;) %&gt;% fit(`0-9세` ~ date, data = training(splits.covid19)) ## frequency = 7 observations per 1 week model_fit_prophet &lt;- prophet_reg() %&gt;% set_engine(engine = &quot;prophet&quot;) %&gt;% fit(`0-9세` ~ date, data = training(splits.covid19)) ## Disabling yearly seasonality. Run prophet with yearly.seasonality=TRUE to override this. ## Disabling daily seasonality. Run prophet with daily.seasonality=TRUE to override this. model_fit_lm &lt;- linear_reg() %&gt;% set_engine(&quot;lm&quot;) %&gt;% fit(`0-9세` ~ as.numeric(date), data = training(splits.covid19)) model_fit_nnetar &lt;- nnetar_reg() %&gt;% set_engine(&quot;nnetar&quot;) %&gt;% fit(`0-9세` ~ date, data = training(splits.covid19)) ## frequency = 7 observations per 1 week model_fit_tbats &lt;- seasonal_reg() %&gt;% set_engine(&quot;tbats&quot;) %&gt;% fit(`0-9세` ~ date, data = training(splits.covid19)) ## frequency = 7 observations per 1 week (models_tbl &lt;- modeltime_table( model_fit_arima, model_fit_ets, model_fit_prophet, model_fit_lm, model_fit_nnetar, model_fit_tbats)) ## # Modeltime Table ## # A tibble: 6 x 3 ## .model_id .model .model_desc ## &lt;int&gt; &lt;list&gt; &lt;chr&gt; ## 1 1 &lt;fit[+]&gt; ARIMA(3,1,1) ## 2 2 &lt;fit[+]&gt; ETS(A,N,N) ## 3 3 &lt;fit[+]&gt; PROPHET ## 4 4 &lt;fit[+]&gt; LM ## 5 5 &lt;fit[+]&gt; NNAR(1,1,10)[7] ## 6 6 &lt;fit[+]&gt; BATS(1, {2,2}, -, -) (calibration_tbl &lt;- models_tbl %&gt;% modeltime_calibrate(new_data = testing(splits.covid19))) ## # Modeltime Table ## # A tibble: 6 x 5 ## .model_id .model .model_desc .type .calibration_data ## &lt;int&gt; &lt;list&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; ## 1 1 &lt;fit[+]&gt; ARIMA(3,1,1) Test &lt;tibble [31 x 4]&gt; ## 2 2 &lt;fit[+]&gt; ETS(A,N,N) Test &lt;tibble [31 x 4]&gt; ## 3 3 &lt;fit[+]&gt; PROPHET Test &lt;tibble [31 x 4]&gt; ## 4 4 &lt;fit[+]&gt; LM Test &lt;tibble [31 x 4]&gt; ## 5 5 &lt;fit[+]&gt; NNAR(1,1,10)[7] Test &lt;tibble [31 x 4]&gt; ## 6 6 &lt;fit[+]&gt; BATS(1, {2,2}, -, -) Test &lt;tibble [31 x 4]&gt; calibration_tbl %&gt;% modeltime_forecast( new_data = testing(splits.covid19), actual_data = wide.covid19.by.age ) %&gt;% plot_modeltime_forecast( .interactive = FALSE ) ## Warning in max(ids, na.rm = TRUE): max에 전달되는 인자들 중 누락이 있어 -Inf를 ## 반환합니다 calibration_tbl %&gt;% modeltime_accuracy() ## Warning: Problem with `mutate()` input `.nested.col`. ## i 표준편차가 0입니다 ## i Input `.nested.col` is `purrr::map(...)`. ## Warning in cor(truth, estimate): 표준편차가 0입니다 ## # A tibble: 6 x 9 ## .model_id .model_desc .type mae mape mase smape rmse rsq ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 ARIMA(3,1,1) Test 13.9 76.8 1.86 49.4 15.5 0.0227 ## 2 2 ETS(A,N,N) Test 13.8 76.2 1.84 49.1 15.4 NA ## 3 3 PROPHET Test 27.2 143. 3.63 75.2 29.0 0.0780 ## 4 4 LM Test 6.81 34.8 0.909 28.9 8.25 0.0947 ## 5 5 NNAR(1,1,10)[7] Test 16.7 90.8 2.22 55.8 18.3 0.0966 ## 6 6 BATS(1, {2,2}, -, -) Test 13.9 76.9 1.86 49.4 15.5 0.0365 model_fit_lm &lt;- linear_reg() %&gt;% set_engine(&quot;lm&quot;) %&gt;% fit(`0-9세` ~ as.numeric(date), data = wide.covid19.by.age) model_fit_ets &lt;- exp_smoothing() %&gt;% set_engine(engine = &quot;ets&quot;) %&gt;% fit(`0-9세` ~ date, data = wide.covid19.by.age) ## frequency = 7 observations per 1 week (models_tbl &lt;- modeltime_table( model_fit_lm, model_fit_ets)) ## # Modeltime Table ## # A tibble: 2 x 3 ## .model_id .model .model_desc ## &lt;int&gt; &lt;list&gt; &lt;chr&gt; ## 1 1 &lt;fit[+]&gt; LM ## 2 2 &lt;fit[+]&gt; ETS(A,N,N) models_tbl %&gt;% modeltime_forecast( h = &#39;3 months&#39;, actual_data = wide.covid19.by.age ) %&gt;% plot_modeltime_forecast( .interactive = FALSE ) ## Warning: Expecting the following names to be in the data frame: .conf_hi, .conf_lo. ## Proceeding with &#39;.conf_interval_show = FALSE&#39; to visualize the forecast without confidence intervals. ## Alternatively, try using `modeltime_calibrate()` before forecasting to add confidence intervals. https://cran.r-project.org/web/packages/parsnip/index.html https://cran.r-project.org/web/packages/modeltime/index.html https://www.tidymodels.org/start/models/ "]]
